<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Drink`s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Drink&#96;s Blog">
<meta property="og:url" content="https://drinkle.top/index.html">
<meta property="og:site_name" content="Drink&#96;s Blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Drink">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Drink`s Blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Drink`s Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://drinkle.top"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-python面试题" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/02/22/python%E9%9D%A2%E8%AF%95%E9%A2%98/" class="article-date">
  <time class="dt-published" datetime="2022-02-22T14:25:01.000Z" itemprop="datePublished">2022-02-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/02/22/python%E9%9D%A2%E8%AF%95%E9%A2%98/">python面试题</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="独到科技Python笔试"><a href="#独到科技Python笔试" class="headerlink" title="独到科技Python笔试"></a>独到科技Python笔试</h1><blockquote>
<p>建议时长 30-50min</p>
</blockquote>
<h2 id="0-简写3-4条PEP8-0规范"><a href="#0-简写3-4条PEP8-0规范" class="headerlink" title="0.简写3~4条PEP8.0规范"></a>0.简写3~4条PEP8.0规范</h2><blockquote>
<p>PEP8.0(Python Enhancement Proposal 8.0)协议[规范]</p>
</blockquote>
<h2 id="1-Python的内置-数据结构-有哪些-各有什么特点"><a href="#1-Python的内置-数据结构-有哪些-各有什么特点" class="headerlink" title="1.Python的内置 [数据结构] 有哪些?各有什么特点?"></a>1.Python的内置 [数据结构] 有哪些?各有什么特点?</h2><blockquote>
<p>可以从存储的 [数据类型] 和操作上考虑</p>
</blockquote>
<h2 id="2-Python中list与array-array有什么区别"><a href="#2-Python中list与array-array有什么区别" class="headerlink" title="2.Python中list与array.array有什么区别?"></a>2.Python中list与array.array有什么区别?</h2><blockquote>
<p>可以从存储数据的方式和类型考虑</p>
</blockquote>
<h2 id="3-什么是迭代器-什么是生成器"><a href="#3-什么是迭代器-什么是生成器" class="headerlink" title="3.什么是迭代器?什么是生成器?"></a>3.什么是迭代器?什么是生成器?</h2><blockquote>
<p>可以从两者的关系和如何避免无限迭代上考虑</p>
</blockquote>
<h2 id="4-按照顺序写出下列输出"><a href="#4-按照顺序写出下列输出" class="headerlink" title="4.按照顺序写出下列输出"></a>4.按照顺序写出下列输出</h2><blockquote>
<p>可以从Python变量赋值方式角度考虑</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">temp_1 = [[<span class="string">&quot;_&quot;</span>] * <span class="number">3</span>] *<span class="number">3</span></span><br><span class="line">temp_2 = [[<span class="string">&quot;_&quot;</span>] * <span class="number">3</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)]</span><br><span class="line"></span><br><span class="line">temp_1[<span class="number">0</span>][<span class="number">0</span>] = <span class="string">&quot;X&quot;</span></span><br><span class="line">temp_2[<span class="number">0</span>][<span class="number">0</span>] = <span class="string">&quot;O&quot;</span></span><br><span class="line"></span><br><span class="line">print(temp_1)</span><br><span class="line">print(temp_2)</span><br></pre></td></tr></table></figure>





<blockquote>
<p>可以从三者获取值时所调用的(magic method)上考虑</p>
<p>PS: 如果<code>AttributeError</code>则写<code>Error</code></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">list_1 = [<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;World&quot;</span>, <span class="string">&quot;!&quot;</span>]</span><br><span class="line">list_2 = [<span class="number">1</span>, <span class="string">&quot;&quot;</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">temp_var = <span class="built_in">dict</span>(<span class="built_in">zip</span>(list_1, list_2))</span><br><span class="line"></span><br><span class="line">print(temp_var[list_1[<span class="number">0</span>]])</span><br><span class="line">print(temp_var.hello)</span><br><span class="line">print(temp_var.get(<span class="string">&quot;World&quot;</span>))</span><br><span class="line">print(temp_var.get(<span class="string">&quot;hello, world&quot;</span>))</span><br></pre></td></tr></table></figure>





<blockquote>
<p>可以从python函数如何接受可变类型参数上考虑</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">var_1,seq=[]</span>):</span></span><br><span class="line">    seq.append(var_1)</span><br><span class="line">    <span class="keyword">return</span> seq</span><br><span class="line"></span><br><span class="line">func(<span class="number">1</span>)</span><br><span class="line">func(<span class="number">1</span>)</span><br><span class="line">print(func(<span class="number">1</span>))</span><br></pre></td></tr></table></figure>




      
    </div>
    <footer class="article-footer">
      <a data-url="https://drinkle.top/2022/02/22/python%E9%9D%A2%E8%AF%95%E9%A2%98/" data-id="cl0b5jm6l0000ecf576nkgdei" data-title="python面试题" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-流畅的python" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/02/06/%E6%B5%81%E7%95%85%E7%9A%84python/" class="article-date">
  <time class="dt-published" datetime="2022-02-06T10:02:01.000Z" itemprop="datePublished">2022-02-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/02/06/%E6%B5%81%E7%95%85%E7%9A%84python/">流畅的python</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Part0-BulitIn"><a href="#Part0-BulitIn" class="headerlink" title="Part0.BulitIn"></a>Part0.BulitIn</h1><h2 id="小知识"><a href="#小知识" class="headerlink" title="小知识"></a>小知识</h2><h3 id="format"><a href="#format" class="headerlink" title="format"></a>format</h3><table>
<thead>
<tr>
<th align="left">数字</th>
<th align="left">格式</th>
<th align="center">输出</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">3.1415926</td>
<td align="left">{:.2f}</td>
<td align="center">3.14</td>
<td align="left">保留小数点后两位</td>
</tr>
<tr>
<td align="left">3.1415926</td>
<td align="left">{:+.2f}</td>
<td align="center">+3.14</td>
<td align="left">带符号保留小数点后两位</td>
</tr>
<tr>
<td align="left">-1</td>
<td align="left">{:+.2f}</td>
<td align="center">-1.00</td>
<td align="left">带符号保留小数点后两位</td>
</tr>
<tr>
<td align="left">2.71828</td>
<td align="left">{:.0f}</td>
<td align="center">3</td>
<td align="left">不带小数</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">{:0&gt;2d}</td>
<td align="center">05</td>
<td align="left">数字补零 (填充左边, 宽度为2)</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">{:x&lt;4d}</td>
<td align="center">5xxx</td>
<td align="left">数字补x (填充右边, 宽度为4)</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left">{:x&lt;4d}</td>
<td align="center">10xx</td>
<td align="left">数字补x (填充右边, 宽度为4)</td>
</tr>
<tr>
<td align="left">1000000</td>
<td align="left">{:,}</td>
<td align="center">1,000,000</td>
<td align="left">以逗号分隔的数字格式</td>
</tr>
<tr>
<td align="left">0.25</td>
<td align="left">{:.2%}</td>
<td align="center">25.00%</td>
<td align="left">百分比格式</td>
</tr>
<tr>
<td align="left">1000000000</td>
<td align="left">{:.2e}</td>
<td align="center">1.00e+09</td>
<td align="left">指数记法</td>
</tr>
<tr>
<td align="left">13</td>
<td align="left">{:&gt;10d}</td>
<td align="center">13</td>
<td align="left">右对齐 (默认, 宽度为10)</td>
</tr>
<tr>
<td align="left">13</td>
<td align="left">{:&lt;10d}</td>
<td align="center">13</td>
<td align="left">左对齐 (宽度为10)</td>
</tr>
<tr>
<td align="left">13</td>
<td align="left">{:^10d}</td>
<td align="center">13</td>
<td align="left">中间对齐 (宽度为10)</td>
</tr>
<tr>
<td align="left">11</td>
<td align="left"><code>&#39;&#123;:b&#125;&#39;.format(11) &#39;&#123;:d&#125;&#39;.format(11) &#39;&#123;:o&#125;&#39;.format(11) &#39;&#123;:x&#125;&#39;.format(11) &#39;&#123;:#x&#125;&#39;.format(11) &#39;&#123;:#X&#125;&#39;.format(11)</code></td>
<td align="center"><code>1011 11 13 b 0xb 0XB</code></td>
<td align="left">进制</td>
</tr>
</tbody></table>
<p><strong>^</strong>, <strong>&lt;**, **&gt;</strong> 分别是居中、左对齐、右对齐，后面带宽度， <strong>:</strong> <strong>号后面带填充的字符</strong>，**只能是一个字符[即只能填充一次]**，不指定则默认是用空格填充。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 即长度为多少</span></span><br><span class="line"><span class="built_in">str</span> = <span class="string">&quot;1&#123;:15&#125;&quot;</span>.<span class="built_in">format</span>(<span class="string">&quot;&amp;&quot;</span>)</span><br><span class="line">print(string_1, <span class="built_in">len</span>(<span class="built_in">str</span>))</span><br><span class="line">|<span class="number">1</span>&amp;               |</span><br><span class="line"><span class="number">16</span></span><br></pre></td></tr></table></figure>

<p><strong>+</strong> 表示在正数前显示 **+**，负数前显示 **-**； （空格）表示在正数前加空格</p>
<p>b、d、o、x 分别是二进制、十进制、八进制、十六进制。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># &#123;&#125; format</span></span><br><span class="line"><span class="comment"># &#123;0&#125; format the index</span></span><br><span class="line"><span class="comment"># &#123;0:2d&#125; format the type --&gt; d int 2d: remain two int</span></span><br><span class="line"><span class="comment"># &#123;&lt;2d&#125; 左对齐，宽度为2d，不足补空格</span></span><br><span class="line">ROW_FMT = <span class="string">&quot;&#123;0:2d&#125;  @ &#123;1:2d&#125;   &#123;2&#125; &#123;0:&lt;2d&#125;&quot;</span></span><br><span class="line">print(ROW_FMT.<span class="built_in">format</span>(needle, posotion, offset))</span><br></pre></td></tr></table></figure>

<h2 id="Attention"><a href="#Attention" class="headerlink" title="Attention"></a>Attention</h2><h3 id="函数-方法返回"><a href="#函数-方法返回" class="headerlink" title="函数|方法返回"></a>函数|方法返回</h3><p>python 会对operation返回return None来表示对对象的就地更改, 即不会id(obj)不会变</p>
<ul>
<li>用返回None来表示就地改动有一个弊端, 即调用者无法将其串联起来; 而返回一个新对象的方法(比如说str里的所有方法)则正好相反, 他们可以串联起来调用</li>
</ul>
<h3 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h3><p>sort分为两种， 一种是value sort即根据值进行排序， 另一种是time sort即就算两个元素比不出大小， 但在每次排序的结果里他们的相对位置是固定的</p>
<h3 id="推导式"><a href="#推导式" class="headerlink" title="推导式"></a>推导式</h3><ul>
<li>一般推导式的作用 <code>[]</code> <code>&#123;&#125;</code><ul>
<li>创建新的数据对象</li>
<li>过滤作用</li>
</ul>
</li>
</ul>
<h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><h3 id="1-python中list和array的区别"><a href="#1-python中list和array的区别" class="headerlink" title="1.python中list和array的区别"></a>1.python中list和array的区别</h3><ul>
<li>list是python的内置数据类型</li>
<li>list中的数据类不必相同的</li>
<li>array的中的类型必须全部相同</li>
<li>在list中的数据类型保存的是数据存放的地址，简单的说就是指针，并非数据</li>
<li>这种保存方式增加了存储和CPU的消耗例如list1=[1,2,3,’a’]需要4个指针和四个数据</li>
<li>数组在背后存的并不是float对象，而是数字的机器翻译，也就是字节表述。这一点和c语言中的数组一样</li>
<li>array创建的数组不适用于数字操作（比如矩阵和矢量运算）。另外+=和*=运算符可以用于array的添加。</li>
<li>从python3.4开始，数组（array）类型不再支持诸如list.sort()这种就地排序方法。要给数组排序的话，得用sorted函数新建一个数组：</li>
</ul>
<h2 id="Magic-Method"><a href="#Magic-Method" class="headerlink" title="Magic Method"></a>Magic Method</h2><p><strong>表1:跟运算符无关的 magic method</strong></p>
<table>
<thead>
<tr>
<th align="center">类别</th>
<th align="center">方法名</th>
</tr>
</thead>
<tbody><tr>
<td align="center">字符串/字节序列表示形式</td>
<td align="center">repr str format bytes</td>
</tr>
<tr>
<td align="center">数值转换</td>
<td align="center">abs bool complex int float hash index</td>
</tr>
<tr>
<td align="center">集合模拟</td>
<td align="center">len getitem setitem delitem contains</td>
</tr>
<tr>
<td align="center">迭代枚举</td>
<td align="center">iter reversed next</td>
</tr>
<tr>
<td align="center">可调用模拟</td>
<td align="center">call</td>
</tr>
<tr>
<td align="center">上下文管理</td>
<td align="center">enter exit</td>
</tr>
<tr>
<td align="center">实例创建/销毁</td>
<td align="center">new init del</td>
</tr>
<tr>
<td align="center">属性管理</td>
<td align="center">getattr getattribute setattr delattr dir</td>
</tr>
<tr>
<td align="center">属性描述符</td>
<td align="center">get set delete</td>
</tr>
<tr>
<td align="center">跟类有关的服务</td>
<td align="center">prepare instancecheck subclasscheck</td>
</tr>
</tbody></table>
<p><strong>表2:跟运算符相关的 magic method</strong></p>
<table>
<thead>
<tr>
<th align="center">类别</th>
<th align="center">方法名和对应的运算符</th>
</tr>
</thead>
<tbody><tr>
<td align="center">一元运算符</td>
<td align="center">neg - pos + abs abs()</td>
</tr>
<tr>
<td align="center">众多比较运算符</td>
<td align="center">lt &lt; le &lt;= eq == ne != gt &gt; ge &gt;=</td>
</tr>
<tr>
<td align="center">算术运算符</td>
<td align="center">add + sub - mul * truediv / floordiv // mod % divmod divmod() pow **|pow() round round()</td>
</tr>
<tr>
<td align="center">反向算术运算符</td>
<td align="center">radd rsub rmul rturediv rfloordiv rmod rdivmod  rpow</td>
</tr>
<tr>
<td align="center">增量赋值算术运算符</td>
<td align="center">iadd isub imul itruediv ifloordic imod ipow</td>
</tr>
<tr>
<td align="center">位运算符</td>
<td align="center">invert ~ lshift &lt;&lt; rshift &gt;&gt; and &amp; or | xor ^</td>
</tr>
<tr>
<td align="center">反向位运算符</td>
<td align="center">rlshift rrshift rand rxor ror</td>
</tr>
<tr>
<td align="center">增量赋值位运算符</td>
<td align="center">ilshift irshift iand ixor ior</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注: 以下所有的keyword默认为 self.__xx__():</span><br></pre></td></tr></table></figure>

<h3 id="bool-len"><a href="#bool-len" class="headerlink" title="bool|len"></a>bool|len</h3><p>默认情况下我们定义的类的实例总是被认为<code>True</code>,除非在<code>define class</code>中有实现<code>bool或者len</code></p>
<p><code>bool()</code>的背后其实是调用<code>x.__bool__()</code>的结果;如果<code>x.__bool__()</code>不存在, 则调用<code>len()</code>即<code>x.__len__()</code>,如果为<code>0-False other-True</code></p>
<p>调用优先级为<code>bool &gt; len</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># define a class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">temp</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.value = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    !<span class="function"><span class="keyword">def</span> <span class="title">__bool__</span>(<span class="params">self</span>):</span></span><br><span class="line">    !   <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">&gt;</span><br><span class="line"><span class="built_in">bool</span>(temp) <span class="literal">False</span></span><br><span class="line">? bool(temp) True</span><br></pre></td></tr></table></figure>



<h3 id="and-mul"><a href="#and-mul" class="headerlink" title="and|mul"></a>and|mul</h3><p><code>and --&gt; +  add</code></p>
<p><code>mul --&gt; *  multiple</code></p>
<h3 id="str-repr"><a href="#str-repr" class="headerlink" title="str|repr"></a>str|repr</h3><p>两者的却别在于<code>str will called by str() and print(), repr can only called by print()</code></p>
<p>如果两者特殊方法保留一个<code>repr</code>会是更好的选择, 因为在没有<code>str</code>时, 解释器会调用<code>repr</code></p>
<p>优先级<code>str &gt; repr </code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># define a class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">temp</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.value = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;repr value is <span class="subst">&#123;self.value&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;str value is <span class="subst">&#123;self.value&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">test = temp()</span><br><span class="line">print(test)</span><br><span class="line"></span><br><span class="line">H:\Python\python.exe H:/MY_TXM/test.py</span><br><span class="line"><span class="built_in">str</span> value <span class="keyword">is</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="Moudle"><a href="#Moudle" class="headerlink" title="Moudle"></a>Moudle</h2><h3 id="OS"><a href="#OS" class="headerlink" title="OS"></a>OS</h3><h4 id="listdir"><a href="#listdir" class="headerlink" title="listdir"></a>listdir</h4><blockquote>
<p>列出目录下的所有文件和文件夹不包括<code>.</code> <code>..</code>隐藏目录</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">print(os.listdir(<span class="string">&quot;H:\MY_TXM&quot;</span>))</span><br><span class="line">&gt;&gt;</span><br><span class="line">[<span class="string">&#x27;.git&#x27;</span>, <span class="string">&#x27;.gitignore&#x27;</span>, <span class="string">&#x27;.idea&#x27;</span>, <span class="string">&#x27;static&#x27;</span>, <span class="string">&#x27;venv&#x27;</span>]</span><br></pre></td></tr></table></figure>

<h3 id="locale"><a href="#locale" class="headerlink" title="locale"></a>locale</h3><blockquote>
<p>locale 是根据计算机用户所使用的语言，所在国家或者地区，以及当地的文化传统所定义的一个软件运行时的语言环境。通常情况下它可以按照涉及使用习惯分为12大类:</p>
</blockquote>
<ul>
<li>语言符号及其分类（LC_CTYPE)</li>
<li>数字（LC_NUMBERIC）</li>
<li>比较习惯（LC_COLLATE)</li>
<li>时间显示格式（LC_TIME）</li>
<li>货币单位（LC_MONETARY)</li>
<li>信息主要是提示信息，错误信息，状态信息，标题，标签，按钮和菜单等（LC_MESSAGES）</li>
<li>行么书写方式（LC_NAME）</li>
<li>地址书写方式（LC_ADDRESS）</li>
<li>电话号码书写方式（LC_TELEPHONE）<br>-度量衡表达方式（LC_MEASUREMENT）</li>
<li>默认纸张尺寸大小（LC_PAPER）</li>
<li>对locale 自身包含信息的概述（LC_IDENTIFICATION）</li>
<li>除此之外还有一个LANGUAGE参数，它与LC_MESSAGES相似</li>
</ul>
<h3 id="time"><a href="#time" class="headerlink" title="time"></a>time</h3><h4 id="time-1"><a href="#time-1" class="headerlink" title="time"></a>time</h4><h4 id="process-time"><a href="#process-time" class="headerlink" title="process_time"></a>process_time</h4><h4 id="process-time-ns"><a href="#process-time-ns" class="headerlink" title="process_time_ns"></a>process_time_ns</h4><h4 id="perf-counter"><a href="#perf-counter" class="headerlink" title="perf_counter"></a>perf_counter</h4><h4 id="perf-counter-ns"><a href="#perf-counter-ns" class="headerlink" title="perf_counter_ns"></a>perf_counter_ns</h4><p><code>time()</code>精度上相对没有那么高，而且受系统的影响，适合表示日期时间或者大程序程序的计时。</p>
<p><code>perf_counter()</code>适合小一点的程序测试，会计算<code>sleep()</code>时间。</p>
<p><code>process_counter()</code>适合小一点的程序测试，不会计算<code>sleep()</code>时间。</p>
<p>此外<code>Python3.7</code>开始还提供了以上三个方法精确到<code>纳秒</code>的计时。分别是：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">time.perf_counter_ns()</span><br><span class="line">time.process_time_ns()</span><br><span class="line">time.time_ns()</span><br></pre></td></tr></table></figure>

<h3 id="arrary"><a href="#arrary" class="headerlink" title="arrary"></a>arrary</h3><p>数组所接受的typecode以及其对应的存储数据类型</p>
<table>
<thead>
<tr>
<th align="left">Type code</th>
<th align="left">C Type</th>
<th align="left">Python Type</th>
<th align="left">Minimum size in bytes</th>
<th align="left">Notes</th>
</tr>
</thead>
<tbody><tr>
<td align="left">‘b’</td>
<td align="left">signed char</td>
<td align="left">int</td>
<td align="left">1</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">‘B’</td>
<td align="left">unsigned char</td>
<td align="left">int</td>
<td align="left">1</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">‘u’</td>
<td align="left">Py_UNICODE</td>
<td align="left">Unicode character</td>
<td align="left">2</td>
<td align="left">(1)</td>
</tr>
<tr>
<td align="left">‘h’</td>
<td align="left">signed short</td>
<td align="left">int</td>
<td align="left">2</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">‘H’</td>
<td align="left">unsigned short</td>
<td align="left">int</td>
<td align="left">2</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">‘i’</td>
<td align="left">signed int    int</td>
<td align="left">2</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">‘I’</td>
<td align="left">unsigned int</td>
<td align="left">int</td>
<td align="left">2</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">‘l’</td>
<td align="left">signed long</td>
<td align="left">int</td>
<td align="left">4</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">‘L’</td>
<td align="left">unsigned long</td>
<td align="left">int</td>
<td align="left">4</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">‘q’</td>
<td align="left">signed long long    int</td>
<td align="left">8</td>
<td align="left">(2)</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">‘Q’</td>
<td align="left">unsigned long long</td>
<td align="left">int</td>
<td align="left">8</td>
<td align="left">(2)</td>
</tr>
<tr>
<td align="left">‘f’</td>
<td align="left">float</td>
<td align="left">float</td>
<td align="left">4</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">‘d’</td>
<td align="left">double</td>
<td align="left">float</td>
<td align="left">8</td>
<td align="left"></td>
</tr>
</tbody></table>
<h3 id="bisect"><a href="#bisect" class="headerlink" title="bisect"></a>bisect</h3><p>bisect是一个根据二分算法写的库，其中主要的俩个方法是bisect和insert，根本上根据二分算法算出有序序列的索引，可以当做快速定位index使用</p>
<h4 id="bisect-bisect-left"><a href="#bisect-bisect-left" class="headerlink" title="bisect|bisect_left"></a>bisect|bisect_left</h4><p>接受一个有序序列，一个元素，返回该元素在有序序列的索引，索引以前全≤该元素，<code>bisect(bisect_right)|bisect_left</code>主要区别是如果俩对比元素相等，前者返回index是从右边插入，后者左边</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> bisect</span><br><span class="line">temp_sequence = [<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">index = bisect.bisect(temp_sequence, <span class="number">2</span>)</span><br><span class="line">_index = bisect.bisect_left(temp_sequence, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">print(index)</span><br><span class="line">print(_index)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<h4 id="insort"><a href="#insort" class="headerlink" title="insort"></a>insort</h4><p>根据bisect或者bisect_left返回的index进行插入，接受有序序列，返回有序序列</p>
<h3 id="itertools"><a href="#itertools" class="headerlink" title="itertools"></a>itertools</h3><h4 id="groupby"><a href="#groupby" class="headerlink" title="groupby"></a>groupby</h4><p>和<code>nlargest() nsmallest()</code>一样支持<code>key=</code></p>
<p>【聚合】</p>
<p>有时候我们需要给一个<code>sequence</code>按照某个属性分组，可以借助groupby来实现,groupby常常和<code>lambda map operator.itemgetter</code>一起使用，因为在分组前，大多希望相关的数据聚集在一起， 这样对于groupby来说分组才有意义</p>
<p>语法：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">groupby(seqence, key)</span><br><span class="line">args:</span><br><span class="line">    sequence must iterable</span><br><span class="line">    key sort the sequence 聚合</span><br><span class="line">return iterator contains key, data --&gt; type tuple</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ol>
<li>如果groupby中的key=None，那么group后的key是被group中的element， 如果key=fun那么group后的key是fun(element)</li>
<li>返回的数据<ul>
<li>type(key) type(element) </li>
<li>type(data) iterator</li>
</ul>
</li>
</ol>
<p>实列：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">a = [&#123;<span class="string">&#x27;severity&#x27;</span>: <span class="string">&#x27;严重&#x27;</span>&#125;, &#123;<span class="string">&#x27;severity&#x27;</span>: <span class="string">&#x27;严重&#x27;</span>&#125;, &#123;<span class="string">&#x27;severity&#x27;</span>: <span class="string">&#x27;不严重&#x27;</span>&#125;, &#123;<span class="string">&#x27;severity&#x27;</span>: <span class="string">&#x27;严重&#x27;</span>&#125;]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果不将数据进行排序直接group</span></span><br><span class="line"><span class="keyword">for</span> key, data <span class="keyword">in</span> groupby(a):</span><br><span class="line">    print(key, <span class="built_in">list</span>(data))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将会输出三组key</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&#123;&#x27;severity&#x27;: &#x27;严重&#x27;&#125; [&#123;&#x27;severity&#x27;: &#x27;严重&#x27;&#125;, &#123;&#x27;severity&#x27;: &#x27;严重&#x27;&#125;]</span></span><br><span class="line"><span class="string">&#123;&#x27;severity&#x27;: &#x27;不严重&#x27;&#125; [&#123;&#x27;severity&#x27;: &#x27;不严重&#x27;&#125;]</span></span><br><span class="line"><span class="string">&#123;&#x27;severity&#x27;: &#x27;严重&#x27;&#125; [&#123;&#x27;severity&#x27;: &#x27;严重&#x27;&#125;]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对数据进行聚合(排序)但不对group的key进行筛选</span></span><br><span class="line">a.sort(key=itemgetter(<span class="string">&quot;severity&quot;</span>))</span><br><span class="line"><span class="keyword">for</span> key, data <span class="keyword">in</span> groupby(a):</span><br><span class="line">    print(key, <span class="built_in">list</span>(data))</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 此时的key时a中的单个element</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&#123;&#x27;severity&#x27;: &#x27;不严重&#x27;&#125; [&#123;&#x27;severity&#x27;: &#x27;不严重&#x27;&#125;]</span></span><br><span class="line"><span class="string">&#123;&#x27;severity&#x27;: &#x27;严重&#x27;&#125; [&#123;&#x27;severity&#x27;: &#x27;严重&#x27;&#125;, &#123;&#x27;severity&#x27;: &#x27;严重&#x27;&#125;, &#123;&#x27;severity&#x27;: &#x27;严重&#x27;&#125;]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对数据进行聚合(排序)且对group的key进行筛选</span></span><br><span class="line">a.sort(key=itemgetter(<span class="string">&quot;severity&quot;</span>))</span><br><span class="line"><span class="keyword">for</span> key, data <span class="keyword">in</span> groupby(a, key=itemgetter(<span class="string">&quot;severity&quot;</span>)):</span><br><span class="line">    print(key, <span class="built_in">list</span>(data))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时的group返回的key是经过滤后的key</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">不严重 [&#123;&#x27;severity&#x27;: &#x27;不严重&#x27;&#125;]</span></span><br><span class="line"><span class="string">严重 [&#123;&#x27;severity&#x27;: &#x27;严重&#x27;&#125;, &#123;&#x27;severity&#x27;: &#x27;严重&#x27;&#125;, &#123;&#x27;severity&#x27;: &#x27;严重&#x27;&#125;]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="operator"><a href="#operator" class="headerlink" title="operator"></a>operator</h3><h4 id="itemgetter"><a href="#itemgetter" class="headerlink" title="itemgetter"></a>itemgetter</h4><p>operator模块提供的itemgetter函数主要用于获取某一对象 <strong>特定维度的数据，</strong>其中的参数为特定维度的索引</p>
<p>operator.itemgetter函数获取的并不是某一个数值，而是<strong>某一个函数</strong>常常可以使用<code>lambda </code>函数替换</p>
<p>用法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">itemgetter(var)</span><br><span class="line">args:</span><br><span class="line">    var can accept index <span class="keyword">and</span> key</span><br><span class="line"><span class="keyword">return</span> fun()</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import operator</span><br><span class="line"></span><br><span class="line">a = [&#123;&quot;age&quot;: 10, &quot;socre&quot;: 90&#125;, &#123;&quot;age&quot;: 9, &quot;socre&quot;: 98&#125;, &#123;&quot;age&quot;: 0, &quot;socre&quot;: 50&#125;, &#123;&quot;age&quot;: 15, &quot;socre&quot;: 56&#125;]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 定义一个获取维度数据的函数</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取sequence的index=0&amp;1的数据</span></span><br><span class="line">condition = operator.itemgetter(0, 1)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将sequence传入获取函数中</span></span><br><span class="line">res = condition(a)</span><br><span class="line">print(res, type(a))</span><br><span class="line">(&#123;&#x27;age&#x27;: 10, &#x27;socre&#x27;: 90&#125;, &#123;&#x27;age&#x27;: 9, &#x27;socre&#x27;: 98&#125;) &lt;class &#x27;tuple&#x27;&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 对a的age进行排序</span></span><br><span class="line">a.sort(key=itemgetter(&quot;age&quot;))</span><br><span class="line">a.sort(key=lambda x: x[&quot;socre&quot;], reverse=True)</span><br><span class="line">print(a)</span><br><span class="line">[&#123;&#x27;age&#x27;: 0, &#x27;socre&#x27;: 50&#125;, &#123;&#x27;age&#x27;: 9, &#x27;socre&#x27;: 98&#125;, &#123;&#x27;age&#x27;: 10, &#x27;socre&#x27;: 90&#125;, &#123;&#x27;age&#x27;: 15, &#x27;socre&#x27;: 56&#125;]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 先对age排序在对score排序</span></span><br><span class="line">a.sort(key=itemgetter(&quot;age&quot;, &quot;socre&quot;), reverse=True)</span><br></pre></td></tr></table></figure>

<h3 id="headq"><a href="#headq" class="headerlink" title="headq"></a>headq</h3><h4 id="nlargest"><a href="#nlargest" class="headerlink" title="nlargest"></a>nlargest</h4><h4 id="nsmallest"><a href="#nsmallest" class="headerlink" title="nsmallest"></a>nsmallest</h4><p>和<code>groupby()</code>一样支持<code>key=</code></p>
<p> 介绍：</p>
<p>这两个函数可以帮助我们在某个集合中找出最大或最小的N个元素</p>
<p>语法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nlargest</span>(<span class="params">n, iterable, key=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Find the n largest elements in a dataset.</span></span><br><span class="line"><span class="string">    Equivalent to:  sorted(iterable, key=key, reverse=True)[:n]</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="random"><a href="#random" class="headerlink" title="random"></a>random</h3><ul>
<li>注意如果在random.method之前使用了seed，那么random.method每次都将按照一定规则返回相同的数值</li>
</ul>
<h4 id="shuffle"><a href="#shuffle" class="headerlink" title="shuffle"></a>shuffle</h4><p>语法:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">random.shuffle(iterable)</span><br><span class="line">args:</span><br><span class="line">    iterbale a <span class="built_in">list</span> <span class="keyword">or</span> <span class="built_in">tuple</span> (sequence)</span><br><span class="line"><span class="keyword">return</span>:</span><br><span class="line">	the origin sequence but the position of element is random ==&gt; None</span><br></pre></td></tr></table></figure>

<p>实列:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">print(a, <span class="built_in">id</span>(a))</span><br><span class="line"></span><br><span class="line"><span class="comment"># operation in ori return None</span></span><br><span class="line">random.shuffle(a)</span><br><span class="line"></span><br><span class="line">print(a, <span class="built_in">id</span>(a))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>] <span class="number">2200356865544</span></span><br><span class="line"><span class="literal">None</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>] <span class="number">2200356865544</span></span><br></pre></td></tr></table></figure>

<h4 id="seed"><a href="#seed" class="headerlink" title="seed"></a>seed</h4><p>调用 <code>random.random()|shuffle </code>生成随机数时，每一次生成的数都是随机的。<br>但是，当使用<code> random.seed(x)</code> 设定好种子之后，其中的 <code>x </code>可以是任意数字，这个时候，先调用<code>seed</code>的情况下，使用 <code>random() </code>生成的随机数将会是同一个</p>
<h4 id="randrange"><a href="#randrange" class="headerlink" title="randrange"></a>randrange</h4><p>从指定范围内，按指定基数递增的集合中 获取一个随机数。</p>
<p><code>random.randrange([start], stop[, step])</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 结果相当于从[10, 12, 14, 16, … 96, 98]序列中获取一个随机数。</span></span><br><span class="line">random.randrange(<span class="number">10</span>, <span class="number">100</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<h4 id="sample"><a href="#sample" class="headerlink" title="sample"></a>sample</h4><p><code>random.sample</code>的函数原型为：<code>random.sample(sequence, k)</code>从指定序列中随机获取指定长度的片断。sample函数不会修改原有序列。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">temp = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line">print(temp, <span class="built_in">id</span>(temp))</span><br><span class="line">random_choice = random.sample(temp, <span class="number">3</span>)</span><br><span class="line">print(random_choice, <span class="built_in">id</span>(random_choice))</span><br><span class="line">print(<span class="built_in">id</span>(temp))</span><br><span class="line"></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>] <span class="number">2483596469896</span></span><br><span class="line">[<span class="number">7</span>, <span class="number">8</span>, <span class="number">3</span>] <span class="number">2483594327944</span></span><br><span class="line"><span class="number">2483596469896</span></span><br></pre></td></tr></table></figure>

<h3 id="dis"><a href="#dis" class="headerlink" title="dis"></a>dis</h3><h4 id="dis-dis"><a href="#dis-dis" class="headerlink" title="dis.dis"></a>dis.dis</h4><p>Python代码在执行的时候，会被编译为Python字节码，再由Python虚拟机执行Python字节码。有时候就我们执行python文件的时候会生成一个pyc文件，这个pyc文件即用于存储Python字节码指令，而这些字节码是一种类似于汇编指令的中间语言，但是每个字节码对应的不是机器指令，而是一段C代码。</p>
<p>而dis模块，就是用于查看这些字节码的运行轨迹，因此我们可以用dis模块判断两个函数的内存占用谁会更大，谁会更消耗CPU性能，不仅如此，通过指令，我们还可以知道Python中一些内置函数、变量的取值过程、运行逻辑，对于我们代码性能并优化代码很有帮助。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> dis</span><br><span class="line">dis.dis(<span class="string">&quot;ori_tuple[index] += mutable_sequence&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="number">1</span>           <span class="number">0</span> LOAD_NAME                <span class="number">0</span> (ori_tuple)</span><br><span class="line">              <span class="number">2</span> LOAD_NAME                <span class="number">1</span> (index)</span><br><span class="line">              <span class="number">4</span> DUP_TOP_TWO</span><br><span class="line">              <span class="number">6</span>             <span class="comment"># 实现 TOS = TOS1[TOS] </span></span><br><span class="line">              <span class="number">8</span> LOAD_NAME                <span class="number">2</span> (mutable_sequence)</span><br><span class="line">             <span class="number">10</span> INPLACE_ADD</span><br><span class="line">             <span class="number">12</span> ROT_THREE</span><br><span class="line">             <span class="number">14</span> STORE_SUBSCR</span><br><span class="line">             <span class="number">16</span> LOAD_CONST               <span class="number">0</span> (<span class="literal">None</span>)</span><br><span class="line">             <span class="number">18</span> RETURN_VALUE</span><br></pre></td></tr></table></figure>

<p>字节码操作:</p>
<ul>
<li><p>假设</p>
<ul>
<li>ori_tuple = (1, 2,  [10, 20])</li>
<li>index = 2</li>
<li>mutable_sequence = [30, 40]</li>
</ul>
</li>
<li><p>6 BINARY_SUBSCR 将 <code>ori_tuple[index]</code>的值存入<code>TOS</code>(Top Of Stack)</p>
</li>
<li><p>10 INPLACE_ADD 计算<code>ori_tuple[index] += mutable_sequence</code>, 这一步骤可以完成, 是因为<code>TOS</code>指向的是一个可变对象</p>
</li>
<li><p>14 STORE_SUBSCR 赋值, 这一步骤失败, 是因为tuple属于不可变序列(immutable)</p>
</li>
</ul>
<hr>
<p>我们从这个操作中可以得到三个教训:</p>
<ol>
<li>不要把可变对象放在元组中</li>
<li>增量赋值(+=)不是一个原子操作, 在计算完后的赋值阶段如果抛出异常, 计算仍然会完成</li>
</ol>
<p>譬如:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">b = (1, 2, [10, 20])</span><br><span class="line">b += [30, 40]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;input&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">TypeError: can only concatenate tuple (not &quot;list&quot;) to tuple</span><br><span class="line">print(b)</span><br><span class="line">(1, 2, [10, 20])</span><br></pre></td></tr></table></figure>

<p><strong>在上述实列中, 即使在最后的赋值阶段tuple抛出异常, 但是此时tuple的数据依然发生了改变!</strong></p>
<table>
<thead>
<tr>
<th align="center">Python字节码 name(variable)</th>
<th>执行操作</th>
</tr>
</thead>
<tbody><tr>
<td align="center">LOAD_NAME</td>
<td>将与 <code>co_names[namei]</code> 相关联的值推入栈顶。</td>
</tr>
<tr>
<td align="center">DUP_TOP_TWO</td>
<td>复制堆栈顶部的两个引用，使它们保持相同的顺序。</td>
</tr>
<tr>
<td align="center">BINARY_SUBSCR</td>
<td>实现 <code>TOS = TOS1[TOS]</code> 。</td>
</tr>
<tr>
<td align="center">INPLACE_ADD</td>
<td>就地实现 <code>TOS = TOS1 + TOS</code> 。</td>
</tr>
<tr>
<td align="center">ROT_THREE</td>
<td>将第二个和第三个堆栈项向上提升一个位置，顶项移动到位置三。</td>
</tr>
<tr>
<td align="center">STORE_SUBSCR</td>
<td>实现 <code>TOS1[TOS] = TOS2</code> 。</td>
</tr>
<tr>
<td align="center">LOAD_CONST</td>
<td>将 <code>co_consts[consti]</code> 推入栈顶</td>
</tr>
<tr>
<td align="center">RETURN_VALUE</td>
<td>返回 TOS 到函数的调用者。</td>
</tr>
</tbody></table>
<ul>
<li>引用<a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/dis.html">dis — Python 字节码反汇编器 — Python 3.10.2 文档</a></li>
</ul>
<h3 id="sys"><a href="#sys" class="headerlink" title="sys"></a>sys</h3><h4 id="getsizeof"><a href="#getsizeof" class="headerlink" title="getsizeof"></a>getsizeof</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">getsizeof(object, default) -&gt; int</span><br><span class="line">Return the size of <span class="built_in">object</span> <span class="keyword">in</span> <span class="built_in">bytes</span>.</span><br></pre></td></tr></table></figure>

<p>获取对象所消耗的内存大小</p>
<h4 id="argv"><a href="#argv" class="headerlink" title="argv"></a>argv</h4><p>是一个从程序外部获取参数的桥梁，从外部取得的参数可以是多个，所以获得的是一个列表（list)，也就是说sys.argv其实可以看作是一个列表，所以才能用[]提取其中的元素。其第一个元素是程序本身，随后才依次是外部给予的参数。</p>
<h3 id="memoryview"><a href="#memoryview" class="headerlink" title="memoryview"></a>memoryview</h3><p>memoryview**[内存视图]<strong>是一个内置类, 它能让用户在不复制内容的情况下操作同一个数组的不同切片,其实内存试图时泛化和去数学化的</strong>numpy数组**,它允许你在不复制内容的前提下,在数据结构之间共享内存, 其中数据结构可以是任何形式,这个功能在处理大型数据集合的时候十分重要</p>
<p>memoryview 语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">memoryview(obj)</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li>obj – 对象</li>
</ul>
<p>返回元组列表(物理地址)。</p>
<h4 id="cast"><a href="#cast" class="headerlink" title=".cast"></a>.cast</h4><p><strong>memoryview.cast</strong>的概念和数组模型差不多,能用不同的方式读写同一块内存地址,而且内容字节不会随意移动,和C语言中类型转换的概念相似.cast会把同一块内存里的内容打包成一个全新的memoryview对象给你</p>
<h2 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h2><h3 id="eval"><a href="#eval" class="headerlink" title="eval"></a>eval</h3><p><strong>描述</strong></p>
<p>eval() 函数用来执行一个字符串表达式，并返回表达式的值。</p>
<p><strong>语法</strong></p>
<p>以下是 eval() 方法的语法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eval(expression[, globals[, locals]])</span><br></pre></td></tr></table></figure>

<p><strong>参数</strong></p>
<ul>
<li>expression – 表达式。</li>
<li>globals – 变量作用域，全局命名空间，如果被提供，则必须是一个字典对象。</li>
<li>locals – 变量作用域，局部命名空间，如果被提供，可以是任何映射对象。</li>
</ul>
<p><strong>返回值</strong></p>
<p>返回表达式计算结果。</p>
<h3 id="isatty"><a href="#isatty" class="headerlink" title="isatty"></a>isatty</h3><blockquote>
<p><strong>isatty()</strong> 方法检测文件是否连接到一个终端设备，如果是返回 True，否则返回 False。</p>
</blockquote>
<p><strong>语法</strong></p>
<p>isatty() 方法语法如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fileObject.isatty()</span><br></pre></td></tr></table></figure>

<h3 id="assert"><a href="#assert" class="headerlink" title="assert"></a>assert</h3><blockquote>
<p>python断言和try-except用法相反</p>
</blockquote>
<p>断言函数是对表达式布尔值的判断，要求表达式计算值必须为真。可用于自动调试。</p>
<p>如果表达式为假，触发异常；如果表达式为真，不执行任何操作。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span> condition</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> condition:</span><br><span class="line">    <span class="keyword">raise</span> AssertionError()</span><br></pre></td></tr></table></figure>

<h3 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a>reverse</h3><h3 id="reversed"><a href="#reversed" class="headerlink" title="reversed"></a>reversed</h3><ol>
<li><code>s.reverse()</code>就地排序, <code>id(s)</code>不变</li>
<li><code>reversed(s)</code>返回<code>s</code>的<strong>倒序迭代器</strong></li>
</ol>
<h3 id="id"><a href="#id" class="headerlink" title="id"></a>id</h3><p>返回对象的物理存储地址, 一般用作操作符是或否创建了一个新对象, 比较两个对象的物理地址是否相同使用<code>is</code></p>
<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>提供的函数对指定序列做映射。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>(function, iterable, ...)</span><br></pre></td></tr></table></figure>

<h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p><strong>filter()</strong> 函数用于过滤序列，过滤掉不符合条件的元素，返回由符合条件元素组成的新列表。</p>
<p><em>Python2.7 返回列表，Python3.x 返回迭代器对象</em></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">filter</span>(function, iterable)</span><br><span class="line"><span class="comment"># 通常和map函数一起使用</span></span><br></pre></td></tr></table></figure>

<p>Python2.x 中返回的是过滤后的列表, 而 Python3 中返回到是一个 filter 类。</p>
<p>filter 类实现了 <strong>iter</strong> 和 <strong>next</strong> 方法, 可以看成是一个迭代器, 有惰性运算的特性, 相对 Python2.x 提升了性能, 节约内存。</p>
<h3 id="abs-fabs-math"><a href="#abs-fabs-math" class="headerlink" title="abs|fabs[math]"></a>abs|fabs[math]</h3><p><code>Python</code> 中<code> fabs(x)</code> 方法返回 <code>x</code> 的绝对值。虽然类似于 <code>abs()</code> 函数，但是两个函数之间存在以下差异：</p>
<ul>
<li><p><code>abs()</code> 是一个内置函数，而 <code>fabs()</code> 在 <code>math</code> 模块中定义的。</p>
</li>
<li><p><code>fabs()</code> 函数只适用于 <code>float</code> 和 <code>integer</code> 类型，而 <code>abs()</code> 也适用于复数。</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line">a = -<span class="number">1</span></span><br><span class="line">b = -<span class="number">1.3232</span></span><br><span class="line">c = b</span><br><span class="line">d = <span class="number">1</span> + <span class="number">1.0j</span></span><br><span class="line">e = <span class="number">3</span> + <span class="number">4.0j</span></span><br><span class="line">print(<span class="string">&quot;a的绝对值是:&quot;</span>, <span class="built_in">abs</span>(a))</span><br><span class="line">print(<span class="string">&quot;b的绝对值是:&quot;</span>, <span class="built_in">abs</span>(b))</span><br><span class="line">print(<span class="string">&quot;c的绝对值是:&quot;</span>, math.fabs(c))</span><br><span class="line">print(<span class="string">&quot;d的的绝对值是:&quot;</span>, <span class="built_in">abs</span>(d))</span><br><span class="line">print(<span class="string">&quot;e的绝对值是:&quot;</span>, math.fabs(e))</span><br><span class="line"></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;H:/MY_TXM/test.py&quot;</span>, line <span class="number">80</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    print(<span class="string">&quot;e的绝对值是:&quot;</span>,math.fabs(e))</span><br><span class="line">TypeError: can<span class="string">&#x27;t convert complex to float</span></span><br></pre></td></tr></table></figure>

<h3 id="hypot-math"><a href="#hypot-math" class="headerlink" title="hypot[math]"></a>hypot[math]</h3><p><strong>hypot()</strong> 返回欧几里德范数 <code>sqrt(x*x + y*y)</code></p>
<p><code>hypot()</code>是不能直接访问的，需要导入 <code>math</code> 模块，然后通过 <code>math </code>静态对象调用该方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line">a = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入直角三角形的一条直角边长：&quot;</span>))</span><br><span class="line">b = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入直角三角形的另一条直角边长：&quot;</span>))</span><br><span class="line">print(<span class="string">&quot;该直角三角形的斜边长为: &quot;</span>,  <span class="built_in">int</span>(math.hypot(a, b)))</span><br><span class="line">print(<span class="string">&quot;Done&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="bool"><a href="#bool" class="headerlink" title="bool"></a>bool</h3><p><strong>bool()</strong> 函数用于将给定参数转换为布尔类型，如果没有参数，返回 <code>False</code>用于判断真假</p>
<p><code>bool </code>是 <code>int</code> 的子类。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">issubclass</span>(<span class="built_in">bool</span>, <span class="built_in">int</span>)  <span class="comment"># bool 是 int 子类</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h3 id="issubclass"><a href="#issubclass" class="headerlink" title="issubclass"></a>issubclass</h3><p><code>issubclass(class, classinfo) --&gt; return True|False</code></p>
<p><strong>issubclass()</strong> 方法用于判断参数 <code>class </code>是否是类型参数<code>classinfo</code>的子类</p>
<h1 id="Part1-DataModel"><a href="#Part1-DataModel" class="headerlink" title="Part1.DataModel"></a>Part1.DataModel</h1><h2 id="1-具名元组"><a href="#1-具名元组" class="headerlink" title="1.具名元组"></a>1.具名元组</h2><p>Python元组的升级版本 – namedtuple(具名元组)</p>
<p>因为元组的局限性：不能为元组内部的数据进行命名，所以往往我们并不知道一个元组所要表达的意义，所以在这里引入了 collections.namedtuple 这个工厂函数，来构造一个带字段名的元组。具名元组的实例和普通元组消耗的内存一样多，因为字段名都被存在对应的类里面。这个类跟普通的对象实例比起来也要小一些，因为 Python 不会用 <strong>dict</strong> 来存放这些实例的属性。</p>
<p>namedtuple 对象的定义如以下格式：</p>
<p><code>collections.namedtuple(typename, field_names, verbose=False, rename=False)</code><br>返回一个具名元组子类 typename，其中参数的意义如下：</p>
<ul>
<li>typename：元组名称</li>
<li>field_names: 元组中元素的名称</li>
<li>rename: 如果元素名称中含有 python 的关键字，则必须设置为 rename=True</li>
<li>verbose: 默认就好</li>
</ul>
<p>下面来看看声明一个具名元组及其实例化的方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line">两种方法来给 namedtuple 定义方法名</span><br><span class="line">User = collections.namedtuple(<span class="string">&#x27;User&#x27;</span>, [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;id&#x27;</span>])</span><br><span class="line">User = collections.namedtuple(<span class="string">&#x27;User&#x27;</span>, <span class="string">&#x27;name age id&#x27;</span>)</span><br><span class="line">user = User(<span class="string">&#x27;tester&#x27;</span>, <span class="string">&#x27;22&#x27;</span>, <span class="string">&#x27;464643123&#x27;</span>)</span><br><span class="line"></span><br><span class="line">print(user)</span><br><span class="line">collections.namedtuple(<span class="string">&#x27;User&#x27;</span>, <span class="string">&#x27;name age id&#x27;</span>) 创建一个具名元组，需要两个参数，一个是类名，另一个是类的各个字段名。后者可以是有多个字符串组成的可迭代对象，或者是有空格分隔开的字段名组成的字符串（比如本示例）。具名元组可以通过字段名或者位置来获取一个字段的信息。</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line"></span><br><span class="line">User(name=<span class="string">&#x27;tester&#x27;</span>, age=<span class="string">&#x27;22&#x27;</span>, <span class="built_in">id</span>=<span class="string">&#x27;464643123&#x27;</span>)</span><br><span class="line">具名元组的特有属性:</span><br><span class="line"></span><br><span class="line">类属性 _fields：包含这个类所有字段名的元组 类方法 _make(iterable)：接受一个可迭代对象来生产这个类的实例 实例方法 _asdict()：把具名元组以 collections.OrdereDict 的形式返回，可以利用它来把元组里的信息友好的展示出来</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个namedtuple类型User，并包含name，sex和age属性。</span></span><br><span class="line">User = namedtuple(<span class="string">&#x27;User&#x27;</span>, [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;sex&#x27;</span>, <span class="string">&#x27;age&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个User对象</span></span><br><span class="line">user = User(name=<span class="string">&#x27;Runoob&#x27;</span>, sex=<span class="string">&#x27;male&#x27;</span>, age=<span class="number">12</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取所有字段名</span></span><br><span class="line">print( user._fields )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以通过一个list来创建一个User对象，这里注意需要使用&quot;_make&quot;方法</span></span><br><span class="line">user = User._make([<span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;male&#x27;</span>, <span class="number">12</span>])</span><br><span class="line"></span><br><span class="line">print( user )</span><br><span class="line"><span class="comment"># User(name=&#x27;user1&#x27;, sex=&#x27;male&#x27;, age=12)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取用户的属性</span></span><br><span class="line">print( user.name )</span><br><span class="line">print( user.sex )</span><br><span class="line">print( user.age )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改对象属性，注意要使用&quot;_replace&quot;方法</span></span><br><span class="line">user = user._replace(age=<span class="number">22</span>)</span><br><span class="line">print( user )</span><br><span class="line"><span class="comment"># User(name=&#x27;user1&#x27;, sex=&#x27;male&#x27;, age=21)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将User对象转换成字典，注意要使用&quot;_asdict&quot;</span></span><br><span class="line">print( user._asdict() )</span><br><span class="line"><span class="comment"># OrderedDict([(&#x27;name&#x27;, &#x27;Runoob&#x27;), (&#x27;sex&#x27;, &#x27;male&#x27;), (&#x27;age&#x27;, 22)])</span></span><br><span class="line">以上实例输出结果为：</span><br><span class="line"></span><br><span class="line">(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;sex&#x27;</span>, <span class="string">&#x27;age&#x27;</span>)</span><br><span class="line">User(name=<span class="string">&#x27;Runoob&#x27;</span>, sex=<span class="string">&#x27;male&#x27;</span>, age=<span class="number">12</span>)</span><br><span class="line">Runoob</span><br><span class="line">male</span><br><span class="line"><span class="number">12</span></span><br><span class="line">User(name=<span class="string">&#x27;Runoob&#x27;</span>, sex=<span class="string">&#x27;male&#x27;</span>, age=<span class="number">22</span>)</span><br><span class="line">OrderedDict([(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;Runoob&#x27;</span>), (<span class="string">&#x27;sex&#x27;</span>, <span class="string">&#x27;male&#x27;</span>), (<span class="string">&#x27;age&#x27;</span>, <span class="number">22</span>)])</span><br></pre></td></tr></table></figure>

<h2 id="2-列表表达式"><a href="#2-列表表达式" class="headerlink" title="2.列表表达式"></a>2.列表表达式</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 两者相等</span></span><br><span class="line">print([(i, j) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>) <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">11</span>, <span class="number">20</span>)])</span><br><span class="line">res = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">11</span>, <span class="number">20</span>):</span><br><span class="line">        res.append((i, j))</span><br><span class="line">print(res)</span><br><span class="line"></span><br><span class="line"><span class="comment"># essential</span></span><br><span class="line">fun() <span class="keyword">for</span>-<span class="keyword">in</span>-loop_1 <span class="keyword">for</span>-<span class="keyword">in</span>-loop_2</span><br><span class="line">&lt;==&gt;</span><br><span class="line"><span class="keyword">for</span>-<span class="keyword">in</span>-loop_1:</span><br><span class="line">    <span class="keyword">for</span>-<span class="keyword">in</span>-loop_2:</span><br><span class="line">        fun()</span><br></pre></td></tr></table></figure>

<h2 id="3-random-choice"><a href="#3-random-choice" class="headerlink" title="3.random choice"></a>3.random choice</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> choice</span><br><span class="line">choice(obj) -&gt; obj: can iterable</span><br><span class="line">==&gt; this module can choice a random element from obj</span><br></pre></td></tr></table></figure>

<h2 id="4-Magic-Method"><a href="#4-Magic-Method" class="headerlink" title="4.Magic Method"></a>4.Magic Method</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">obj[key]</span><br><span class="line">本质上调用的是__getitem__</span><br><span class="line"></span><br><span class="line">magic method 又称为 dunder method 及双下滑线魔法方法</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>-<span class="keyword">in</span>-loop</span><br><span class="line">==&gt; __contains__ 迭代通常是隐式的</span><br><span class="line"></span><br><span class="line">obj[key]   --&gt;  self.__getitem__</span><br><span class="line"></span><br><span class="line">迭代通常是隐式的,如果一个集合类型没有实现slef.__contains__,</span><br><span class="line">那么<span class="keyword">in</span>运算符就会按照顺序做一次迭代搜索</span><br><span class="line"></span><br><span class="line">len(obj)   --&gt;   self.__len__</span><br><span class="line">注意如果obj是python内置的类型比如（<span class="built_in">list</span>、<span class="built_in">str</span>、bytearry）等Cpython会抄个近路，__len__实际上会直接返回PyVarObject的self.ob_size这个属性，而不是执行self.__len__这个方法</span><br><span class="line"></span><br><span class="line">for item in x:   --&gt;  self.__iter__</span><br><span class="line">x 必须是可迭代的</span><br></pre></td></tr></table></figure>

<h2 id="5-迭代器与生成器"><a href="#5-迭代器与生成器" class="headerlink" title="5.迭代器与生成器"></a>5.迭代器与生成器</h2><h3 id="5-1迭代器"><a href="#5-1迭代器" class="headerlink" title="5.1迭代器"></a>5.1迭代器</h3><p>迭代是Python最强大的功能之一，是访问集合元素的一种方式。</p>
<p>迭代器是一个可以记住遍历的位置的对象。</p>
<p>迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。</p>
<p>迭代器有两个基本的方法：<strong>iter()</strong> 和 **next()**。</p>
<p>字符串，列表或元组对象都可用于创建迭代器：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">it = <span class="built_in">iter</span>(<span class="built_in">list</span>)    <span class="comment"># 创建迭代器对象</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">next</span>(it))   <span class="comment"># 输出迭代器的下一个元素</span></span><br><span class="line">&gt;<span class="number">1</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">next</span>(it))</span><br><span class="line">&gt;<span class="number">2</span></span><br></pre></td></tr></table></figure>

<p><strong>迭代器对象可以使用常规for语句进行遍历</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">list</span>=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">it = <span class="built_in">iter</span>(<span class="built_in">list</span>)    <span class="comment"># 创建迭代器对象</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> it:</span><br><span class="line">    <span class="built_in">print</span> (x, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">    </span><br><span class="line">&gt; <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p><strong>也可以使用 next() 函数：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> sys         <span class="comment"># 引入 sys 模块</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">list</span>=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">it = <span class="built_in">iter</span>(<span class="built_in">list</span>)    <span class="comment"># 创建迭代器对象</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">print</span> (<span class="built_in">next</span>(it))</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        sys.exit()</span><br></pre></td></tr></table></figure>

<h3 id="5-2创建一个迭代器"><a href="#5-2创建一个迭代器" class="headerlink" title="5.2创建一个迭代器"></a>5.2创建一个迭代器</h3><p>把一个类作为一个迭代器使用需要在类中实现两个方法 <strong>iter</strong>() 与 <strong>next</strong>() </p>
<p>在定义类的时候都有一个构造函数，Python 的构造函数为 <strong>init</strong>(), 它会在对象初始化的时候执行。</p>
<p><strong>iter</strong>() 方法返回一个特殊的<strong>迭代器对象</strong>， 这个迭代器对象实现了 <strong>next</strong>() 方法并通过 <strong>StopIteration</strong> 异常标识迭代的完成。</p>
<p><strong>next</strong>() 方法（Python 2 里是 next()）会返回下一个迭代器对象。</p>
<p>创建一个返回数字的迭代器，初始值为 1，逐步递增 1：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Numbers</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    抽象一个迭代器对象，初始属性【value=0每次next自增1，并通过【value&gt;20】来rais StopInteration</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.value = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 注意这里返回的不是属性self.value而是self这个抽象对象</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.value &lt;= <span class="number">20</span>:</span><br><span class="line">	        self.value += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 这里我们需要输出值,print进行查看</span></span><br><span class="line">            <span class="keyword">return</span> self.value</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line">            </span><br><span class="line"><span class="comment"># ------</span></span><br><span class="line"></span><br><span class="line">temp = Numbers()</span><br><span class="line">temp_iter = <span class="built_in">iter</span>(temp)  <span class="comment"># 这一步骤可以省略，因为temp在实例化的时候已经是一个迭代器了（contains magic method） iterm | next</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以直接for-in-loop temp</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> temp_iter:</span><br><span class="line">    print(item)</span><br><span class="line">&gt; <span class="number">1</span> <span class="number">2</span> ... <span class="number">21</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将俩者的信息进行打印如下:</span></span><br><span class="line">print(<span class="string">f&quot;the obj is <span class="subst">&#123;temp&#125;</span> , type is <span class="subst">&#123;<span class="built_in">type</span>(temp)&#125;</span>&quot;</span>)</span><br><span class="line">print(<span class="string">f&quot;the iter is <span class="subst">&#123;temp_iter&#125;</span> , type is <span class="subst">&#123;<span class="built_in">type</span>(temp)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">&gt;&gt;</span><br><span class="line">the obj <span class="keyword">is</span> &lt;__main__.Numbers <span class="built_in">object</span> at <span class="number">0x0000016FFBD51088</span>&gt; , <span class="built_in">type</span> <span class="keyword">is</span> &lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">__main__</span>.<span class="title">Numbers</span>&#x27;&gt;</span></span><br><span class="line">the iter is &lt;__main__.Numbers object at 0x0000016FFBD51088&gt; , type is &lt;class &#x27;__main__.Numbers&#x27;&gt;</span><br><span class="line"><span class="comment"># 可以看到两者的物理地址相同，因此iter(OBJ)和OBJ一样都是属于迭代器</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="5-3生成器"><a href="#5-3生成器" class="headerlink" title="5.3生成器"></a>5.3生成器</h3><p>在 Python 中，使用了 yield 的函数被称为生成器（generator）。</p>
<p>跟普通函数不同的是，生成器是一个返回迭代器的函数，只能用于迭代操作，更简单点理解生成器就是一个迭代器。</p>
<p>在调用生成器运行的过程中，每次遇到 yield 时函数会暂停并保存当前所有的运行信息，返回 yield 的值, 并在下一次执行 next() 方法时从当前位置继续运行。</p>
<p>调用一个生成器函数，返回的是一个迭代器对象。</p>
<p>以下实例使用 yield 实现斐波那契数列：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibonacci</span>(<span class="params">n</span>):</span>  <span class="comment"># 生成器函数 - 斐波那契</span></span><br><span class="line">    a, b, counter = <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> (counter &gt; n): </span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">yield</span> a</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        counter += <span class="number">1</span></span><br><span class="line">f = fibonacci(<span class="number">10</span>)  <span class="comment"># f 是一个迭代器，由生成器返回生成</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">print</span> (<span class="built_in">next</span>(f), end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        sys.exit()</span><br><span class="line"><span class="comment">#  每次next（generator）所生成的迭代器对象公用和一个物理地址</span></span><br></pre></td></tr></table></figure>

<h3 id="5-4迭代器和生成器对比"><a href="#5-4迭代器和生成器对比" class="headerlink" title="5.4迭代器和生成器对比"></a>5.4迭代器和生成器对比</h3><ul>
<li><p>迭代器（iterator）是一个特殊的类，其中必有iterm和next方法，本质上是一个类|对象 </p>
<ul>
<li>除了使用class来定义一个迭代器外， 还可以使用iterm(obj)来快速生成一个迭代器对象</li>
<li>可以使用rais StopIteration来抛出exception阻止迭代器进入<strong>死循环</strong></li>
<li>是一个可以记住遍历的位置的对象（本质上含有iterm和next）</li>
</ul>
</li>
<li><p>生成器是一个含有yield的函数（generator），生成器是一个返回迭代器的函数，只能用于迭代操作，其实生成器也可以理解成一种特殊的迭代器</p>
<ul>
<li>生成器是一个返回迭代器的函数</li>
<li>在调用生成器运行的过程中，每次遇到 yield 时函数会暂停并保存当前所有的运行信息，返回 yield 的值, 并在下一次执行 next() 方法时从当前位置继续运行。</li>
<li>调用一个生成器函数，返回的是一个迭代器对象</li>
</ul>
</li>
</ul>
<h2 id="6-len为什么不是普通方法"><a href="#6-len为什么不是普通方法" class="headerlink" title="6.len为什么不是普通方法"></a>6.len为什么不是普通方法</h2><p>如果x是一个python内置类型的实例， 那么len(x)中Cpython会直接调用这个类的属性，解释器将不走<code>__len__()</code>这个方法</p>
<h2 id="杂谈"><a href="#杂谈" class="headerlink" title="杂谈"></a>杂谈</h2><ol>
<li><p>数据模型|对象模型</p>
<ul>
<li>python文档中大多使用数据模型, 而大多数喜欢使用对象模型</li>
<li>对象模型:计算机编程语言中对象的属性&lt;==&gt;数据模型</li>
</ul>
</li>
<li><p>魔法方法</p>
<ul>
<li>python用这个方法来提供更多的元对象协议,目的是让语言的使用者和开发者拥有并使用同样的工具</li>
</ul>
</li>
<li><p>元对象</p>
<p><code>the art of the MetaObject Protocal | AMOP</code></p>
<ul>
<li>元对象协议:那些对构建语言本身来讲很重要的对象, 以此为前提, 协议也可以看成是接口, 即是说, 元对象协议是对象模型(数据模型)的同义词, 他们的本质都是构建核心语言的API</li>
</ul>
</li>
</ol>
<h1 id="Part2-DataStructure"><a href="#Part2-DataStructure" class="headerlink" title="Part2.DataStructure"></a>Part2.DataStructure</h1><h2 id="2-0前言"><a href="#2-0前言" class="headerlink" title="2.0前言"></a>2.0前言</h2><p>在创建<code>poython</code>之前<code>Guido</code>曾为<code>ABC</code>语言贡献过代码, <code>ABC</code>语言是一个致力于为初学者设计变成环境的长达10的研究项目, 其中很多点子在现在看来任然具有python的特性如:</p>
<ol>
<li>序列的泛型操作</li>
<li>内置的元组</li>
<li>映射类型</li>
<li>用缩进来构建源码</li>
<li>无需变量声明的强类型</li>
</ol>
<p>python也从ABC继承了用统一风格处理<code>序列数据</code>这一特点, 无论是中数据结构(string|list|bytes|tuple|array|xml|element|database query)他们都公用一套操作:</p>
<ol>
<li>迭代</li>
<li>切片</li>
<li>排序</li>
<li>拼接</li>
</ol>
<h2 id="2-1内置序列类型"><a href="#2-1内置序列类型" class="headerlink" title="2.1内置序列类型"></a>2.1内置序列类型</h2><p>python使用C实现了两大类序列类型：<strong>容器序列 扁平序列</strong></p>
<blockquote>
<p>两者的却别前者支持存储不同类型的数据; 后者仅支持一种类型的数据</p>
</blockquote>
<p><strong>容器序列</strong>: <code>list tuple collection.deque</code></p>
<ul>
<li>存放的是任意类型的对象的引用</li>
<li>支持存储不同数据类型</li>
<li>非连续内存存储</li>
</ul>
<p><strong>扁平序列</strong>: <code>str bytes bytearray memoryvivew arrary.arrary</code></p>
<ul>
<li>存放的是值而不是引用</li>
<li>只能存储一种数据类型[字符 字节 数值]</li>
<li>连续存储</li>
</ul>
<p>根据是否可以被修改可以分为:<strong>可变序列</strong> <strong>不可变序列</strong></p>
<p>从UML图中可以看出两者之间的部分继承关系，但是<strong>内置的序列</strong>类型不是直接<code>sequence</code>和<code>mutale sequence</code>这两个抽象基类继承来的<code>Abstarct Base Class | ABC</code></p>
<table>
<thead>
<tr>
<th></th>
<th>immutable sequence</th>
<th>mutable sequence</th>
</tr>
</thead>
<tbody><tr>
<td>*getitem</td>
<td>y</td>
<td></td>
</tr>
<tr>
<td>*setitem</td>
<td></td>
<td>y</td>
</tr>
<tr>
<td>*delitem</td>
<td></td>
<td>y</td>
</tr>
<tr>
<td>*contains</td>
<td>y</td>
<td></td>
</tr>
<tr>
<td>*iter</td>
<td>y</td>
<td></td>
</tr>
<tr>
<td>*reversed</td>
<td>y</td>
<td></td>
</tr>
<tr>
<td>*iadd</td>
<td></td>
<td>y</td>
</tr>
<tr>
<td>index</td>
<td>y</td>
<td></td>
</tr>
<tr>
<td>insert</td>
<td></td>
<td>y</td>
</tr>
<tr>
<td>append</td>
<td></td>
<td>y</td>
</tr>
<tr>
<td>reverse</td>
<td></td>
<td>y</td>
</tr>
<tr>
<td>extend</td>
<td></td>
<td>y</td>
</tr>
<tr>
<td>pop</td>
<td></td>
<td>y</td>
</tr>
<tr>
<td>remove</td>
<td></td>
<td>y</td>
</tr>
<tr>
<td>count</td>
<td>y</td>
<td></td>
</tr>
</tbody></table>
<h2 id="2-2-列表推导和生成器表达"><a href="#2-2-列表推导和生成器表达" class="headerlink" title="2.2 列表推导和生成器表达"></a>2.2 列表推导和生成器表达</h2><blockquote>
<p>list comprehension and generator expression</p>
</blockquote>
<p><code>[]: 列表推导式</code></p>
<p><code>(): 生成器表达式</code></p>
<p><strong>列表推导式: 快速构建list</strong></p>
<p>使用原则:</p>
<ol start="0">
<li><p><strong>列表推导式的作用只有一个:生成列表</strong></p>
</li>
<li><p>创建新列表</p>
</li>
<li><p>尽量保持简短</p>
</li>
<li><p>在<code>py3.x</code>中修复了列表推导是中的变量泄露问题(通过局部作用域修复)</p>
</li>
<li><p>使用<code>filter + map</code>也可以达到相同效果</p>
</li>
<li><p>注意: <code>filter</code>返回的是一个迭代器</p>
</li>
<li><p>两者的效率根据不同情况表现不一样</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">temp = <span class="string">&#x27;!@#$%&#x27;</span></span><br><span class="line"></span><br><span class="line">m1 = [<span class="built_in">ord</span>(s) <span class="keyword">for</span> s <span class="keyword">in</span> temp <span class="keyword">if</span> <span class="built_in">ord</span>(s) &gt; <span class="number">35</span>]</span><br><span class="line">print(m1)</span><br><span class="line"></span><br><span class="line">m2 = <span class="built_in">list</span>(<span class="built_in">filter</span>(<span class="keyword">lambda</span> x: x &gt; <span class="number">35</span>, <span class="built_in">map</span>(<span class="built_in">ord</span>, temp)))</span><br><span class="line">print(m2)</span><br></pre></td></tr></table></figure>

<h3 id="2-2-1-笛卡尔积"><a href="#2-2-1-笛卡尔积" class="headerlink" title="2.2.1 笛卡尔积"></a>2.2.1 笛卡尔积</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">col_1 = [<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;c&quot;</span>]</span><br><span class="line">col_2 = [<span class="string">&quot;!&quot;</span>, <span class="string">&quot;@&quot;</span>, <span class="string">&quot;#&quot;</span>]</span><br><span class="line"></span><br><span class="line">col_3 = [(i, j) <span class="keyword">for</span> i <span class="keyword">in</span> col_1 <span class="keyword">for</span> j <span class="keyword">in</span> col_2]</span><br><span class="line">print(col_3)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> col_1:</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> col_2:</span><br><span class="line">        print(i, j)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>列表推导式和双层<code>for</code>循环俩者执行顺序一样</p>
</blockquote>
<h3 id="2-2-2生成器表达式"><a href="#2-2-2生成器表达式" class="headerlink" title="2.2.2生成器表达式"></a>2.2.2生成器表达式</h3><p>使用列表推导也可以初始化元组|数组|其他序列,但是生成器表达式是一个更好的选择, 因为背后支持迭代器协议,可以逐个产出元素而非先建立一个完整的<code>list</code>,可以更好的节省内存</p>
<p>生成器表达式和列表推导式的区别是:</p>
<ul>
<li><code>[]</code> <code>()</code></li>
<li>生成一个完整的<code>list</code>; 迭代器</li>
</ul>
<h2 id="2-3-元组"><a href="#2-3-元组" class="headerlink" title="2.3 元组"></a>2.3 元组</h2><blockquote>
<p>元组: 是一个不可变的list; 记录一定的维度[位置]的数据信息</p>
</blockquote>
<p>元组的拆包</p>
<p>本质上是将元组中的数据提取</p>
<ol start="0">
<li><p>元组的拆包方式在任意可迭代对象中都是通用的</p>
</li>
<li><p><code>for-loop</code></p>
</li>
<li><p><code>*</code></p>
<ul>
<li><code>*</code>拆包返回的是<code>list</code></li>
</ul>
</li>
<li><p>平行赋值</p>
</li>
<li><p><code>a, b = b, a </code>本质上也是拆包</p>
</li>
<li><p>可以使用<code>_</code>占位符来过滤掉不需要的数据</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.for-loop</span></span><br><span class="line">a = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> a:</span><br><span class="line">    print(i)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 2.*</span></span><br><span class="line"><span class="comment"># 提取元素</span></span><br><span class="line">i, *j = a</span><br><span class="line"><span class="comment"># 将可迭代对象拆开作为函数的参数</span></span><br><span class="line">b = (<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="built_in">divmod</span>(*b)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 平行赋值</span></span><br><span class="line">i, j, m = a</span><br></pre></td></tr></table></figure>

<h4 id="2-3-1-具名元组"><a href="#2-3-1-具名元组" class="headerlink" title="2.3.1 具名元组"></a>2.3.1 具名元组</h4><p><code>collections.namedtuple</code>构建的类的实例所消耗的内存和元组一样, 因为字段名都存在了相应的类里</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># namedtuple</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"></span><br><span class="line"><span class="comment"># define a class</span></span><br><span class="line"><span class="comment"># namedtuple(str, iterator)</span></span><br><span class="line"><span class="comment">#   &gt;&gt;&gt; str: the name of class</span></span><br><span class="line"><span class="comment">#   &gt;&gt;&gt; iterator: define the attributes of class</span></span><br><span class="line"><span class="comment">#   &gt;&gt;&gt; iterator(if accept str): &quot;name age score&quot; split whith &#x27; &#x27;</span></span><br><span class="line">student = namedtuple(<span class="string">&#x27;student&#x27;</span>, [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;score&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># create some instances</span></span><br><span class="line">drink = student(<span class="string">&#x27;Drink&#x27;</span>, <span class="string">&#x27;21&#x27;</span>, <span class="string">&#x27;90&#x27;</span>)</span><br><span class="line">starfire = student(<span class="string">&#x27;starfire&#x27;</span>, <span class="string">&#x27;23&#x27;</span>, <span class="string">&#x27;92&#x27;</span>)</span><br><span class="line">spark = student(<span class="string">&#x27;spark&#x27;</span>, <span class="string">&#x27;24&#x27;</span>, <span class="string">&#x27;95&#x27;</span>)</span><br><span class="line"></span><br><span class="line">print(drink)</span><br><span class="line">print(starfire)</span><br><span class="line">print(spark)</span><br><span class="line"></span><br><span class="line">student(name=<span class="string">&#x27;Drink&#x27;</span>, age=<span class="string">&#x27;21&#x27;</span>, score=<span class="string">&#x27;90&#x27;</span>)</span><br><span class="line">student(name=<span class="string">&#x27;starfire&#x27;</span>, age=<span class="string">&#x27;23&#x27;</span>, score=<span class="string">&#x27;92&#x27;</span>)</span><br><span class="line">student(name=<span class="string">&#x27;spark&#x27;</span>, age=<span class="string">&#x27;24&#x27;</span>, score=<span class="string">&#x27;95&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># we can get the specify value by [] or .attr</span></span><br><span class="line">print(drink[<span class="number">0</span>])</span><br><span class="line">print(drink.name)</span><br><span class="line"></span><br><span class="line">Drink</span><br><span class="line">Drink</span><br></pre></td></tr></table></figure>

<p>除了从普通元组继承的属性之外, 具名元组还有独特的属性:<code>_fields类属性|类方法|_make(iterable)和实列方法_asdict() </code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment"># get all attrs of drink</span></span><br><span class="line">print(drink._fields)</span><br><span class="line"></span><br><span class="line">(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;score&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># exchange drink into dict</span></span><br><span class="line">drink_dict = drink._asdict()</span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> drink_dict.items():</span><br><span class="line">    print(key, <span class="string">&quot;:&quot;</span>, value)</span><br><span class="line">    </span><br><span class="line">name : Drink</span><br><span class="line">age : <span class="number">21</span></span><br><span class="line">score : <span class="number">90</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># accept date generate an instance</span></span><br><span class="line">data = (<span class="string">&quot;star&quot;</span>, <span class="string">&quot;20&quot;</span>, <span class="string">&quot;60&quot;</span>)</span><br><span class="line">star = student._make(data)</span><br><span class="line">print(star)</span><br><span class="line"></span><br><span class="line">student(name=<span class="string">&#x27;star&#x27;</span>, age=<span class="string">&#x27;20&#x27;</span>, score=<span class="string">&#x27;60&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="2-3-2-不可变列表-元组"><a href="#2-3-2-不可变列表-元组" class="headerlink" title="2.3.2 不可变列表[元组]"></a>2.3.2 不可变列表[元组]</h4><blockquote>
<p>元组支持列表的大多数操作除了增删改元素之外</p>
</blockquote>
<h2 id="2-4切片"><a href="#2-4切片" class="headerlink" title="2.4切片"></a>2.4切片</h2><ol>
<li>切片支持大多数<code>可变序列</code></li>
<li>切片的数学表达式为<code>[&lt;= &lt;)</code></li>
<li>区间运算<code>start default=0</code></li>
<li><code>s[a:b:c] start end step</code>其中<code>step</code>可以为负即反向取值</li>
</ol>
<p>本质上在使用slice取值时, python会调用<code>seq.__getitem__(slice(start, end, step))</code></p>
<p>或者说<code>slice()</code>是一个切片对象, 可以改切片命名就像<code>excel--sheet</code>一样</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">name_slice = <span class="built_in">slice</span>(<span class="number">0</span>, <span class="number">5</span>)</span><br><span class="line">a = <span class="string">&quot;drink 21 98&quot;</span></span><br><span class="line">print(a[name_slice])</span><br><span class="line"></span><br><span class="line">drink</span><br></pre></td></tr></table></figure>

<h3 id="2-4-1-多维切片-省略"><a href="#2-4-1-多维切片-省略" class="headerlink" title="2.4.1 多维切片|省略"></a>2.4.1 多维切片|省略</h3><blockquote>
<p>多维切片所支持的数据序列也是多维度,而python内置的数据序列都是一维的</p>
</blockquote>
<p>本质上多维切片<code>seq[i, j]| seq[m:n, i:j]</code>调用的是<code>seq.__getitem__((i, j))</code>或者<code>seq.__setitem((i, j))</code></p>
<p>省略<code>...</code>在python解释器中是一个符号,其实本质上<code>Ellipsis</code>对象的别称</p>
<p>如果<code>x</code>是四维数组,那么<code>x[i:...]</code>就是<code>x[i:::]</code>的缩写</p>
<h3 id="2-4-2-切片赋值"><a href="#2-4-2-切片赋值" class="headerlink" title="2.4.2 切片赋值"></a>2.4.2 切片赋值</h3><ul>
<li>通过切片赋值右边必须是<strong>可迭代对象</strong></li>
</ul>
<h2 id="2-5-对序列使用-和"><a href="#2-5-对序列使用-和" class="headerlink" title="2.5 对序列使用+和*"></a>2.5 对序列使用+和*</h2><ul>
<li><p><code>+</code>和<code>*</code>都遵守一条规律即<strong>不修改原有的操作对象</strong>而是创建一个全新的序列</p>
</li>
<li><p><code>+</code>通常是相同类型的数据</p>
</li>
<li><p>在操作中python会创建一个包含相同类型数据的序列作为拼接的结果</p>
</li>
<li><p>注意在使用<code>seq * n</code>操作时, 如果<code>seq</code>里的元素是对其他可变对象的引用的话, 虽然<code>* n</code>拼接了, 但本质上还是对<code>seq</code>的引用, 对其进行操作时很可能会出现”多重操作”</p>
</li>
</ul>
<p>示例:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">a = [[<span class="string">&quot;_&quot;</span>] * <span class="number">3</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)]</span><br><span class="line"></span><br><span class="line">b = [[<span class="string">&quot;_&quot;</span>] * <span class="number">3</span>] * <span class="number">3</span></span><br><span class="line"></span><br><span class="line">a[<span class="number">1</span>][<span class="number">2</span>] = <span class="string">&quot;X&quot;</span></span><br><span class="line">b[<span class="number">1</span>][<span class="number">2</span>] = <span class="string">&quot;O&quot;</span></span><br><span class="line"></span><br><span class="line">print(a)</span><br><span class="line">print(b)</span><br><span class="line"></span><br><span class="line">[[<span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>],</span><br><span class="line"> [<span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;X&#x27;</span>],</span><br><span class="line"> [<span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>]]</span><br><span class="line"></span><br><span class="line">[[<span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;O&#x27;</span>],</span><br><span class="line"> [<span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;O&#x27;</span>], </span><br><span class="line"> [<span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;O&#x27;</span>]]</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/add_mul_operator.png"></p>
<p>其中<code>b</code>时三个指向同一对象的引用</p>
<p><code>b</code>所犯的错误和下面的错误一样</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># list中追加的是对同一对象的三次引用</span></span><br><span class="line">row = [<span class="string">&quot;_&quot;</span>] * <span class="number">3</span></span><br><span class="line">board = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    board.append(row)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># should optimize to this </span></span><br><span class="line">board = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    row = [<span class="string">&quot;_&quot;</span>] * <span class="number">3</span></span><br><span class="line">    board.append(row)</span><br></pre></td></tr></table></figure>

<h2 id="2-6-序列的增量赋值"><a href="#2-6-序列的增量赋值" class="headerlink" title="2.6 序列的增量赋值"></a>2.6 序列的增量赋值</h2><blockquote>
<p>即就地增量 += *= (仅针对可变序列), 不可变序列增量拼接的话实现的是 + * 每次都会创建一个新对象,效率会很低(str除外, 因为对于str的拼接操作过于频繁, CPython对其进行优化)</p>
</blockquote>
<p>在调用这些运算符中, python优先调用<code>__iadd__|__imul__</code>如果没有会次级调用<code>__add__|__mul__</code></p>
<p>需要注意的是:</p>
<p>如果<code>a</code>实现了<code>__iadd__</code>那么<code>+=</code>会实现就地增量赋值,像<code>a.extend(iterator)</code> 否则会调用<code>__add__</code>, 此时不是就地增加,而是首先计算<code>a + b</code>得到一个新的对象, 然后再将对象赋值给<code>a</code>,即是否实现<code>就地</code>完全取决于这个类型有没有实现<code>__iadd__</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">aa = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">print(<span class="built_in">id</span>(aa))</span><br><span class="line">aa += [<span class="number">1</span>, <span class="number">23</span>]</span><br><span class="line">print(<span class="built_in">id</span>(aa))</span><br><span class="line"></span><br><span class="line">ss = <span class="string">&quot;123&quot;</span></span><br><span class="line">print(<span class="built_in">id</span>(ss))</span><br><span class="line">ss += <span class="string">&quot;qwer&quot;</span></span><br><span class="line">print(<span class="built_in">id</span>(ss))</span><br><span class="line"></span><br><span class="line"><span class="number">1168530238600</span></span><br><span class="line"><span class="number">1168530238600</span></span><br><span class="line"><span class="number">1168257348464</span></span><br><span class="line"><span class="number">1168257157616</span></span><br></pre></td></tr></table></figure>

<p>对不可变序列进行重复拼接操作:</p>
<ol>
<li>创建一个新对象</li>
<li>将原来对象的元素复制到新对象中</li>
<li>追加寻元素</li>
</ol>
<p><code>str有优化:在为str初始化内存的时候,程序会为他流出额外的可扩展空间,因此进行增量操作的时候,并不会涉及复制原有字符串到新位置的这一操作</code></p>
<h3 id="2-6-1-元组的增量赋值"><a href="#2-6-1-元组的增量赋值" class="headerlink" title="2.6.1 元组的增量赋值"></a>2.6.1 元组的增量赋值</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">t = (<span class="number">1</span>, <span class="number">2</span>, [<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">t[<span class="number">2</span>] += [<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;input&gt;&quot;</span>, line <span class="number">2</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: <span class="string">&#x27;tuple&#x27;</span> <span class="built_in">object</span> does <span class="keyword">not</span> support item assignment</span><br><span class="line">print(t)</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br></pre></td></tr></table></figure>

<ol>
<li>元组中的元素被成功拼接</li>
<li>解释器抛出异常</li>
</ol>
<blockquote>
<p>其实写成t[2].extend([3, 4])就不会抛出异常了</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用dis.dis展示操作的python字节码</span></span><br><span class="line">dis.dis(<span class="string">&#x27;tuple[i] += iter&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="number">1</span>           <span class="number">0</span> LOAD_NAME                <span class="number">0</span> (<span class="built_in">tuple</span>)</span><br><span class="line">              <span class="number">2</span> LOAD_NAME                <span class="number">1</span> (i)</span><br><span class="line">              <span class="number">4</span> DUP_TOP_TWO</span><br><span class="line">              <span class="number">6</span> BINARY_SUBSCR</span><br><span class="line">              <span class="number">8</span> LOAD_NAME                <span class="number">2</span> (<span class="built_in">iter</span>)</span><br><span class="line">             <span class="number">10</span> INPLACE_ADD</span><br><span class="line">             <span class="number">12</span> ROT_THREE</span><br><span class="line">             <span class="number">14</span> STORE_SUBSCR</span><br><span class="line">             <span class="number">16</span> LOAD_CONST               <span class="number">0</span> (<span class="literal">None</span>)</span><br><span class="line">             <span class="number">18</span> RETURN_VALUE</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>BINARY_SUBSCR: 将值存入stack (DONE)</li>
<li>INPLACE_ADD 完成 += (DONE)</li>
<li>STORE_SUBSCR 赋值 (ERROR)</li>
</ul>
<p>可以得出:</p>
<ol>
<li>不要把可变对象放在元组里</li>
<li>增量赋值不是一个原子操作<ul>
<li>先计算</li>
<li>后赋值</li>
</ul>
</li>
</ol>
<h2 id="2-7-排序-sort和sorted"><a href="#2-7-排序-sort和sorted" class="headerlink" title="2.7 排序.sort和sorted()"></a>2.7 排序.sort和sorted()</h2><blockquote>
<p>两者都是排序, 且内部算法使用的是<code>Timsort</code>,它是一种自适应算法,会根据原始数据的顺序特点交替使用插入排序和并归排序,而且<code>Timsort</code>算法是稳定的(相等元素的相对位置保持不变)</p>
</blockquote>
<ul>
<li><p>seq.sort: 就地排序, 在原始数据的基础上排序, id不会改变, 这个方法返回<code>None</code> </p>
<ul>
<li>python operation返回<code>None</code>表示就地修改, 不会创建新对象</li>
<li>如果函数或者方法对对象进行就地修改,那么就应该让他返回<code>None</code>,通知调用者传入的参数发生改变,但并未创建新对象</li>
<li><code>random.shuffle(iterator)</code>|<code>id(iterator)</code>不会修改</li>
<li>返回<code>None</code>表示就地改动又个弊端, 就是调用者无法串联接口,即始终使用的是一个对象引用</li>
</ul>
</li>
<li><p>sort(obj) 会返回一个新建的<code>list</code></p>
<ul>
<li>可以接收任何形式的可迭代对象作为参数,包括不可变序列和生成器</li>
<li>最后返回的是一个<code>list</code></li>
</ul>
</li>
<li><p>两者都接受两个参数</p>
<ol>
<li><code>reverse=False</code>: 是否反向排序</li>
<li><code>key=identity function:接收一个排序</code>fun<code>通常使用</code>lambda函数<ul>
<li>恒等函数<code>(identity funtion)</code>默认用元素自己的值进行排序</li>
<li><code>key=str.lower</code>:忽略大小写排序</li>
<li><code>key=len</code>: 基于长度排序</li>
</ul>
</li>
</ol>
</li>
<li><p>接收<code>key</code>参数:</p>
<ol>
<li><code>min|max</code></li>
<li><code>sort|.sort</code></li>
<li><code>itertools.groupby()</code></li>
<li><code>heapq.nlargest()|heapq.nsmller()</code></li>
</ol>
</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> groupby</span><br><span class="line"><span class="keyword">from</span> operator <span class="keyword">import</span> itemgetter</span><br><span class="line"><span class="keyword">from</span> heapq <span class="keyword">import</span> nlargest, nsmallest</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">random.seed(<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line">a = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 就地随机打乱seq</span></span><br><span class="line">random.shuffle(a)</span><br><span class="line"></span><br><span class="line">print(a)</span><br><span class="line">a.sort()</span><br><span class="line">print(a)</span><br><span class="line">print(nlargest(<span class="number">3</span>, a))</span><br><span class="line">print(nsmallest(<span class="number">3</span>, a))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">temp_data = [</span><br><span class="line">    &#123;<span class="string">&quot;name&quot;</span>: <span class="number">1</span>, <span class="string">&quot;age&quot;</span>: <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;name&quot;</span>: <span class="number">2</span>, <span class="string">&quot;age&quot;</span>: <span class="number">32</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;name&quot;</span>: <span class="number">1</span>, <span class="string">&quot;age&quot;</span>: <span class="number">45</span>&#125;,</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据list中每个ele中的name进行排序</span></span><br><span class="line">temp_data.sort(key=itemgetter(<span class="string">&quot;name&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 过滤key=name</span></span><br><span class="line"><span class="keyword">for</span> name, data <span class="keyword">in</span> groupby(temp_data, key=itemgetter(<span class="string">&quot;name&quot;</span>)):</span><br><span class="line">    print(<span class="string">f&quot;name---[<span class="subst">&#123;name&#125;</span>]-----&gt; [<span class="subst">&#123;<span class="built_in">list</span>(data)&#125;</span>]&quot;</span>)</span><br><span class="line">    </span><br><span class="line">[<span class="number">4</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">[<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>]</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">name---[1]-----&gt; [[&#123;&#x27;name&#x27;: 1, &#x27;age&#x27;: 1&#125;, &#123;&#x27;name&#x27;: 1, &#x27;age&#x27;: 45&#125;]]</span><br><span class="line">name---[2]-----&gt; [[&#123;&#x27;name&#x27;: 2, &#x27;age&#x27;: 32&#125;]]</span><br></pre></td></tr></table></figure>

<h2 id="2-8-bisect管理有序序列"><a href="#2-8-bisect管理有序序列" class="headerlink" title="2.8 bisect管理有序序列"></a>2.8 bisect管理有序序列</h2><blockquote>
<p><code>bisect</code>模块包含两个主要的函数<code>bisect</code>和<code>insort</code>, 两者都是通过二分法获取<code>index</code>并进行操作</p>
</blockquote>
<p><code>bisect(haystack, needle)</code>, 在<code>haystack</code>中搜索<code>needle</code>其中:</p>
<ol>
<li><code>haystack</code>必须是有序的</li>
<li><code>return index</code></li>
</ol>
<p><code>bisect</code>可以建立一个用数字作为索引的查询表格, 比如把表格和成绩对应起来</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> bisect</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">grade</span>(<span class="params">socre, grades=<span class="literal">None</span>, breakpoints=<span class="string">&quot;FDCBA&quot;</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> grades <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        grades = [<span class="number">50</span>, <span class="number">60</span>, <span class="number">70</span>, <span class="number">80</span>, <span class="number">90</span>]</span><br><span class="line">    socre_index = bisect.bisect(grades, score)</span><br><span class="line">    <span class="keyword">return</span> breakpoints[socre_index]</span><br></pre></td></tr></table></figure>

<p><code>bisect.insort(seq, item)</code> 把变量<code>item</code>插入到有序序列<code>seq</code>中<code>[本质上是通过二分法获取index后插入]</code></p>
<ul>
<li>如果只是处理数字列表的话, <code>array</code>是一个更好的选择</li>
</ul>
<h2 id="2-9-当list不是首选时"><a href="#2-9-当list不是首选时" class="headerlink" title="2.9 当list不是首选时"></a>2.9 当list不是首选时</h2><p><code>list</code>可以处理多个数据类型,但当面对大量的数字类型时, <code>array</code>是一个更好的选择</p>
<ol>
<li>数组存储的不是<code>num</code>对象,而是数字的机器翻译(字节表述)</li>
<li>和C语言的数组一样, 如果需要频繁的对序列进行进出操作, <code>deque</code>的速度会更快</li>
<li>在处理<code>包含</code>操作时,<code>set</code>是个更好的选择,python对此进行过优化,需要注意的是,<code>set</code>不是序列,他是无序的</li>
</ol>
<h3 id="2-9-1-数组"><a href="#2-9-1-数组" class="headerlink" title="2.9.1 数组"></a>2.9.1 数组</h3><p><code>array.array</code>在存储数字方面效率胜于<code>list</code>且支持<code>list</code>的基本操作,此外数组还提供从文件读取<code>(.frombytes)</code>和存入文件<code>(.tofile)</code>的快速方法</p>
<blockquote>
<p>python中的数组和C一样, 在创建数组时都需要一个类型码,以表明要存储的数据类型</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> array <span class="keyword">import</span> array</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="comment"># init a array</span></span><br><span class="line">floats = array(<span class="string">&quot;d&quot;</span>, [random() <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span> ** <span class="number">7</span>)])</span><br><span class="line"><span class="comment"># get ele by index</span></span><br><span class="line">print(floats[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># init the path</span></span><br><span class="line">file_path = <span class="string">&quot;./floats.bin&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># open the file with &quot;wb&quot;</span></span><br><span class="line">fp = <span class="built_in">open</span>(file_path, <span class="string">&quot;wb&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># write the data to the specify file</span></span><br><span class="line"><span class="comment"># by binaryIO</span></span><br><span class="line">floats.tofile(fp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># close the file</span></span><br><span class="line">fp.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># init an empty array</span></span><br><span class="line">floats2 = array(<span class="string">&quot;d&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># open the file with &quot;rb</span></span><br><span class="line">op = <span class="built_in">open</span>(file_path, <span class="string">&quot;rb&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># open the file 10 ** 7 from file</span></span><br><span class="line"><span class="comment"># by binaryIO</span></span><br><span class="line">floats2.fromfile(op, <span class="number">10</span>**<span class="number">7</span>)</span><br><span class="line">print(floats2[<span class="number">1</span>])</span><br></pre></td></tr></table></figure>

<p>method区别:</p>
<ol>
<li>数组不支持浅拷贝|但支持<code>__deepcopy__</code></li>
<li>数组支持<code>seq.reverse()</code>但不支持<code>seq.__reversed__()</code></li>
<li>数组不支持就地排序<code>seq.sort()</code></li>
</ol>
<blockquote>
<p>从python3.4开始数组不再支持就地排序seq.sort(), 如果需要排序得用sorted函数重新建立一个数组</p>
</blockquote>
<p><code>a = array.array(a.typecode, sorted(a))</code></p>
<h3 id="2-9-2-内存视图"><a href="#2-9-2-内存视图" class="headerlink" title="2.9.2 内存视图"></a>2.9.2 内存视图</h3><p><code>memoryview</code>是一个内置类, 可以让用户在不复制内容的情况下操作同一数组的不同切片</p>
<ul>
<li>本质上是泛化和去数学化的<code>Numpy</code>数组</li>
<li>可以在不需要复制内容的前提下,在任何数据结构之间共享内存 </li>
<li>处理大数据很实用 –&gt; 节省了数据copy内存和时间</li>
<li>需要注意是对原数据直接进行操作</li>
</ul>
<p><code>memoryview.cast</code><strong>能用不同的方式读写同一块内存数据</strong>,并且内容字节不会随意移动,会把同一块内存里的内容打包成一个全新的<code>memoryview.cast</code>对象给你    </p>
<p> <strong>不同方式</strong>:可以用不同的读写方式操作数据</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># init array 类型码“h”</span></span><br><span class="line">temp_array = array(<span class="string">&#x27;h&#x27;</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用数组创一个memoryview实例</span></span><br><span class="line">view = <span class="built_in">memoryview</span>(temp_array)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个memoryview实例,其中把这块内存内容用“B”类型存储[无符号字符]</span></span><br><span class="line">cast = view.cast(<span class="string">&quot;B&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># .tolist()以列表的形式查看|return --&gt; list</span></span><br><span class="line">temp = cast.tolist()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把位于1的字节赋值为6, 因为把占2个字节的整数高位字节改成了6</span></span><br><span class="line"><span class="comment"># 那么之歌有符号整数的值就变为了 1537</span></span><br><span class="line">cast[<span class="number">1</span>] = <span class="number">6</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/memoryview"></p>
<p><img src="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/20220303231533.png"></p>
<h3 id="2-9-3-NumPy-SciPy"><a href="#2-9-3-NumPy-SciPy" class="headerlink" title="2.9.3 NumPy|SciPy"></a>2.9.3 NumPy|SciPy</h3><blockquote>
<p>NumPy和SciPy提供了高阶数组和矩阵操作, python内置数据类型都是一维数据</p>
</blockquote>
<p>维度: row</p>
<p>每个维度所含元素: col</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy</span><br><span class="line"></span><br><span class="line">a = numpy.arange(<span class="number">12</span>)</span><br><span class="line">print(a.shape)</span><br><span class="line"><span class="comment"># 表述1维row 12元素</span></span><br><span class="line">(<span class="number">12</span>,) </span><br><span class="line"></span><br><span class="line"><span class="comment"># using unpacking tuple </span></span><br><span class="line"><span class="comment"># 将1维12元素转化成4维3元素</span></span><br><span class="line">a.shape = <span class="number">4</span>, <span class="number">3</span></span><br><span class="line">[[ <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>]</span><br><span class="line"> [ <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>]</span><br><span class="line"> [ <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>]</span><br><span class="line"> [ <span class="number">9</span> <span class="number">10</span> <span class="number">11</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># get index_row = 1 index_col = 2</span></span><br><span class="line">a[<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># get all index_row index_col = 1</span></span><br><span class="line">a[:, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># transpose() matrix</span></span><br><span class="line"><span class="comment"># return new view</span></span><br><span class="line">a.transpose()</span><br></pre></td></tr></table></figure>

<h3 id="2-9-4-双向队列"><a href="#2-9-4-双向队列" class="headerlink" title="2.9.4 双向队列"></a>2.9.4 双向队列</h3><blockquote>
<p>用列表和append pop(0)可以实现队列 先进先出, 但是删除list中的第一个或者在第一元素前添加一个元素都是十分耗时的, 因为这涉及到所有元素的移动</p>
</blockquote>
<p><code>collection.deque</code>双端队列实现了队列两端元素操作的优化, 但是涉及到中间元素的操作依然会耗时, 并且是一个<code>thread safe</code>类</p>
<ul>
<li>快速从两端对元素进行操作</li>
<li>存储最近使用的几个元素</li>
<li><code>collection.deque</code>可以实现简单的过期机制&lt;通过设置maxlen&gt;</li>
<li><code>append(item)|popleft(index)</code>都是原子操作, 因此<code>deque</code>可以在多线程程序中安全地当作<code>先进先出</code>的<code>栈</code>使用, 而且使用者不需要担心<code>资源锁</code>问题</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="comment"># create dequeue maxlen=10 eles=range(10)</span></span><br><span class="line">dq = deque(<span class="built_in">range</span>(<span class="number">10</span>), maxlen=<span class="number">10</span>)</span><br><span class="line"><span class="comment"># [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># append one ele - right</span></span><br><span class="line">dq.append(<span class="number">10</span>)</span><br><span class="line"><span class="comment"># [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># append one ele - left</span></span><br><span class="line">dq.appendleft(<span class="number">0</span>)</span><br><span class="line"><span class="comment"># [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># rotate num ele default=right | negative=left</span></span><br><span class="line"><span class="comment"># return None ==&gt; will change ori data</span></span><br><span class="line">dq.rotate(<span class="number">3</span>)</span><br><span class="line"><span class="comment"># [7, 8, 9, 0, 1, 2, 3, 4, 5, 6]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># extend iterator ele default=right</span></span><br><span class="line">dq.extend([<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>])</span><br><span class="line"><span class="comment"># [0, 1, 2, 3, 4, 5, 6, 10, 11, 12]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># extendleft iterator ele</span></span><br><span class="line"><span class="comment"># attention the order!</span></span><br><span class="line">dq.extendleft([-<span class="number">1</span>, -<span class="number">2</span>, -<span class="number">3</span>])</span><br><span class="line"><span class="comment"># [-3, -2, -1, 0, 1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure>

<h2 id="2-10-线程安全"><a href="#2-10-线程安全" class="headerlink" title="2.10 线程安全"></a>2.10 线程安全</h2><blockquote>
<p>除了<code>collections.deque</code>外还有其他<code>python</code>标准库也有对队列的实现</p>
</blockquote>
<p><strong>queue</strong></p>
<p>提供了同步<code>线程安全</code>类<code>Queue|LifoQueue|PriorityQueue</code>,不同的<strong>线程</strong>可以利用这些数据类型来交换信息</p>
<ul>
<li>线程通信</li>
<li>三个类构造时都有一个可选参数<code>maxsize</code>用来限制队列大小</li>
<li>在满员时这些类并<strong>不会丢掉旧的元素腾出位置</strong></li>
<li>而是会锁住资源, 直到另外的线程移除了某个元素</li>
<li>适合<strong>控制活跃线程的数量</strong></li>
</ul>
<hr>
<p><strong>multiprocessing</strong></p>
<p>这个包实现了自己的<code>Queue</code>和<code>queue.Queue</code>类似, 是设计给<strong>进程</strong>通信用的还有一个<code>multiprocessiong.JoinableQueue</code></p>
<ul>
<li>进程通信</li>
<li>任务管理</li>
</ul>
<hr>
<p><strong>asyncio</strong></p>
<p><code>python3.4</code>及以上提供, 里面有<code>Queue</code> <code>LifoQueue PriorityQueue</code>和<code>JoinableQueue</code>这些类受到<code>queue</code>和<code>multiprocessing</code>的影响,用于异步变成任务管理</p>
<ul>
<li>异步编程</li>
</ul>
<hr>
<p><strong>heapq</strong></p>
<p>和上面三个模块不同, <code>heapq</code>没有队列类,而是提供了<code>heappush</code>和<code>heappop</code>方法, 可以让用户把<code>可变序列</code>当作堆队列或者优先队列使用</p>
<h2 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h2><p>可变序列 不可变序列</p>
<p>容器序列: 存储引用 非连续存储</p>
<p>扁平序列: 存储值 连续存储 原子性数据</p>
<p>列表: 列表中数据最好是具有相同特性的数据</p>
<p>拆包: 获取元组内数据最安全可靠的方法,<code>*</code>拆包的利器</p>
<p>具名元组: 将元组与数据关联</p>
<ul>
<li><code>namedtuple()._asdict</code>将具名元组转化成<code>ordereddoct</code></li>
<li><code>dict(zip(iter_key, iter_value))</code>普通元组转化<code>dict</code></li>
</ul>
<p>序列切片是python中最受欢迎的语言特性之一</p>
<p><strong>对切片赋值是一个修改可变序列的捷径</strong></p>
<p>重复拼接<code>n*seq</code>要在正确的前提下使用!!!!!</p>
<ul>
<li>初始化含有不可变元素的序列</li>
</ul>
<p>增量赋值<code>+= 和 *=</code>的操作行为和序列本身有关(可变序列|不可变序列) </p>
<p>PS: string类型有优化不会重复复制原数据</p>
<ul>
<li><p>可变序列: 就地修改</p>
</li>
<li><p>不可变序列: 生成新的序列</p>
<p><code>sort</code>和<code>sorted()</code>与<code>key</code>的用法</p>
</li>
<li><p>背后的逻辑是<code>timsort</code>算法, 它是一种自适应算法, 会根据原始数据的特点交替使用插入排序和并归排序</p>
</li>
</ul>
<hr>
<p>元组的鼻祖是ABC语言中的compounds, tuple更准确的说是<code>frozenlist</code></p>
<p><strong>key参数</strong></p>
<p>再使用默认函数key进行排序时<code>Python</code>总会比较两个键, 但是这一计算阶段发生在<code>C</code>语言层, 这也是比调用用户自定义比较函数快的原因</p>
<ul>
<li>当<code>ele</code>是<code>int</code> 或者<code>str</code>时, <code>key</code>支持<code>int</code>或者<code>str</code><ul>
<li><code>int</code>: 比较整个数值</li>
<li><code>str</code>: 只比较第一位数值</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">temp_1 = [<span class="number">3</span>, <span class="number">45</span>, <span class="number">2</span>, <span class="string">&quot;10&quot;</span>, <span class="string">&quot;34&quot;</span>]</span><br><span class="line">print(<span class="built_in">sorted</span>(temp_1, key=<span class="built_in">int</span>))</span><br><span class="line">print(<span class="built_in">sorted</span>(temp_1, key=<span class="built_in">str</span>))</span><br><span class="line"></span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="string">&#x27;10&#x27;</span>, <span class="string">&#x27;34&#x27;</span>, <span class="number">45</span>]</span><br><span class="line">[<span class="string">&#x27;10&#x27;</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">&#x27;34&#x27;</span>, <span class="number">45</span>]</span><br></pre></td></tr></table></figure>

<h1 id="Part3-Dict-Set"><a href="#Part3-Dict-Set" class="headerlink" title="Part3.Dict|Set"></a>Part3.Dict|Set</h1><blockquote>
<p><code>dict</code>的内置函数<code>_builtins_.dict_</code>, Python对字典实现了高度优化 –&gt; <code>hashtable</code></p>
</blockquote>
<h2 id="3-1-泛映射类型"><a href="#3-1-泛映射类型" class="headerlink" title="3.1 泛映射类型"></a>3.1 泛映射类型</h2><p><code>collections.abc</code>中含有<code>Mapping</code>和<code>MutableMapping</code>这俩个抽象类,为<code>dict</code>和其他类似的类型定义形式接口</p>
<p><img src="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/fluent_python_dict_set"></p>
<p>非抽象类一般不会直接继承这些抽象基类, 而是直接对<code>dict</code>或者<code>collections.User.Dict</code>进行扩展,这些抽象基类的主要作用是作为形式化的文档, 定义构建一个映射类型所需要的最基本接口.而且还可以与<code>isinstance</code>一起使用来判断某个数据是否是广义上的<code>mapping</code>类型</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">my_dict = &#123;&#125;</span><br><span class="line"><span class="built_in">isinstance</span>(my_dict, abc.mapping)</span><br></pre></td></tr></table></figure>

<ul>
<li>使用<code>isinstance</code>而不是<code>type</code></li>
<li>可以判断除<code>dict</code>外的广义映射类型</li>
</ul>
<blockquote>
<p>标准库的所有映射类型都是通过dict来实现的,他们有个共同的限制, 即key必须是可散列的</p>
</blockquote>
<p><strong>可散列数据</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">An <span class="built_in">object</span> <span class="keyword">is</span> hashable <span class="keyword">if</span> it has a <span class="built_in">hash</span> value which never changes during its lifetime (it needs a __hash__() method), <span class="keyword">and</span> can be compared to other objects (it needs an __eq__() method). Hashable objects which compare equal must have the same <span class="built_in">hash</span> value. </span><br></pre></td></tr></table></figure>

<ul>
<li>含有<code>__hash__</code> 散列</li>
<li>含有<code>__eq__ </code>比较key</li>
<li>哈希值在整个声明周期不会变化</li>
<li>散列对象相等==&gt;散列值一定相等</li>
</ul>
<p>可散列的数据类型:</p>
<ul>
<li>str</li>
<li>bytes</li>
<li>数值类型</li>
<li>frozenset</li>
<li>tuple(所含的元素全为可散列)</li>
</ul>
<hr>
<p>一般用户自定义的类型的对象都是可散列的, 其中散列值就是<code>id(obj)</code>, 所以所有这些对象在比较时都是不相等的. 如果一个对象实现了<code>__eq__</code>方法, 并且在方法中用到了这个对象的内部状态的话, 那么只有当所有这些内部状态都是不可变的情况下, 这个对象才是可散列的</p>
<hr>
<p><strong>构造字典方法</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;</span><br><span class="line"><span class="built_in">dict</span>(name=<span class="string">&quot;Drink&quot;</span>, age=<span class="string">&quot;23&quot;</span>, score=<span class="string">&quot;98&quot;</span>)</span><br><span class="line"></span><br><span class="line">&gt;&gt;</span><br><span class="line">&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Drink&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="string">&quot;23&quot;</span>, <span class="string">&quot;score&quot;</span>: <span class="string">&quot;98&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;</span><br><span class="line"><span class="built_in">dict</span>(<span class="built_in">zip</span>([<span class="string">&quot;name&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="string">&quot;score&quot;</span>], [<span class="string">&quot;Drink&quot;</span>, <span class="string">&quot;23&quot;</span>, <span class="string">&quot;98&quot;</span>]))</span><br><span class="line"></span><br><span class="line">&gt;&gt;</span><br><span class="line"><span class="built_in">dict</span>([(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Drink&quot;</span>), (<span class="string">&quot;age&quot;</span>, <span class="string">&quot;23&quot;</span>), (<span class="string">&quot;score&quot;</span>, <span class="string">&quot;98&quot;</span>)])</span><br><span class="line"></span><br><span class="line">&gt;&gt;</span><br><span class="line"><span class="built_in">dict</span>(&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Drink&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="string">&quot;23&quot;</span>, <span class="string">&quot;score&quot;</span>: <span class="string">&quot;98&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line">&gt;&gt;</span><br><span class="line">&#123;key, value <span class="keyword">for</span> key, value <span class="keyword">in</span> iterator(key-value-pair)&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-2-字典推导"><a href="#3-2-字典推导" class="headerlink" title="3.2 字典推导"></a>3.2 字典推导</h2><blockquote>
<p>推导式的作用: </p>
<p>创建新的数据对象</p>
<p>过滤作用</p>
</blockquote>
<h2 id="3-3-常见的映射方法"><a href="#3-3-常见的映射方法" class="headerlink" title="3.3 常见的映射方法"></a>3.3 常见的映射方法</h2><p>映射类型的方法很丰富, <code>dict</code> <code>defalutdict</code> 和<code>OrderedDict</code>的常见方法, 后面两个数据类型是<code>dict</code>的变种,位于<code>collections</code>模块内</p>
<p><img src="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/dict01.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/dict02"></p>
<p><img src="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/dict03.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/dict04"></p>
<p><code>default_factory</code>不是一个方法而是一个可调用对象, 他的值在<code>defaultdict</code>初始化中由用户设置</p>
<p><code>OrderedDict.popitem()</code>会移除最先插入的元素**(先进先出)<strong>, 如果<code>.popitem(last=True)</code>则会移除最后插入的元素</strong>(后进先出)**</p>
<p><code>d.update(m, [**kargs])</code>, 在处理<code>m</code>时, 函数首先检验<code>m</code>是否有<code>keys</code>方法,</p>
<ul>
<li>有–&gt;<code>update</code>会把它当作映射对象处理</li>
<li>无–&gt;<code>update</code>会把它当作含有<code>(key-vaule)</code>键值对元素的迭代器</li>
<li><code>python</code>大多数映射类型的构建都采用了相似的逻辑</li>
</ul>
<p><strong>可调用对象</strong></p>
<blockquote>
<p>将类当作函数调用instance()</p>
</blockquote>
<ul>
<li>类中实现<code>__call__</code></li>
<li>快速调用带有某一实例化属性的类的函数</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">eval_some</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">slef, g</span>):</span></span><br><span class="line">        self.g = g</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self, t</span>):</span></span><br><span class="line">        <span class="keyword">return</span> (self.g * <span class="number">2</span>) / t</span><br><span class="line"></span><br><span class="line">earth = eval_some(<span class="number">9.8</span>)</span><br><span class="line">print(earth(<span class="number">10</span>))</span><br></pre></td></tr></table></figure>

<h3 id="3-3-1-更新字典kV"><a href="#3-3-1-更新字典kV" class="headerlink" title="3.3.1 更新字典kV"></a>3.3.1 更新字典kV</h3><p><strong>用setdefault处理找不到的键</strong></p>
<p><code>d[k] --&gt; getitem</code>找不到键时, 会有异常抛出<code>KeyError</code></p>
<ul>
<li>符合python的快速失败哲学</li>
<li>可以使用<code>d.get(k, default)</code>代替异常</li>
<li><strong>当在更新某个键对应的值的时候, 以上俩个方式效率都很低</strong></li>
</ul>
<p>如果要更新字典的一个键值对(包括不存在)使用<code>setdefault(key, default) [operate]</code>这样只会<code>query 1</code>,如果使用<code>if else []</code>则会查询<code>2~3</code>次</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Drink&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里只会查询一次key并更新或初始化</span></span><br><span class="line"><span class="comment"># 如果key存在则对key-value更新</span></span><br><span class="line"><span class="comment"># 不存在将key-default放进映射中</span></span><br><span class="line">a.setdefault(<span class="string">&quot;things&quot;</span>, []).append(<span class="string">&quot;reading&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当存在key时查询2次, 不存在会查询3次</span></span><br><span class="line"><span class="keyword">if</span> <span class="string">&quot;things&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> a:</span><br><span class="line">    a[<span class="string">&quot;things&quot;</span>] = []</span><br><span class="line">a[<span class="string">&quot;things&quot;</span>].append(<span class="string">&quot;reading&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="3-4-映射的弹性键查询"><a href="#3-4-映射的弹性键查询" class="headerlink" title="3.4 映射的弹性键查询"></a>3.4 映射的弹性键查询</h2><blockquote>
<p>在映射中查找不存的key时, 我们希望可以返回一个default value而不是error, 以下俩途径可以实现弹性键查询</p>
</blockquote>
<ol>
<li>通过<code>defaultdict</code>这个类而不是普通的<code>dict</code></li>
<li>自己定义一个<code>dict</code>子类, 并在在子类中实现<code>__missing__</code>方法</li>
</ol>
<h3 id="3-4-1-defaultdict处理不存在的key"><a href="#3-4-1-defaultdict处理不存在的key" class="headerlink" title="3.4.1 defaultdict处理不存在的key"></a>3.4.1 defaultdict处理不存在的key</h3><blockquote>
<p><code>defaultdict</code>是<code>collections</code>中的一个类, 在实例化它时,可以接受一个<code>defaultfoctory</code>不接受参数(一定是可调用的且不接受参数的方法类|函数)</p>
</blockquote>
<ol>
<li><p>在调用<code>d[key]</code>中如果<code>__getitem__</code>找不到对应的<code>key</code>会调用<code>__missing__</code>查看是否定义了<code>defaultfactory</code></p>
</li>
<li><p>将<code>defaultfactory</code>返回的值赋值给<code>d[key]</code></p>
</li>
<li><p>更新<code>dict</code></p>
</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line">temp = defaultdict(<span class="built_in">list</span>)</span><br><span class="line"></span><br><span class="line">temp[<span class="string">&quot;name&quot;</span>]</span><br><span class="line">print(temp)</span><br><span class="line">&gt;&gt; </span><br><span class="line">defaultdict(&lt;class &#x27;list&#x27;&gt;, &#123;&quot;name&quot;: []&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>如果<code>defaultfactory=None</code>在没有找到对应的<code>key</code>时会抛出<code>KeyError</code></p>
</li>
<li><p><code>defaultfactory</code>只会在<code>__getitem__</code>中调用, 比如<code>dict[key]</code>才会被调用, 其中连接两者桥梁的时<code>__missing__</code></p>
</li>
</ul>
<h3 id="3-4-2-特殊方法missing"><a href="#3-4-2-特殊方法missing" class="headerlink" title="3.4.2 特殊方法missing"></a>3.4.2 特殊方法missing</h3><blockquote>
<p>所有的映射类型在找不到key的时候都会牵扯到missing, python基类虽然直到这个方法,但并没有定义这个方法, 不过, 如果一个class继承了dict并且这个类提供了missing方法,那么在<code>getitem</code>找不到值的时候不会抛出<code>异常</code></p>
</blockquote>
<p>特点:</p>
<ol>
<li><code>missing</code>方法只会被<code>getitem</code>调用</li>
<li>不会对<code>.get()</code> <code>__contains__</code>方法产生影响</li>
</ol>
<p><code>dict[key] -- __getitem__ -- __missing__</code></p>
<p><code>dict.get() -- get -- try except</code></p>
<hr>
<p>如果要自定义一个映射类型, 更合适的策略是继承<code>collections.UserDict</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># define the new mapping class by user based on dict</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrKeyDict</span>(<span class="params"><span class="built_in">dict</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__missing__</span>(<span class="params">self, key</span>):</span></span><br><span class="line">        <span class="comment"># 如果键不存在且本身是str则抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(key, <span class="built_in">str</span>):</span><br><span class="line">            <span class="keyword">raise</span> KeyError(key)</span><br><span class="line">        <span class="comment"># 如果键不存在且本身不是str则调用getitem</span></span><br><span class="line">        <span class="keyword">return</span> self[<span class="built_in">str</span>(key)]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># get方法吧查找工作用self[key]的形式委托给getitem,这样</span></span><br><span class="line">    <span class="comment"># 在宣布查找失败之前还missing再给某个键一个机会</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, key, default=<span class="literal">None</span></span>):</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> self[key]</span><br><span class="line">        <span class="keyword">except</span> KeyError:</span><br><span class="line">            <span class="comment"># 如果cast异常则missing也失败了,返回default</span></span><br><span class="line">            <span class="keyword">return</span> default</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__contains__</span>(<span class="params">self, key</span>):</span></span><br><span class="line">        <span class="comment"># 按照传入键的原本值来查找,如果没找到则转化成str再次查找</span></span><br><span class="line">        <span class="keyword">return</span> key <span class="keyword">in</span> self.keys() <span class="keyword">or</span> <span class="built_in">str</span>(key) <span class="keyword">in</span> self.keys()</span><br></pre></td></tr></table></figure>

<blockquote>
<p> 像<code>k in dict.keys()</code>操作在<code>python3</code>中是十分快速的, 即使映射类型对象很庞大, 因为:</p>
</blockquote>
<ul>
<li><code>dict.keys()</code>返回的值是一个视图, 就像集合, 在里面查找一个元素是十分快的</li>
<li><code>key in dict</code>扫描的是一个list, 处理大数据效率低<code>dict.keys()</code></li>
</ul>
<h2 id="3-5-字典的变种"><a href="#3-5-字典的变种" class="headerlink" title="3.5 字典的变种"></a>3.5 字典的变种</h2><p>都是基于<code>collections</code>库</p>
<blockquote>
<p>除了bultin中定义的dict外, 其余字典的变种都是<code>collections</code>库中的</p>
</blockquote>
<h3 id="UserDict"><a href="#UserDict" class="headerlink" title="UserDict"></a>UserDict</h3><blockquote>
<p>比较特殊的一种dict, 这个类其实是把builtin中的dict用纯Pyhton又实现了一遍</p>
</blockquote>
<p>一般用于用户自定义子类的继承</p>
<h3 id="OrderedDict"><a href="#OrderedDict" class="headerlink" title="OrderedDict"></a>OrderedDict</h3><blockquote>
<p>这个类型会在添加键的时候保持顺序, 因此键的每次迭代次序总是一致的</p>
</blockquote>
<p><code>OrderedDict</code>的<code>popitem</code>方法默认删除并返回的时字典里的最后一个元素(先进后出), 如果<code>popitem(last=False)</code>则会删除并返回第一个元素(先进先出)</p>
<h3 id="ChainMap"><a href="#ChainMap" class="headerlink" title="ChainMap"></a>ChainMap</h3><p><a target="_blank" rel="noopener" href="https://zditect.com/main-advanced/python/python-chainmap.html">什么是chainmap?为什么要搞chainmap</a></p>
<blockquote>
<p>该类型可以容纳数个不同的映射对象,然后在进行键查找操作时, 这些对象会被当作一个整体逐个进行查找,直到键被找到</p>
</blockquote>
<p>在给有嵌套功能作用域的语言做解释器的时候很有用, 可以用一个映射对象来代表一个作用域的上下文</p>
<p><code>ChainMap</code>可以将多个字典合并为一个独有的字典，这样的操作 并不是对源数据的拷贝，而是指向源数据，假如原字典数据修改，<code>ChainMap</code>映射也会改变；如果对<code>ChainMap</code>的结果修改，那么原数据一样也会被修改</p>
<p><strong>使用update进行合并字典,是对源数据的拷贝</strong></p>
<ol>
<li><p><code>ChainMap</code> 可接受多个映射然后在逻辑上使它们表现为一个单独的映射结构；它只是维护了一个记录底层映射关系的列表，然后去重定义常用的字典操作</p>
</li>
<li><p>如果有重复的键，会采用第一个映射中键对应的值</p>
</li>
<li><p>修改 <code>ChainMap </code>映射结构，会同时作用在自己和原始字典结构上</p>
</li>
<li><p>可以使用字典的 <code>update() </code>方法，来替代上面的合并方案；但是这就需要创建一个新的字典对象(或者修改原字典，破坏了原始数据)，并且原始字典做了修改，并不会反映到新建的字典上</p>
</li>
<li><p><code>ChainMap </code>使用的就是原始字典，因此原字典变，它也会改变。</p>
</li>
<li><p><strong>如果在使用 ChainMap 合并多个字典时，字典中有重复的 key 值，默认取第一个字典中 key 对应的 value</strong> ，从原理上面讲，ChainMap 实际上是把放入的字典存储在一个队列中，当进行字典的增加删除等操作只会在第一个字典上进行，当进行查找的时候会依次查找<code>(以查找的第一个key-value返回)</code></p>
</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">m1 = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Drink&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">23</span>&#125;</span><br><span class="line">m2 = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Drinkle&quot;</span>, <span class="string">&quot;score&quot;</span>: <span class="number">93</span>&#125;</span><br><span class="line">m3 = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Spark&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">23</span>, <span class="string">&quot;score&quot;</span>: <span class="number">98</span>, <span class="string">&quot;sex&quot;</span>: <span class="string">&quot;man&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">cm = collections.ChainMap(m1, m2, m3)</span><br><span class="line">print(cm)</span><br><span class="line">print(cm[<span class="string">&quot;name&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> cm.items():</span><br><span class="line">    print(key, <span class="string">&quot; &lt;--&gt; &quot;</span>, value)</span><br><span class="line"></span><br><span class="line">ChainMap(&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Drink&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">23</span>&#125;, &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Drinkle&#x27;</span>, <span class="string">&#x27;score&#x27;</span>: <span class="number">93</span>&#125;, &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Spark&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">23</span>, <span class="string">&#x27;score&#x27;</span>: <span class="number">98</span>, <span class="string">&#x27;sex&#x27;</span>: <span class="string">&#x27;man&#x27;</span>&#125;)</span><br><span class="line">Drink</span><br><span class="line">name  &lt;--&gt;  Drink</span><br><span class="line">age  &lt;--&gt;  23</span><br><span class="line">score  &lt;--&gt;  93</span><br><span class="line">sex  &lt;--&gt;  man</span><br></pre></td></tr></table></figure>

<h3 id="Counter"><a href="#Counter" class="headerlink" title="Counter"></a>Counter</h3><blockquote>
<p>这个类型会给键准备一个整数计数器, 每次更新一个键的时候都会增加这个计数器.因此这个类型可以用来给可散列对象计数(str bytes frozenset 数值型)或者当成多重集来用–&gt;多重集合就是集合里的元素可以出现不止一次, Counter实现了+ - 运算符来和并记录</p>
</blockquote>
<p>还有像<code>most_common(num)</code>这类方法, 会按照次序返回映射里最常见的num个键和他们的计数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">counter = collections.Counter(<span class="string">&quot;asdxzcsdfwerewrfewzsqawd&quot;</span>)</span><br><span class="line"></span><br><span class="line">print(counter)</span><br><span class="line"></span><br><span class="line">counter.update(<span class="string">&quot;asdsassd&quot;</span>)</span><br><span class="line"></span><br><span class="line">print(counter.most_common())</span><br><span class="line"></span><br><span class="line">Counter(&#123;<span class="string">&#x27;w&#x27;</span>: <span class="number">4</span>, <span class="string">&#x27;s&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;d&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;e&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;a&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;z&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;f&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;r&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;x&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;q&#x27;</span>: <span class="number">1</span>&#125;)</span><br><span class="line"></span><br><span class="line">[(<span class="string">&#x27;s&#x27;</span>, <span class="number">7</span>), (<span class="string">&#x27;d&#x27;</span>, <span class="number">5</span>)]</span><br></pre></td></tr></table></figure>

<h2 id="3-6-子类化UserDict"><a href="#3-6-子类化UserDict" class="headerlink" title="3.6 子类化UserDict"></a>3.6 子类化UserDict</h2><blockquote>
<p>自定义mapping类型,以<code>UserDict</code>为基类更加方便,因为<code>UserDict</code>是原生的方法, 而<code>dict</code>可能会走写捷径,导致我们不得不在子类中重写这些方法, 而<code>UserDict</code>则不会出现这个问题</p>
</blockquote>
<p>需要注意的是, <code>UserDict</code>并不是<code>Dict</code>的子类,但在<code>data</code>属性是基于<code>Dict</code>的实例实现的, 这个属性实际上是<code>UserDict</code>最终存储数据的地方</p>
<ul>
<li><code>UserDict</code>的子类在实现<code>__setitem__</code>避免了不必要的递归</li>
<li>可以让<code>__contains__</code>的代码更加简洁</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrKeyDict</span>(<span class="params">collections.UserDict</span>):</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__missing__</span>(<span class="params">self, key</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(key, <span class="built_in">str</span>):</span><br><span class="line">            <span class="keyword">raise</span> KeyError (key)</span><br><span class="line">        <span class="keyword">return</span> self[<span class="built_in">str</span>(key)]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__contains__</span>(<span class="params">self, key</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">str</span>(key) <span class="keyword">in</span> self.data</span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span>(<span class="params">self, key, value</span>):</span></span><br><span class="line">        self.data[<span class="built_in">str</span>(key)] = value</span><br></pre></td></tr></table></figure>

<p><code>UserDict</code>继承的是<code>MutableMapping</code>,所以<code>StrKeyDict</code>里剩下的映射类型方法都是从<code>UserDict</code> <code>MutableMapping</code> 和 <code>Mapping</code>这些超类中继承的</p>
<p><code>Mapping</code>类虽然是一个抽象基类<code>ABC</code>,但它提供了许多实用方法</p>
<p><strong>1.MutableMapping.update</strong></p>
<ul>
<li>可以直接使用<code>dict.update(obj)</code></li>
<li>定义在<code>__init__</code>中, 实列化时可以接受多个不同类型的参数构造<code>dict</code></li>
<li>本质上调用的是<code>__setitem__</code> –&gt; <code>self[key]=value</code></li>
</ul>
<p><strong>2.Mapping.get</strong></p>
<ul>
<li><code>.get()</code> –&gt; <code>def get()</code> –&gt; <code>try except</code></li>
</ul>
<h2 id="3-7-不可变映射类型"><a href="#3-7-不可变映射类型" class="headerlink" title="3.7 不可变映射类型"></a>3.7 不可变映射类型</h2><blockquote>
<p>接受一个mapping类型, 返还一个动态只读视图, 在原数据上更改可以反映到视图上,但不能对视图进行写操作, 只能读取 <code>types.MappingProxyType</code></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> types <span class="keyword">import</span> MappingProxyType</span><br><span class="line"></span><br><span class="line">temp = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Drink&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">proxy_dict = MappingProxyType(temp)</span><br><span class="line"></span><br><span class="line">&gt;&gt;</span><br><span class="line">proxy_dict[<span class="string">&quot;name&quot;</span>] </span><br><span class="line">proxy_dict[<span class="string">&quot;age&quot;</span>]</span><br><span class="line">proxy_dict[<span class="string">&quot;score&quot;</span>] = <span class="number">90</span></span><br><span class="line">temp[<span class="string">&quot;age&quot;</span>] = <span class="number">23</span></span><br><span class="line">proxy_dict</span><br><span class="line">&gt;&gt;</span><br><span class="line">&lt;Dirnk&gt;</span><br><span class="line">&lt;KeyError: <span class="string">&#x27;age&#x27;</span>&gt;</span><br><span class="line">&lt;TypeError: <span class="string">&#x27;mappingproxy&#x27;</span> <span class="built_in">object</span> does <span class="keyword">not</span> support item assignment&gt;</span><br><span class="line">&lt;SUCCESS&gt;</span><br><span class="line">&lt;&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Drink&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">23</span>&#125;&gt;</span><br></pre></td></tr></table></figure>

<h2 id="3-8-集合论"><a href="#3-8-集合论" class="headerlink" title="3.8 集合论"></a>3.8 集合论</h2><blockquote>
<p>集合从2.3以module出现, 到2.6才成为built-in type, 包括<code>set</code> <code>frozenset</code></p>
<p>集合的本质是许多唯一对象的聚集(去重)</p>
<p>拥有极快的查找速度 ==&gt; 散列表</p>
</blockquote>
<p>空集 –&gt; <code>set()</code></p>
<p><code>&#123;&#125;</code> –&gt; <code>dict 本质上是一个空字典</code></p>
<p>集合内元素必须是<code>can hash</code>即可散列的</p>
<ul>
<li>str</li>
<li>bytes</li>
<li>数值类型</li>
<li>frozenset</li>
</ul>
<p>集合的操作</p>
<p><code>|</code> –&gt; <code>∪</code></p>
<p><code>&amp;</code> –&gt; <code>∩</code> –&gt; <code>set.intersection(set)</code></p>
<p><code>-</code> –&gt; 差集</p>
<h3 id="3-8-1-集合字面量「仅set」"><a href="#3-8-1-集合字面量「仅set」" class="headerlink" title="3.8.1 集合字面量「仅set」"></a>3.8.1 集合字面量「仅set」</h3><blockquote>
<p>除了空集合<code>set()</code>外, 集合的字面量如同<code>&#123;1&#125; &#123;1, 2&#125;</code></p>
</blockquote>
<p>字面量语句构造集合的方法比<code>set([1, 2, &quot;3&quot;])</code>更快, 后者<code>python</code>需要新建一个列表, 最后吧这个列表传入到构造方法中, 如果是<code>&#123;1, 2, &quot;3&quot;&#125;</code>的字面量构造, <code>python</code>会利用一个<code>BUILD_SET</code>的字节码创建集合</p>
<p>使用反汇编函数查看字节码:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> dis <span class="keyword">import</span> dis</span><br><span class="line"></span><br><span class="line">dis(<span class="string">&quot;&#123;1&#125;&quot;</span>)</span><br><span class="line">dis(<span class="string">&quot;set([1])&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">0</span> LOAD_CONST    <span class="number">0</span> (<span class="number">1</span>)</span><br><span class="line"><span class="number">2</span> BUILD_SET     <span class="number">1</span></span><br><span class="line"><span class="number">4</span> RETURN_VALUE</span><br><span class="line">            </span><br><span class="line"><span class="number">0</span> LOAD_NAME      <span class="number">0</span> (<span class="built_in">set</span>)</span><br><span class="line"><span class="number">2</span> LOAD_CONST     <span class="number">0</span> (<span class="number">1</span>)</span><br><span class="line"><span class="number">4</span> BUILD_LIST     <span class="number">1</span>  --</span><br><span class="line"><span class="number">6</span> CALL_FUNCTION  <span class="number">1</span>  --</span><br><span class="line"><span class="number">8</span> RETURN_VALUE</span><br></pre></td></tr></table></figure>

<p><code>python</code>对于<code>frozenset</code>没有特殊字面量句法, 只能采用构造的方式</p>
<h3 id="3-8-2-集合推导"><a href="#3-8-2-集合推导" class="headerlink" title="3.8.2 集合推导"></a>3.8.2 集合推导</h3><blockquote>
<p>同列表推导字典推导一样</p>
</blockquote>
<ol>
<li>创建一个新的序列</li>
<li>起到过滤条件的作用</li>
</ol>
<h3 id="3-8-3-集合的操作"><a href="#3-8-3-集合的操作" class="headerlink" title="3.8.3 集合的操作"></a>3.8.3 集合的操作</h3><p><img src="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/338FE41118E025DEC0F08E62E79242FB.png"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># KeyError</span></span><br><span class="line">a.remove(<span class="number">4</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment"># pop the first one ele</span></span><br><span class="line">a.pop()  </span><br><span class="line"></span><br><span class="line"><span class="comment"># if number not in set do nothing</span></span><br><span class="line">a.discard(<span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<p>下表中, 缀运算符需要两侧的对象都是集合类型, 但是其他的方法则只要求所传入的参数是可迭代对象</p>
<p><img src="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/04AFD0F1F67F70C8B753E15D433EBB86.png"></p>
<p><strong>集合的比较运算符, 返回布尔值</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/9074D4974B2971BC1FA4BFBE2710A364.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/6D3B0816875580AF04759FD9538975E0.png"></p>
<p><strong>集合的其他操作方法</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/56D97AD7F6AB7ADC76CFDFC71D3CF306.png"></p>
<h2 id="3-9-dict和set的原理"><a href="#3-9-dict和set的原理" class="headerlink" title="3.9 dict和set的原理"></a>3.9 dict和set的原理</h2><blockquote>
<p><code>principles of dict and set</code>, 了解<code>python</code>里的字典和集合类型,他们背后所涉及的<code>hash table</code>是必不可少的</p>
<p>这节将会回答以下几个问题</p>
</blockquote>
<ol>
<li><code>python</code>中的<code>dict</code>和<code>set</code>效率有多高?</li>
<li>为什么他是无序且不稳定的?</li>
<li>为什么并不是所有的<code>python</code>对象都可以当作<code>dict</code>的<code>key</code>或<code>set</code>里的<code>number</code>?</li>
<li>为什么<code>dict</code>的<code>key</code>和<code>set</code>的<code>number</code>的顺序是根据它们被添加的次序而定的,以及为什么在映射对象的生命周期中,这个顺序并不是一成不变的?</li>
<li>为什么不应该迭代循环<code>dict</code>或<code>set</code>的同时往里面添加元素?</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">temp_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">a = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Drink&quot;</span>&#125;.fromkeys(temp_list, <span class="string">&quot;&quot;</span>)</span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line"><span class="built_in">dict</span>.fromkeys(iterator, values)</span><br><span class="line"><span class="comment"># Create a new dictionary with keys from iterable</span></span><br><span class="line"><span class="comment"># and values set to value.</span></span><br><span class="line">&#123;<span class="number">1</span>: <span class="string">&#x27;&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;&#x27;</span>, <span class="number">3</span>: <span class="string">&#x27;&#x27;</span>, <span class="number">4</span>: <span class="string">&#x27;&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-9-1-效率实验"><a href="#3-9-1-效率实验" class="headerlink" title="3.9.1 效率实验"></a>3.9.1 效率实验</h3><p>使用<code>in set(&amp;)</code>  操作符,分别在<code>set dict list</code>查询是否含有某个元素</p>
<p>其中结果如下:</p>
<p>最快的是<code>&amp;</code></p>
<p>最慢的是<code>list in</code></p>
<p>由于列表背后没有散列表来支持<code>in</code>运算符, 每次搜索都会扫描一次完成的列表 [说明了, <code>dict</code>和<code>set</code>在使用散列表存储的时候使用了类似排序的功能]</p>
<h3 id="3-9-2-dict中的散列表"><a href="#3-9-2-dict中的散列表" class="headerlink" title="3.9.2 dict中的散列表"></a>3.9.2 dict中的散列表</h3><blockquote>
<p>这一节只是笼统的描述python如何使用hashtable来实现dict, 其中Cpython对dict有过优化</p>
</blockquote>
<p><strong>散列表</strong> </p>
<ul>
<li><p>本质上是一个稀疏数组(总是有空白元素的数组称为稀疏数组)</p>
</li>
<li><p>散列表中的单元叫做表元(bucket)</p>
</li>
<li><p>在dict的散列表中, 每个键值对占用一个表元,一个表元有俩部分, 分别是对值的引用和对键的引用</p>
</li>
<li><p>表元大小一致, 可以通过偏移量读取特定的表元</p>
</li>
<li><p>python会保证散列表中大约三分之一的表元是空的,如果达到阈值, <strong>原有的散列表会被复制</strong>到一个更大的空间中</p>
</li>
<li><p>把对象放入散列表, 首先使用<code>hash()</code>计算这个元素键的散列值</p>
</li>
</ul>
<p><strong>有关散列表的概念</strong>:</p>
<p><strong>1.散列值和相等性</strong></p>
<blockquote>
<p><code>hash()</code> <code>  ==</code></p>
</blockquote>
<ul>
<li><code>hash()</code>可以用于任何内置类型对象, 自定义对象调用自定义实现的<code>__hash__</code></li>
<li>如果俩对象在比较时是相等的, 则它们的散列值一定相等(但对象的类型和存储结构不一定相等)</li>
<li>为了让散列值可以当作散列表的索引, 越是相似但不相等的对象,他们散列值的差别就越大</li>
</ul>
<p>从python3.3开始 str bytes datetime对象的散列值计算过程中多了随机<code>加盐</code> 所加盐值是python进程内的一个常量每次启动python解释器都会生成一个不同的盐值,目的是为了防止<code>DOS</code>攻击而采取的安全措施</p>
<p><strong>2.散列表算法</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/20220312164711.png"></p>
<p>以<code>dict[key]</code>为例:</p>
<ul>
<li>python首先会调用<code>hash(key)</code>计算key的散列值</li>
<li>把计算的散列值最低的几位数字当作偏移量, 在散列表中查找表元<code>bucket</code><ul>
<li>具体取几位要看散列表的大小</li>
<li>若对应的表元为空 –&gt;  <code>KeyError</code></li>
<li>若非空 –&gt; 表元里会有<code>key-value-pairs</code></li>
</ul>
</li>
<li>python会校验<code>key-value-pairs</code>中的<code>key</code>与输入的<code>key</code>是否相等<code>==</code><ul>
<li>相等 –&gt; 返回对应的<code>value</code></li>
<li>不等 –&gt; 散列冲突</li>
</ul>
</li>
<li>散列冲突: 因为散列表所做的是把随机的元素映射到只有几位的数字上,而散列表本身的索引又依赖于这个数字的一部分<ul>
<li>为了解决冲突,算法会在散列值中另外再取几位数字用特殊方法处理后把新的数字当作索引寻找表元,并重复之前的操作</li>
</ul>
</li>
</ul>
<hr>
<p><strong>添加新元素:</strong></p>
<p>发现表元为空时会放入一个新元素</p>
<p><strong>更新元素</strong>:</p>
<p>找到表元后会更新元素</p>
<p><strong>需要注意的是,python会按照散列表的拥挤程度来决定是否要重新分配内存为它扩容,如果增加散列表的大小,那散列值所占的位数和用作索引的位数会增加,减少了散列冲突</strong></p>
<hr>
<p>**注意:**Cpython中规定如果有一个整型对象,而且他能存进入一个机器字中,那么他的散列值就是它本身</p>
<h3 id="3-9-3-dict的实现和限制"><a href="#3-9-3-dict的实现和限制" class="headerlink" title="3.9.3 dict的实现和限制"></a>3.9.3 dict的实现和限制</h3><blockquote>
<p>主要讨论hashtable给dict带来的优势和限制</p>
</blockquote>
<p><strong>1.键必须是可散列的</strong></p>
<p>包括: str bytes frozenset 数值类型</p>
<p>一个可散列的对象必须包括</p>
<ul>
<li>支持<code>hash()</code>函数并且通过<code>__hash__</code>所得到的散列值不变(在他的生命周期中)</li>
<li>支持通过<code>__eq__</code>方法检测相等性</li>
<li>若<code>a==b</code>那么<code>hash(a)==hash(b)</code></li>
<li>所有由用户自定义的对象默认都是可散列的,因为他们的散列值都是<code>id()</code>来获取的,而且他们不相等</li>
</ul>
<p>**注意:**如果自定义的类实现了<code>_eq_</code>,并且希望他是可散列的, 那么必须定义一个恰当的<code>_hash_</code>保证<code>a==b</code>时<code>hash(a)==hash(b)</code>另一方面,如果一个含有自定义<code>_eq_</code>依赖的类处于可变状态, 那么就不要在这个类中实现<code>_hash_</code>,因为他的实例是不可散列的</p>
<hr>
<p><strong>2.字典在内存中开销大</strong></p>
<ul>
<li>字典使用散列表实现</li>
<li>散列表是稀疏的</li>
<li>在自定义类中<code>_slots_</code>属性可以改变实例属性的存储方式, 由<code>dict--&gt;tuple</code></li>
<li><code>optimization</code>优化往往和可维护相对立<code>maintain</code></li>
</ul>
<hr>
<p><strong>3.键查询很快</strong></p>
<ul>
<li>空间换时间</li>
<li><code>hash table</code>实现了无视数据量大小的快速访问<code>(在数据能放入内存的前提下)</code></li>
</ul>
<p><strong>4.键的次序取决于添加次序</strong></p>
<ul>
<li>在添加新键时, 可能会由哈希冲突, 此时新键会被安排到另一个表元(bucket)中</li>
<li>但是和俩个值相同的键添加顺序有关</li>
<li>虽然逻辑和面向用户表现形式上如此,在判断俩上依旧是相等的</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Drink&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">23</span>&#125;</span><br><span class="line">b = &#123;<span class="string">&quot;age&quot;</span>: <span class="number">23</span>, <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Drink&quot;</span>&#125;</span><br><span class="line"><span class="keyword">if</span> a == b:</span><br><span class="line">    print(<span class="string">&quot;you are right&quot;</span>)</span><br><span class="line">&gt;&gt;</span><br><span class="line">right</span><br></pre></td></tr></table></figure>

<p><strong>5.添加新键会改变已有键的顺序</strong></p>
<blockquote>
<p>尽量不要边遍历边添加新键</p>
</blockquote>
<ul>
<li>添加新键</li>
<li>python解释器为字典扩容</li>
<li>新键散列表并把已有元素添加到新表中</li>
<li>这个过程可能会发生散列冲突,导致新散列表中键的次序变化</li>
<li>如果在迭代一个字典的所有键的过程中同时对字典进行修改,那么这个循环可能会跳过一些键甚至是字典中已有的键</li>
</ul>
<p>因此:不要对字典同时进行迭代和修改,如果扫描并修改一个字典,最好分成俩步 :</p>
<p>​        [迭代–得出要添加的内容–并把内容放到新字典]  </p>
<p>​        [对原有字典进行更新]</p>
<p>不过在<code>python3</code>中对此进行了优化,<code>.keys()</code> <code>.items()</code> <code>.values()</code>方法返回的都是字典视图, 换句话说这些方法返回的更像<code>set</code>而不是<code>list</code>,此外视图还可以动态的反馈字典的变化</p>
<h3 id="3-9-4-set的实现和限制"><a href="#3-9-4-set的实现和限制" class="headerlink" title="3.9.4 set的实现和限制"></a>3.9.4 set的实现和限制</h3><blockquote>
<p>set 和 frozenset的实现也依赖于散列表</p>
</blockquote>
<ul>
<li>在散列表中只存放元素的引用(类似只存放key的引用)</li>
<li>集合中的元素必须是可散列的</li>
<li>集合很消耗内存</li>
<li>可以很高效的判断元素是否在集合中</li>
<li>元素的次序取决于被添加到集合中的顺序</li>
<li>在集合里添加元素会改变集合里已有元素的次序</li>
</ul>
<h2 id="本章小结-1"><a href="#本章小结-1" class="headerlink" title="本章小结"></a>本章小结</h2><p><code>dict</code>是<code>python</code>的基石, 除了<code>dict</code>外<code>builtin</code>里还提供了特殊映射比如<code>collections</code>里的<code>defaultdict</code> <code>OrderDict</code> <code>ChainMap</code> <code>Counter</code> <code>UserDict</code>以及<code>types</code>里的<code>MappingProxyTypes</code></p>
<p><strong>映射类型的重要方法</strong></p>
<p><strong>1.setdefault</strong></p>
<ul>
<li>更新字典里存档的可变值(比如列表)</li>
<li>避免重复搜索键</li>
</ul>
<p><strong>2.update</strong></p>
<ul>
<li>让批量更新字典成为可能</li>
</ul>
<p><strong>3.missing</strong></p>
<ul>
<li>可以自定当找不到对应的<code>key</code>时, 对象如何处理</li>
</ul>
<p><code>collections.abc</code>模块提供了<code>Mapping</code>和<code>MutableMapping</code>俩大抽象基类,利用它可以进行类型查询或者引用,此外还有<code>Set</code>和<code>MutableSet</code>俩大抽象基类</p>
<h1 id="Part4-TextAndBytes"><a href="#Part4-TextAndBytes" class="headerlink" title="Part4.TextAndBytes"></a>Part4.TextAndBytes</h1><blockquote>
<p>human use text and computer use bytes.</p>
</blockquote>
<p>本章节主要讨论:</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 字符 码位 字节表述</li>
<li><input checked="" disabled="" type="checkbox"> <code>bytes</code> <code>bytearray</code> 和 <code>memoryview</code>等二进制序列的独特性</li>
<li><input checked="" disabled="" type="checkbox"> 全部<code>unicode</code>和陈旧字符集的编解码器</li>
<li><input checked="" disabled="" type="checkbox"> 避免和处理编码错误</li>
<li><input checked="" disabled="" type="checkbox"> 处理文本文件的最佳实践</li>
<li><input checked="" disabled="" type="checkbox"> 默认编码的陷阱和标准<code>I/O</code>问题</li>
<li><input checked="" disabled="" type="checkbox"> 规范化 <code>Unicode</code>文本 进行安全比较</li>
<li><input checked="" disabled="" type="checkbox"> 规范化 大小写折叠和暴力移除音调符号的实用函数</li>
<li><input checked="" disabled="" type="checkbox"> 使用<code>locale</code>模块和<code>PyUCA</code>库正确地排序<code>Unicode</code>文本</li>
<li><input checked="" disabled="" type="checkbox"> <code>Unicode</code>数据库中的字符元数据</li>
<li><input checked="" disabled="" type="checkbox"> 能处理字符串和字节序列的双模式<code>API</code></li>
</ul>
<h2 id="4-1-字符问题"><a href="#4-1-字符问题" class="headerlink" title="4.1 字符问题"></a>4.1 字符问题</h2><blockquote>
<p>字符串:一个字符序列, 本质上是一个序列; 问题是什么是字符?</p>
<p>2015年字符的定义为Unicode字符(面向人)</p>
</blockquote>
<p>Unicode标准把字符的标识-和具体的字节表述进行了区分:</p>
<ul>
<li><strong>字符的标识即码位</strong>:是0<del>1114111的数字(10进制)在<code>unicode</code>标准中以4</del>6个十六进制数字标识,并且加前缀<code>U+</code></li>
<li><strong>字符的具体表述取决于所用的编码</strong>:编码是在码位和字节序列之间转换时使用的算法</li>
</ul>
<p><strong>把码位转化成字节序列的过程时编码,反之是解码</strong></p>
<p>简单的理解: </p>
<p><strong>码位</strong>是数字映射后的准备编码的<strong>字符标识</strong>;</p>
<p><strong>字节序列</strong>是通过一定编码规则(算法)编码后的用于计算机存储和传播的<strong>字节序列</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/20220313165653.png"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># init string</span></span><br><span class="line">a = <span class="string">&#x27;advdv我&#x27;</span>  </span><br><span class="line"></span><br><span class="line"><span class="comment"># advdv我字符串有四个Unicode字符</span></span><br><span class="line">print(<span class="built_in">len</span>(a))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用UTF-8把str对象编码成bytes对象</span></span><br><span class="line">b = a.encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># check b and len of b</span></span><br><span class="line"><span class="comment"># \xe6 --&gt; one 16-base</span></span><br><span class="line"><span class="comment"># 我 -encode-&gt; three bytes</span></span><br><span class="line"><span class="comment"># -&gt; \xe6\x88\x91</span></span><br><span class="line">print(b, <span class="built_in">len</span>(b))</span><br><span class="line"></span><br><span class="line"><span class="comment"># decode b with utf-8</span></span><br><span class="line"><span class="comment"># 使用UTF-8把bytes对象解码成str对象</span></span><br><span class="line">print(b.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line">&gt;&gt;</span><br><span class="line"><span class="number">6</span> </span><br><span class="line"><span class="comment"># bytes对象字面量以b开头</span></span><br><span class="line"><span class="comment"># 字节序列b有8个字节 我被编码成了三个字节</span></span><br><span class="line"><span class="string">b&#x27;advdv\xe6\x88\x91&#x27;</span> <span class="number">8</span></span><br><span class="line">advdv我</span><br></pre></td></tr></table></figure>

<p><code>python3</code>的<code>str</code>类型基本相当于<code>python2</code>的<code>unicode</code>类型, 但是前者的<code>bytes</code>类型却不是把<code>str</code>类型换个名字那么简单</p>
<h2 id="4-2-字节概要"><a href="#4-2-字节概要" class="headerlink" title="4.2 字节概要"></a>4.2 字节概要</h2><p><code>python</code>内置了两个基本的二进制序列类型其中有<code>py3</code>引入的不可变<code>bytes</code>类型和<code>py2.6</code>添加的可变<code>bytesarray</code>类型</p>
<p><code>bytes</code>和<code>bytearray</code>对象的各个元素是介于<code>0~255(含)</code>之间的整数而不是<code>py2</code>的<code>str</code>对象那样的单个字符.</p>
<p>需要注意的是二进制序列的切片始终是同一类型的二进制序列</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># bytes对象可以从str对象加给定的编码方法构建</span></span><br><span class="line">cafe = <span class="built_in">bytes</span>(<span class="string">&quot;cafの&quot;</span>, encoding=<span class="string">&quot;utf_8&quot;</span>)</span><br><span class="line">print(cafe)</span><br><span class="line"></span><br><span class="line"><span class="comment"># bytes对象中的各个元素是range(256)的整数</span></span><br><span class="line">print(cafe[<span class="number">0</span>])</span><br><span class="line"><span class="comment"># bytes对象的切片依然是bytes</span></span><br><span class="line">print(cafe[:<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># bytesarray对象没有字面量语句而是以bytearray()</span></span><br><span class="line"><span class="comment"># 和字节序列字面量参数的形式显示</span></span><br><span class="line">cafe_arr = <span class="built_in">bytearray</span>(cafe)</span><br><span class="line">print(cafe_arr)</span><br><span class="line"><span class="comment"># bytearray对象的切片还是bytearray对象</span></span><br><span class="line">print(cafe_arr[-<span class="number">1</span>:])</span><br><span class="line"></span><br><span class="line">&gt;&gt;</span><br><span class="line"><span class="string">b&#x27;caf\xe3\x81\xae&#x27;</span></span><br><span class="line"><span class="number">99</span></span><br><span class="line"><span class="string">b&#x27;c&#x27;</span></span><br><span class="line"><span class="built_in">bytearray</span>(<span class="string">b&#x27;caf\xe3\x81\xae&#x27;</span>)</span><br><span class="line"><span class="built_in">bytearray</span>(<span class="string">b&#x27;\xae&#x27;</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>二进制序列本质上整数序列,但是他们的字面量表示含有ASCII文本,因此各个字节的值会有以下三种不同的方式显示 –&gt; 例如<code>b&#39;xxxxx\xx\xx\t&#39;</code></p>
</blockquote>
<ul>
<li>可打印的ASCII范围内的字节(从空格到~)使用ASCII字符本身</li>
<li>制表符 换行符 回车符和\ 使用转义序列 <code>\t</code> <code>\n</code>  <code>\r</code> <code>\\</code></li>
<li>其他字节的值,使用十六进制转义序列(<code>\x00</code>空字节)</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/20220313200437.png"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="built_in">bytes</span>.fromhex(<span class="string">&#x27;31 4b ce a9&#x27;</span>)</span><br><span class="line">print(a)</span><br><span class="line"><span class="string">b&#x27;1K\xce\xa9&#x27;</span></span><br><span class="line">31(16进制) --&gt; 49(10进制) --&gt; ASCII(1K)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">在ASCII中K代表10进制</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="4-2-1-str方法"><a href="#4-2-1-str方法" class="headerlink" title="4.2.1 str方法"></a>4.2.1 str方法</h3><p><strong>1.casefold</strong></p>
<p><code>lower()</code> 只对 ASCII 也就是 <code>&#39;A-Z&#39;</code>有效，但是其它一些语言里面存在小写的情况就没办法了。文档里面举得例子是德语中<code>&#39;ß&#39;</code>的小写是<code>&#39;ss&#39;</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&#x27;ß&#x27;</span></span><br><span class="line">s.lower() <span class="comment">#  &#x27;ß&#x27;</span></span><br><span class="line">s.casefold() <span class="comment"># &#x27;ss&#x27;</span></span><br></pre></td></tr></table></figure>

<p>汉语 &amp; 英语环境下面，继续用 <code>lower()</code>没问题；要处理其它语言且存在大小写情况的时候再用<code>casefold()</code></p>
<p><strong>2.isdecimal</strong></p>
<p>判断<code>string</code>是否是十进制, 返回<code>bool</code>空字符为<code>False</code></p>
<p><strong>3.isidentifier</strong></p>
<blockquote>
<p>Python 对各种变量、方法、函数等命名时使用的字符序列称为标识符</p>
</blockquote>
<p>检查<code>string</code>是否是<code>python</code>标识符</p>
<p>标准为:</p>
<ul>
<li><p>由 26 个英文字母大小写，0-9 ，_ 组成，不能以数字开头，且严格区分大小写</p>
</li>
<li><p>不能包含空格、@、% 以及 $ 等特殊字符，不能以系统保留关键字作为标识符一共有25 个</p>
</li>
<li><p>以下划线开头的标识符有特殊含义</p>
</li>
</ul>
<p>对应<code>keyword.iskeyword(str)</code>检查是否是<code>python</code>保留的关键字</p>
<p><strong>4.isnumeric</strong></p>
<p><code>isnumeric()</code> 方法检测字符串是否只由数字组成，数字可以是<code>Unicode</code>数字，全角数字（双字节） 罗马数字 汉字数字。指数类似 <strong>²</strong> 与分数类似 <strong>½</strong> 也属于数字。返回<code>bool</code></p>
<p><strong>5.isprintable</strong></p>
<p>判断是否是可打印字符,不可打印的有:</p>
<ul>
<li>换行符制表符等<code>\t \n</code></li>
</ul>
<p><strong>6.translate</strong></p>
<p><code>s.transelate(table)</code></p>
<p><code>table</code>用<code>str.maketrans(in-str, out-str)</code>生成<strong>用于创建字符映射的转换表</strong></p>
<p>转换表本质上整数映射</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(transtable)</span><br><span class="line"></span><br><span class="line">&#123;<span class="number">115</span>: <span class="number">109</span>, <span class="number">111</span>: <span class="number">97</span>, <span class="number">109</span>: <span class="number">110</span>, <span class="number">101</span>: <span class="number">121</span>&#125;</span><br></pre></td></tr></table></figure>

<p>以<code>table</code>作为基础替换<code>s</code>中所有命中的字符</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">&quot;i like something relaxing!&quot;</span></span><br><span class="line">in_str = <span class="string">&quot;some&quot;</span></span><br><span class="line">out_str = <span class="string">&quot;many&quot;</span></span><br><span class="line">transtable = <span class="built_in">str</span>.maketrans(in_str, out_str)</span><br><span class="line"></span><br><span class="line">print(a.translate(transtable))</span><br><span class="line">&gt;&gt;</span><br><span class="line">i liky manything rylaxing!</span><br></pre></td></tr></table></figure>

<hr>
<p><code>str</code>类型的其他方法都支持<code>bytes</code>和<code>bytearray</code>类型</p>
<p><strong>二进制序列并不是指字节序列全是二进制编码,而是指用于计算机存储和传播的二进制字节序列即字节序列,其本质上还是整数序列</strong></p>
<ul>
<li>在<code>ASCII</code>中<code>K</code>表示十进制</li>
<li><code>1k</code>表示十进制<code>1</code></li>
</ul>
<hr>
<p>构建<code>bytes</code>或<code>bytearray</code>实例还可以调用各自的构造方法,传参如下:</p>
<ul>
<li>一个<code>str</code>对象(码位)和<code>encoding</code>关键字参数(编码规则)</li>
<li>一个可迭代对象, 提供<code>0~255</code>数值</li>
<li>一个实现缓冲协议的对象<code>(bytes bytearray memoryview array.array)</code> 此时把源对象中的字节序列复制到新建的二进制序列中</li>
</ul>
<p>注意使用缓冲类对象构建二进制序列是一个底层操作,可能涉及类型转换</p>
<p><strong>下面是将<code>array.array</code>转化成字节序列表示</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> array</span><br><span class="line"><span class="comment"># 创建一个短整数16位数组</span></span><br><span class="line">numbers = array.array(<span class="string">&#x27;h&#x27;</span>, [-<span class="number">2</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line"><span class="comment"># 保存组成的numbers的字节序列副本</span></span><br><span class="line">to_bytes = <span class="built_in">bytes</span>(numbers)</span><br><span class="line"><span class="comment"># 表示5个短整数的10个字节</span></span><br><span class="line">print(to_bytes)</span><br><span class="line">&gt;&gt;</span><br><span class="line"><span class="string">b&#x27;\xfe\xff\xff\xff\x00\x00\x01\x00\x02\x00&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个空array接收bytes</span></span><br><span class="line"><span class="comment"># 并输出结构化的bytes</span></span><br><span class="line">temp_array = array.array(<span class="string">&#x27;h&#x27;</span>)</span><br><span class="line">print(temp_array.frombytes(to_bytes))</span><br><span class="line">print(temp_array)</span><br><span class="line">&gt;&gt;</span><br><span class="line"><span class="literal">None</span></span><br><span class="line">array(<span class="string">&#x27;h&#x27;</span>, [-<span class="number">2</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>])</span><br></pre></td></tr></table></figure>

<p><strong>需要注意</strong></p>
<ul>
<li><p><strong>使用缓冲类对象<code>(bytes bytearray array.array memoryview)</code>创建<code>bytes</code> <code>bytearray</code>对象时, 始终复制的是源对象中的字节序列</strong></p>
</li>
<li><p>不过<code>memoryview</code>对象允许在二进制数据结构之间共享内存</p>
</li>
<li><p>从二进制序列提取结构化信息需要<code>struct</code>模块</p>
</li>
</ul>
<h3 id="4-2-2-结构体和内存视图"><a href="#4-2-2-结构体和内存视图" class="headerlink" title="4.2.2 结构体和内存视图"></a>4.2.2 结构体和内存视图</h3><p><code>struct</code>模块提供了一些函数, 把打包的字节序列转换成不同类型字段组成的元组,还有一些函数用于执行反向转换,把元组转化成打包的字节序列.可以处理<code>bytes</code> <code>bytearray</code> <code>memoryview</code>对象</p>
<p><strong>注意</strong>:</p>
<p><code>memoryview</code>类不是用于创建或存储字节序列的, 而是共享内存,让你访问其他二进制序列 打包的数组和缓冲中的数据切片,而无需复制字节序列</p>
<p><strong>memoryview 对象的切片是一个新 memoryview 对象，而且不会复制字节序列</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="comment"># 结构体格式: &lt; 小字节序列</span></span><br><span class="line"><span class="comment">#		  3s3s 俩个3字节序列</span></span><br><span class="line"><span class="comment">#         HH   俩个16位二进制整数</span></span><br><span class="line">fmt = <span class="string">&quot;&lt;3s3sHH&quot;</span></span><br><span class="line">whith <span class="built_in">open</span>(<span class="string">&quot;filter.gif&quot;</span>, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">    <span class="comment"># 使用内存中的文件内容创建一个memoryview对象</span></span><br><span class="line">    img = <span class="built_in">memoryview</span>(fp.read())</span><br><span class="line"><span class="comment"># 使用他的切片再创建一个mv对象(这里不会复制字节序列)</span></span><br><span class="line">header = img[:<span class="number">10</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转化成字节序列(10字节)</span></span><br><span class="line"><span class="built_in">bytes</span>(header)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拆包mv对象获得一个元组包括类型 版本 宽度 高度</span></span><br><span class="line">struct.unpack(fmt, header)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除引用 释放mv实列占用的内存</span></span><br><span class="line"><span class="keyword">del</span> header</span><br><span class="line"><span class="keyword">del</span> img</span><br></pre></td></tr></table></figure>

<p>如果经常处理二进制数据推荐阅读:</p>
<p><strong><a target="_blank" rel="noopener" href="https://docs.python.org/3/library/stdtypes.html#memory-views">memoryview</a></strong></p>
<p><a target="_blank" rel="noopener" href="https://docs.python.org/3/library/struct.html"><strong>struct interpret bytes as packed binary data</strong></a></p>
<h2 id="4-3-基本的编解码器"><a href="#4-3-基本的编解码器" class="headerlink" title="4.3 基本的编解码器"></a>4.3 基本的编解码器</h2><blockquote>
<p>python自带了超过100种编解码器(编码算法)用于在文本和字节之间相互转换</p>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/496D8BAFE68A48610FC47DBC7BB2A83F.png" style="zoom:150%;" />

<p>其中后三者是可变长度的多字节编码, 其余都是单字节编码</p>
<p>图中星号表示某些编码(<code>ASCII</code>和多字节编码<code>GB2312</code>)不能表示所有的<code>Unicode</code>字符, <code>UTF</code>编码的设计目的是处理每一个<code>Unicode</code>码位</p>
<h2 id="4-4-编解码问题"><a href="#4-4-编解码问题" class="headerlink" title="4.4 编解码问题"></a>4.4 编解码问题</h2><blockquote>
<p>编解码涉及到<code>unicode</code>或者<code>string</code>或称<code>码位</code>与<code>byte</code>的编解码转换</p>
</blockquote>
<p>编解码异常有三种:</p>
<p><strong>1.UnicodeEncodeError</strong></p>
<p><code>str</code>转<code>byte</code>异常</p>
<p><strong>2.UnicodeDecodeError</strong></p>
<p><code>byte</code>转<code>str</code>异常</p>
<p><strong>3.SynatxError</strong></p>
<p>如果在编解码中,源码的编码与预期不符, 在加载模块时会抛出语法异常</p>
<h3 id="4-4-1-UnicodeEncodeError"><a href="#4-4-1-UnicodeEncodeError" class="headerlink" title="4.4.1 UnicodeEncodeError"></a>4.4.1 UnicodeEncodeError</h3><h3 id="4-4-2-UnicodeDecodeError"><a href="#4-4-2-UnicodeDecodeError" class="headerlink" title="4.4.2 UnicodeDecodeError"></a>4.4.2 UnicodeDecodeError</h3><h3 id="4-4-3-SyntaxError"><a href="#4-4-3-SyntaxError" class="headerlink" title="4.4.3 SyntaxError"></a>4.4.3 SyntaxError</h3><blockquote>
<p>多数非<code>UTF</code>编解码器只能处理<code>Unicode</code>字符的一小部分子集, 把文本转化成字节序列时, 如果目标编码中没有定义某个字符就会抛该异常, 处理方式是把<code>errors</code>参数传给编码方法或函数,对错误进行特殊处理</p>
</blockquote>
<blockquote>
<p>不是每个字节都包含有效的ASCII字符,也不是每个字符序列都是有效<code>UTF-8</code> 或<code>UTF-16</code> 因此,在把二进制序列转化成文本时, 如果假设是这俩个编码中的一个, 遇到无法转换的字节序列时会抛出UnicodeDecodeError</p>
</blockquote>
<p><strong>str.en|decode(encoding=””, errors=””)</strong></p>
<p><code>errors</code>接收四个参数</p>
<ul>
<li><p>strict: 遇到无法编码的字符raise error</p>
</li>
<li><p>ignore: 忽略不能编码的字符</p>
</li>
<li><p>replace: 使用<code>?</code>代替不能编码的字符</p>
</li>
<li><p>xmlcharrefreplace: 把无法编码的字符替换成XML实体</p>
</li>
</ul>
<p>需要注意的是errors接受的参数是可以扩展的, 你可以位errors参数注册额外的字符串方法<code>codecs.register_error</code>函数</p>
<ul>
<li>python3允许在源码中使用非ASCII标识符</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">β = <span class="number">1</span></span><br><span class="line">print(β)</span><br></pre></td></tr></table></figure>

<h3 id="4-4-4-找出字节序列编码"><a href="#4-4-4-找出字节序列编码" class="headerlink" title="4.4.4 找出字节序列编码"></a>4.4.4 找出字节序列编码</h3><blockquote>
<p>简单的说一般找不出字节序列的编码, 有些通讯协议和文件格式, 比如 HTTP和XML包含<strong>明确指明内容编码的首部</strong>. 可以肯定的是, 某些字节流不是ASCII, 因为其中包含大于127的字节值, 而且制定UTF-8和UTF-16的方式也限制了可用的字节序列.即使如此我们也无法根据特定的位模式来确定二进制文件的编码时ASCII或UTF-8</p>
</blockquote>
<p>  统一字符编码侦测包<code>Chartdetect</code>,可以识别30中编码</p>
<p>二进制序列编码通常不会指明自己的编码, 但是<code>UTF</code>格式可以在文本内容的开头添加一个字节序列标记</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> chardet</span><br><span class="line">a = chardet.detect(<span class="string">b&quot;sddssfsd&quot;</span>)</span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line">&#123;<span class="string">&#x27;encoding&#x27;</span>: <span class="string">&#x27;ascii&#x27;</span>, <span class="string">&#x27;confidence&#x27;</span>: <span class="number">1.0</span>, <span class="string">&#x27;language&#x27;</span>: <span class="string">&#x27;&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-4-5-BOM有用的鬼符"><a href="#4-4-5-BOM有用的鬼符" class="headerlink" title="4.4.5 BOM有用的鬼符"></a>4.4.5 BOM有用的鬼符</h3><blockquote>
<p>BOM (bytes-Order-Mark)字节序列标记, 指明编码时使用的是IntelGPU的小子节序</p>
</blockquote>
<ul>
<li><code>utf-16</code>有俩种编码格式<code>UTF-16LE</code>小子节序<code>UTF-6BE</code>大字节序</li>
<li>小子节序各个码位的最低有效字节在前面, 大字节序相反(Unicode码位)</li>
<li>因此在<code>utf-16</code>编码中使用开头的BOM<code>b&#39;\xff\xfe&#39;</code>十进制(255 254)表示小子节编码</li>
<li><code>utf-8</code>无论设备使用哪种字节序,生成的字节序列始终一致, 因此不需要BOM</li>
</ul>
<h2 id="4-5-处理文本文件"><a href="#4-5-处理文本文件" class="headerlink" title="4.5 处理文本文件"></a>4.5 处理文本文件</h2><p><img src="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/20220320144303.png"></p>
<p>处理文本文件最好的方式是三明治处理法, 首先将输入的字节序列转码成字符串, 在对字符串进行处理, 最后把处理好的字符串编码成字节序列进行输出</p>
<p><code>Python3</code>中的<code>Open</code>函数会在读取文本进行必要的解码, 在以文本模式写入文件时也会进行必要的编码, 所以<code>my_file.read()</code>方法得到的以及传递给<code>my_file.write(text)</code>方法的都是字符串对象</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用utf-8编码打开(创建)txt文件, 模式位写</span></span><br><span class="line"><span class="comment"># 此时使用open函数创建一个TextIowrapper对象</span></span><br><span class="line">fp = <span class="built_in">open</span>(<span class="string">&quot;text.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">print(fp)</span><br><span class="line">&lt;_io.TextIOWrapper name=<span class="string">&#x27;text.txt&#x27;</span> mode=<span class="string">&#x27;w&#x27;</span> encoding=<span class="string">&#x27;utf-8&#x27;</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将字符串对象写入TextIo对象中</span></span><br><span class="line">fp.write(<span class="string">&quot;Drink&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭TextIo对象</span></span><br><span class="line">fp.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="comment"># 调用系统stat,查看路径文件的字节大小</span></span><br><span class="line">print(os.stat(<span class="string">&quot;text.txt&quot;</span>).st_size)</span><br><span class="line"><span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开文本文件, 返回一个TextIoWrapper对象</span></span><br><span class="line"><span class="comment"># 编码是区域设置中的默认值</span></span><br><span class="line">fp2 = <span class="built_in">open</span>(<span class="string">&quot;text.txt&quot;</span>)</span><br><span class="line"><span class="comment"># TextIO对象有encoding属性, 查看所使用的编码</span></span><br><span class="line">print(fp2.encoding)</span><br><span class="line">cp936</span><br><span class="line">fp2.read()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以特定的编码方式打开文本文件流</span></span><br><span class="line">fp3 = <span class="built_in">open</span>(<span class="string">&quot;text.txt&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">fp3.read()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用open函数创建一个BytesIoWrapper对象</span></span><br><span class="line">fp4 = <span class="built_in">open</span>(<span class="string">&quot;text.txt&quot;</span>, <span class="string">&quot;rb&quot;</span>)</span><br><span class="line"><span class="comment"># 在二进制模式即字节流中返回的是BufferedReader对象</span></span><br><span class="line"><span class="comment"># 其满足buffer-protocol协议</span></span><br><span class="line">print(fp4)</span><br><span class="line">&lt;_io.BufferedReader name=<span class="string">&#x27;text.txt&#x27;</span>&gt;</span><br><span class="line">fp4.read()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>除非想要判断编码否则不要使用二进制模式打开文本文件, 即便想要查看编码类型也不要重复发明轮子, 可以使用chardet</p>
</blockquote>
<p><strong>通常不建议使用默认编码方式取处理二进制或文本流</strong></p>
<h3 id="编码默认值"><a href="#编码默认值" class="headerlink" title="编码默认值"></a>编码默认值</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> locale</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">expressions = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    locale.getpreferredencoding()</span></span><br><span class="line"><span class="string">    type(my_file)</span></span><br><span class="line"><span class="string">    sys.stdout.isatty()</span></span><br><span class="line"><span class="string">    sys.stdout.encoding</span></span><br><span class="line"><span class="string">    sys.stdin.isatty()</span></span><br><span class="line"><span class="string">    sys.stdin.encoding</span></span><br><span class="line"><span class="string">    sys.stderr.isatty()</span></span><br><span class="line"><span class="string">    sys.stderr.encoding</span></span><br><span class="line"><span class="string">    sys.getdefaultencoding()</span></span><br><span class="line"><span class="string">    sys.getfilesystemencoding()</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">my_file = <span class="built_in">open</span>(<span class="string">&#x27;dummy&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> expression <span class="keyword">in</span> expressions.split():</span><br><span class="line">    value = <span class="built_in">eval</span>(expression)</span><br><span class="line">    print(expression.rjust(<span class="number">30</span>), <span class="string">&quot;--&gt;&quot;</span>, <span class="built_in">repr</span>(value))</span><br><span class="line"></span><br><span class="line">sys.stdin.isatty()</span><br><span class="line">sys.stderr.isatty()</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">locale.getpreferredencoding() --&gt; &#x27;cp936&#x27;</span><br><span class="line">                type(my_file) --&gt; &lt;class &#x27;_io.TextIOWrapper&#x27;&gt;</span><br><span class="line">          sys.stdout.isatty() --&gt; False</span><br><span class="line">          sys.stdout.encoding --&gt; &#x27;UTF-8&#x27;</span><br><span class="line">           sys.stdin.isatty() --&gt; False</span><br><span class="line">           sys.stdin.encoding --&gt; &#x27;UTF-8&#x27;</span><br><span class="line">          sys.stderr.isatty() --&gt; False</span><br><span class="line">          sys.stderr.encoding --&gt; &#x27;UTF-8&#x27;</span><br><span class="line">     sys.getdefaultencoding() --&gt; &#x27;utf-8&#x27;</span><br><span class="line">  sys.getfilesystemencoding() --&gt; &#x27;utf-8&#x27;</span><br></pre></td></tr></table></figure>

<p><code>sys.getfilesystemencoding()</code>用于编解码文件名而非文件内容, 把字符串参数作为文件名传给<code>open()</code>函数会使用它, 如果是字节序列则直接传给<code>OS API</code></p>
<blockquote>
<p><code>locale.getprefferedencoding()</code>返回的编码即是打开文件的默认编码,同时也是重定向文件的<code>sys.stdout/stdin/stderr</code></p>
</blockquote>
<blockquote>
<p>不要依赖默认编码尤其是windows用户</p>
</blockquote>
<h2 id="4-6-规范化Unicode字符"><a href="#4-6-规范化Unicode字符" class="headerlink" title="4.6 规范化Unicode字符"></a>4.6 规范化Unicode字符</h2><blockquote>
<p>因为Unicode有组合字符(变音字符和附加到前一个字符上的记号, 打印时作为一个整体)所以字符串比较起来比较复杂</p>
</blockquote>
<p>比如<code>é</code>这个词, 是<code>e</code>后加<code>U+0301</code>得来的, 在<code>unicode</code>中称为标准等价物, 但是<code>python</code>看到的是不同的码位序列, 因此判断两者不相等, 这时就需要一个统一的标准, 来规范化<code>Unicode</code>就像规范两种方言一样</p>
<p>使用<code>unicodedata.normalize</code>函数</p>
<p>第一个参数:</p>
<ul>
<li><strong>NFC (Normalization Form C)</strong></li>
</ul>
<p>使用最少的码位构成等价的字符串</p>
<ul>
<li><strong>NFD</strong></li>
</ul>
<p>把组合字符分解成 [基字符] 和 [单独的组合字符]</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">s1 = <span class="string">&quot;café&quot;</span></span><br><span class="line">s2 = <span class="string">&quot;cafe\u3001&quot;</span></span><br><span class="line"></span><br><span class="line">print(unicodedata.normalize(<span class="string">&quot;NFC&quot;</span>, s1))</span><br><span class="line">print(unicodedata.normalize(<span class="string">&quot;NFC&quot;</span>, s2))</span><br><span class="line"></span><br><span class="line">print(unicodedata.normalize(<span class="string">&quot;NFD&quot;</span>, s1))</span><br><span class="line">print(unicodedata.normalize(<span class="string">&quot;NFD&quot;</span>, s2))</span><br><span class="line"></span><br><span class="line">café</span><br><span class="line">cafe、</span><br><span class="line">café</span><br><span class="line">cafe、</span><br></pre></td></tr></table></figure>

<blockquote>
<p>用户输入的文本默认是NFC格式, 在保存文本前, 最好使用normalization(“NFC”, text)清洗字符串</p>
<p>需要注意的是, 在使用NFC清洗字符串时, 有些单字符会被规范成另一个单字符, 比如电阻的单位Ω会被规范成欧米茄, 在视觉上是一样的, 但在比较时并不相等</p>
</blockquote>
<ul>
<li><p>NFKC</p>
</li>
<li><p>NFKD</p>
</li>
</ul>
<p><strong>这俩个规范化方法是兼容性规范化, 这些规范化更适合用在用户搜索或索引上, 需要注意的是, 经过NFKC或者NFKD兼容性规范化后的字符可能会丧失原本的意义, 尽量不要用于数据的持久化</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s3 = <span class="string">&quot;¼&quot;</span></span><br><span class="line">print(unicodedata.normalize(<span class="string">&quot;NFKC&quot;</span>, s3))</span><br><span class="line">&gt;&gt; <span class="number">1</span>/<span class="number">4</span></span><br></pre></td></tr></table></figure>

<h3 id="4-6-1-大小写折叠"><a href="#4-6-1-大小写折叠" class="headerlink" title="4.6.1 大小写折叠"></a>4.6.1 大小写折叠</h3><blockquote>
<p>即将所有的字符转化成小写, 相比于lower()只支持Unicode, casefold()支持更多的大小写转化, 尽管如此, 两者不同的字符仅有116个码位, 占比0.11%</p>
</blockquote>
<h3 id="4-6-2-规范化文本匹配实用函数"><a href="#4-6-2-规范化文本匹配实用函数" class="headerlink" title="4.6.2 规范化文本匹配实用函数"></a>4.6.2 规范化文本匹配实用函数</h3><blockquote>
<p>NFC和NFD可以很合理的比较Unicode字符串, 并且NFC是最好的规范化形式, 不区分大小写应该使用casefold()</p>
</blockquote>
<p><strong>1.去掉变音字符号</strong></p>
<blockquote>
<p>unicodedata.combining (unichr) <strong>将分配给Unicode字符 unichr 的规范组合类 返回 为整数</strong>。 如果未定义组合类，则返回 0 。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> unicodedata <span class="keyword">import</span> normalize</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shave_marks</span>(<span class="params">txt</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    去掉所有的变音符号</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 把所有的字符拆成基字符和组合记号</span></span><br><span class="line">    norm_txt = unicodedata.normalize(<span class="string">&quot;NFD&quot;</span>, txt)</span><br><span class="line">    <span class="comment"># 过滤掉所有组合记号</span></span><br><span class="line">    shaved = <span class="string">&quot;&quot;</span>.join(c <span class="keyword">for</span> c <span class="keyword">in</span> norm_txt <span class="keyword">if</span> <span class="keyword">not</span> unicodedata.combining(c))</span><br><span class="line">    <span class="comment"># 重组所有字符</span></span><br><span class="line">    <span class="keyword">return</span> unicodedata.normalize(<span class="string">&quot;NFC&quot;</span>, shaved)</span><br></pre></td></tr></table></figure>

<p><strong>2.比较字符是否相等|忽略大小写</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> unicodedata <span class="keyword">import</span> normalize</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nfc_equal</span>(<span class="params">str1, str2</span>):</span></span><br><span class="line">    <span class="keyword">return</span> normalize(<span class="string">&quot;NFC&quot;</span>, str1) == normalize(<span class="string">&quot;NFC&quot;</span>, str2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fold_equal</span>(<span class="params">str1, str2</span>):</span></span><br><span class="line">    <span class="keyword">return</span> (normalize(<span class="string">&quot;NFC&quot;</span>, str1).casefold() == </span><br><span class="line">            normalize(<span class="string">&quot;NFC&quot;</span>, str2).casefold())</span><br></pre></td></tr></table></figure>

<h2 id="4-7-Unicode文本排序"><a href="#4-7-Unicode文本排序" class="headerlink" title="4.7 Unicode文本排序"></a>4.7 Unicode文本排序</h2><blockquote>
<p>对于ASCII字符串来说比较的是码位, 但在非ASCII字符时会使用locale.strxfrm函数, 这个函数会把string转化成适合的区域进行比较</p>
</blockquote>
<p>需要注意的是, 一般情况下, 变音符不会对排序造成影响, 如果有影响, 变音符号常常排在常规词后面</p>
<p>在使用locale.strxfrm函数作为排序key前, 要先调用setlocale(LC_COLLATE, your_locale)</p>
<p>需要注意:</p>
<ol>
<li>区域设置是全局的, 不建议库中调用, 且应用或框架应该在进程中调用</li>
<li>操作系统必须支持区域设置</li>
</ol>
<p><strong>使用unicode排序算法排序</strong></p>
<p><code>pyuca</code> </p>
<blockquote>
<p>Python Unicode Collator Algorithm</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pyuca</span><br><span class="line"></span><br><span class="line">coll = pyuca.Collator()</span><br><span class="line">fruits = [<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;alle&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;bba&quot;</span>]</span><br><span class="line">sorted_fruits = <span class="built_in">sorted</span>(fruits, key=coll.sort_key)</span><br><span class="line">print(sorted_fruits)</span><br></pre></td></tr></table></figure>

<h2 id="4-8-Unicode-数据库"><a href="#4-8-Unicode-数据库" class="headerlink" title="4.8 Unicode 数据库"></a>4.8 Unicode 数据库</h2><blockquote>
<p>本质上已经一个关于unicode以及个中映射关系的数据库, 就如码位与string bytes的映射一样, 同样基于此提供了许多双模式API对外调用, 出名的有unicodedata</p>
</blockquote>
<p><strong>regex库正在替代re库</strong></p>
<p><strong>双模式API是一个趋势</strong>: 即支持字符和字节参数,并根据参数的格式做出自适应的调整</p>
<h2 id="4-9-支持str和bytes的双模式API"><a href="#4-9-支持str和bytes的双模式API" class="headerlink" title="4.9 支持str和bytes的双模式API"></a>4.9 支持str和bytes的双模式API</h2><blockquote>
<p>标准库中一些函数能接受字符串或字节序列作为参数, 然后根据类型自适应做不同的行为, 其中re和os为例</p>
</blockquote>
<h3 id="4-9-1-正则str和bytes"><a href="#4-9-1-正则str和bytes" class="headerlink" title="4.9.1 正则str和bytes"></a>4.9.1 正则str和bytes</h3><table>
<thead>
<tr>
<th></th>
<th>unicode</th>
<th>bytes</th>
<th>次数|注</th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td></td>
<td></td>
<td>{0,}</td>
</tr>
<tr>
<td>+</td>
<td></td>
<td></td>
<td>{1,}</td>
</tr>
<tr>
<td>?</td>
<td></td>
<td></td>
<td>{0,1}</td>
</tr>
<tr>
<td>\d</td>
<td>匹配任何一个十进制数字, 包括[0-9]和其他数字字符</td>
<td>只匹配[0-9]</td>
<td>和re.ASCII</td>
</tr>
<tr>
<td>\w</td>
<td>任何Unicode字符, 所有语言|数字|下横线</td>
<td>[a-zA-A0-9]</td>
<td>和re.ASCII一样</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">re_numbers_str = re.<span class="built_in">compile</span>(<span class="string">r&quot;\d+&quot;</span>)</span><br><span class="line">re_words_str = re.<span class="built_in">compile</span>(<span class="string">r&quot;\w+&quot;</span>)</span><br><span class="line"></span><br><span class="line">re_numbers_bytes = re.<span class="built_in">compile</span>(<span class="string">rb&quot;\d+&quot;</span>)</span><br><span class="line">re_words_bytes = re.<span class="built_in">compile</span>(<span class="string">rb&quot;\w+&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里会默认拼接str</span></span><br><span class="line">text_str = <span class="string">&quot;Drink see \u0be7\u0be6\u0be5\u0be4&quot;</span> <span class="string">&quot;as 1999 = 1000 + 999&quot;</span></span><br><span class="line"></span><br><span class="line">text_bytes = text_str.encode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;TEXT&quot;</span>, <span class="built_in">repr</span>(text_str), sep=<span class="string">&quot;\n &quot;</span>)</span><br><span class="line">print(<span class="string">&quot;NUMBERS&quot;</span>)</span><br><span class="line">print(<span class="string">&quot;  str  :&quot;</span>, re_numbers_str.findall(text_str))</span><br><span class="line">print(<span class="string">&quot;  bytes:&quot;</span>, re_numbers_bytes.findall(text_bytes))</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;WORDS&quot;</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;  str  :&quot;</span>, re_words_str.findall(text_str))</span><br><span class="line">print(<span class="string">&quot;  bytes:&quot;</span>, re_words_bytes.findall(text_bytes))</span><br><span class="line"></span><br><span class="line">&gt;&gt;</span><br><span class="line">TEXT</span><br><span class="line"> <span class="string">&#x27;Drink see ௧௦\u0be5\u0be4as 1999 = 1000 + 999&#x27;</span></span><br><span class="line">NUMBERS</span><br><span class="line">  <span class="built_in">str</span>  : [<span class="string">&#x27;௧௦&#x27;</span>, <span class="string">&#x27;1999&#x27;</span>, <span class="string">&#x27;1000&#x27;</span>, <span class="string">&#x27;999&#x27;</span>]</span><br><span class="line">  <span class="built_in">bytes</span>: [<span class="string">b&#x27;1999&#x27;</span>, <span class="string">b&#x27;1000&#x27;</span>, <span class="string">b&#x27;999&#x27;</span>]</span><br><span class="line">WORDS</span><br><span class="line">  <span class="built_in">str</span>  : [<span class="string">&#x27;Drink&#x27;</span>, <span class="string">&#x27;see&#x27;</span>, <span class="string">&#x27;௧௦&#x27;</span>, <span class="string">&#x27;as&#x27;</span>, <span class="string">&#x27;1999&#x27;</span>, <span class="string">&#x27;1000&#x27;</span>, <span class="string">&#x27;999&#x27;</span>]</span><br><span class="line">  <span class="built_in">bytes</span>: [<span class="string">b&#x27;Drink&#x27;</span>, <span class="string">b&#x27;see&#x27;</span>, <span class="string">b&#x27;as&#x27;</span>, <span class="string">b&#x27;1999&#x27;</span>, <span class="string">b&#x27;1000&#x27;</span>, <span class="string">b&#x27;999&#x27;</span>]</span><br></pre></td></tr></table></figure>

<h3 id="4-9-2-os中的字符串和字节序列"><a href="#4-9-2-os中的字符串和字节序列" class="headerlink" title="4.9.2 os中的字符串和字节序列"></a>4.9.2 os中的字符串和字节序列</h3><blockquote>
<p>GNU/linux内核不理解Unicode, 因此文件名中使用字节序列都是无效的</p>
</blockquote>
<p>为了方便处理字符串或字节序列形式的文件名或路径名, os模块提供了特殊的编码和解码函数</p>
<p><strong>fsencode(filename)</strong></p>
<p>当filename是str时使用<code>sys.getfilesystemencoding()</code>编码成bytes</p>
<p><strong>fsdecode(filename)</strong></p>
<p>当filename是bytes时使用<code>sys.getfilesystemencoding()</code>解码成str</p>
<blockquote>
<p>在unix及其衍生平台中使用<code>surrogateescape</code>错误处理方式, 避免碰到意外字节卡住, windows使用strict, 这种处理方式在py3.1时被引进</p>
</blockquote>
<p>这种错误的处理方式实际上是将无法编码的字节替换成<code>Unicode</code>中<code>U+DC00</code>到<code>U+DCFF</code>之间的码位<code>(low surrogate area)</code>, 这些码位是保留的,没有分配字符, 只供程序内部使用</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://drinkle.top/2022/02/06/%E6%B5%81%E7%95%85%E7%9A%84python/" data-id="ckzb823ai0000ngf5h2vdfe6t" data-title="流畅的python" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/" rel="tag">Python</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-经济分析-1" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/11/14/%E7%BB%8F%E6%B5%8E%E5%88%86%E6%9E%90-1/" class="article-date">
  <time class="dt-published" datetime="2021-11-14T15:14:00.000Z" itemprop="datePublished">2021-11-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/11/14/%E7%BB%8F%E6%B5%8E%E5%88%86%E6%9E%90-1/">经济分析[1]</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://drinkle.top/2021/11/14/%E7%BB%8F%E6%B5%8E%E5%88%86%E6%9E%90-1/" data-id="ckwtcwj440000jof547g5dmg1" data-title="经济分析[1]" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-新闻联播-2" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/11/14/%E6%96%B0%E9%97%BB%E8%81%94%E6%92%AD-2/" class="article-date">
  <time class="dt-published" datetime="2021-11-14T15:13:39.000Z" itemprop="datePublished">2021-11-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/11/14/%E6%96%B0%E9%97%BB%E8%81%94%E6%92%AD-2/">新闻联播[2]</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://drinkle.top/2021/11/14/%E6%96%B0%E9%97%BB%E8%81%94%E6%92%AD-2/" data-id="ckwtcwj490001jof5gi3cd85y" data-title="新闻联播[2]" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Question" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/10/07/Question/" class="article-date">
  <time class="dt-published" datetime="2021-10-07T11:39:08.000Z" itemprop="datePublished">2021-10-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/10/07/Question/">Question</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Q21-SSLError"><a href="#Q21-SSLError" class="headerlink" title="Q21 SSLError"></a>Q21 SSLError</h2><h3 id="Info"><a href="#Info" class="headerlink" title="-Info"></a>-Info</h3><p>在使用<code>AsyncHTTPClient</code>调用<code>API</code>时, 出现错误</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AsyncHTTPClient</span><br><span class="line">ssl.SSLError: [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed (_ssl.c:<span class="number">852</span>)</span><br></pre></td></tr></table></figure>

<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="-Analysis"></a>-Analysis</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">url = <span class="string">&quot;https://txm.zidouchat.com/wx/get_access_token&quot;</span></span><br><span class="line">data = &#123;<span class="string">&quot;token&quot;</span>: <span class="string">&quot;doododisagreatcompany&quot;</span>&#125;</span><br><span class="line">body = json.dumps(data)</span><br><span class="line">response = <span class="keyword">await</span> httpclient.fetch(url, method=<span class="string">&quot;POST&quot;</span>, body=body)</span><br></pre></td></tr></table></figure>

<p>debug排查:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">print(ssl_options, host)</span><br><span class="line"><span class="keyword">if</span> ssl_options <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">	<span class="keyword">if</span> timeout <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">		stream = <span class="keyword">yield</span> gen.with_timeout(timeout, stream.start_tls(<span class="literal">False</span>, ssl_options=ssl_options, server_hostname=host))</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		stream = <span class="keyword">yield</span> stream.start_tls(<span class="literal">False</span>, ssl_options=ssl_options,server_hostname=host)</span><br><span class="line"><span class="keyword">raise</span> gen.Return(stream)</span><br></pre></td></tr></table></figure>

<p>此网站的ssl证书验证失败</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;ssl.SSLContext <span class="built_in">object</span> at <span class="number">0x7f9f0d393ac8</span>&gt;   txm.zidouchat.com</span><br></pre></td></tr></table></figure>

<h3 id="Solution"><a href="#Solution" class="headerlink" title="-Solution"></a>-Solution</h3><p>方法一</p>
<blockquote>
<p>在使用http链接建立请求时关闭ssl验证</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加ssl跳过验证</span></span><br><span class="line"><span class="keyword">import</span> ssl</span><br><span class="line">ssl_options = &#123;<span class="string">&quot;ssl_version&quot;</span>: ssl.PROTOCOL_TLSv1&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加ssl跳过验证</span></span><br><span class="line"><span class="keyword">if</span> ssl_options <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">	<span class="keyword">if</span> timeout <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">		stream = <span class="keyword">yield</span> gen.with_timeout(timeout, stream.start_tls(<span class="literal">False</span>, ssl_options=ssl_options, server_hostname=host))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        stream = <span class="keyword">yield</span> stream.start_tls(<span class="literal">False</span>, ssl_options=ssl_options,</span><br><span class="line">                                                server_hostname=host)</span><br></pre></td></tr></table></figure>

<p>方法二</p>
<blockquote>
<p>在实例化时赋予属性 validate_cert=False, 有一定风险仍然使用old_ssl</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tornado.httpclient</span><br><span class="line"></span><br><span class="line">request = tornado.httpclient.HTTPRequest(</span><br><span class="line">    url=<span class="string">&quot;https://myhostname.com:9001&quot;</span>,</span><br><span class="line">    method=<span class="string">&quot;GET&quot;</span>,</span><br><span class="line">    validate_cert=<span class="literal">False</span></span><br><span class="line">)</span><br><span class="line"><span class="built_in">print</span> tornado.httpclient.HTTPClient().fetch(request)</span><br></pre></td></tr></table></figure>

<h3 id="Review"><a href="#Review" class="headerlink" title="-Review"></a>-Review</h3><p><code>curl http_address -k</code></p>
<p>可以跳过ssl验证</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I<span class="string">&#x27;m trying to use tornado&#x27;</span>s http client to fetch a URL. I<span class="string">&#x27;ve done this before many times, but I&#x27;</span>m getting a really odd SSL error this time. The endpoint I<span class="string">&#x27;m trying to consume does not have a valid cert, but a -k on a curl call still proves it works.</span></span><br></pre></td></tr></table></figure>

<h2 id="Q20-Docker-Compose"><a href="#Q20-Docker-Compose" class="headerlink" title="Q20 Docker Compose"></a>Q20 Docker Compose</h2><h3 id="Info-1"><a href="#Info-1" class="headerlink" title="-Info"></a>-Info</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 拉取镜像报错</span></span><br><span class="line">docker-compose up</span><br></pre></td></tr></table></figure>

<h3 id="Analysis-1"><a href="#Analysis-1" class="headerlink" title="-Analysis"></a>-Analysis</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 报错信息</span></span><br><span class="line">ERROR: write /var/lib/docker/tmp/GetImageBlob264931462: no space left on device</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 指宿主机内部没有空间写入docker文件</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看内存使用</span></span><br><span class="line">df -h</span><br></pre></td></tr></table></figure>

<h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="-Solution"></a>-Solution</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 清除宿主机内不在使用的imgaes</span></span><br><span class="line">docker rmi $ (docker images -aq)</span><br></pre></td></tr></table></figure>

<h2 id="Q19GIt-PUll失败"><a href="#Q19GIt-PUll失败" class="headerlink" title="Q19GIt PUll失败"></a>Q19GIt PUll失败</h2><h3 id="Info-2"><a href="#Info-2" class="headerlink" title="-Info"></a>-Info</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(venv) edy@bogon TXM % git pull</span><br><span class="line"></span><br><span class="line">Your configuration specifies to merge <span class="keyword">with</span> the ref <span class="string">&#x27;refs/heads/watsons_uat&#x27;</span></span><br><span class="line"><span class="keyword">from</span> the remote, but no such ref was fetched.</span><br></pre></td></tr></table></figure>

<h3 id="Analysis-2"><a href="#Analysis-2" class="headerlink" title="-Analysis"></a>-Analysis</h3><ol>
<li>远程仓库不存在要pull的分支</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">本地仓库当前分支是a，但是a的远程分支被删除掉了，pull的时候就会报错，这时候使用</span><br><span class="line">git remote prune origin</span><br><span class="line">同步下远程分支，并清除掉已删除的分支，再清除掉当前分支（如果当前分支在工作区的话）就可以了</span><br><span class="line"></span><br><span class="line">建议：使用命令行拉取新分支代码前使用：git fetch -p 获取最新分支 然后获取远程分支代码</span><br><span class="line">git fetch -p</span><br></pre></td></tr></table></figure>

<h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="-Solution"></a>-Solution</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 切换到其他分支, 建议master分支</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 同步远程分支, 并清楚已经删除的分支</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 清除被删除的分支</span></span><br><span class="line">git remote prune origin  </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在获取之前，删除远程上不再存在的任何远程跟踪引用</span></span><br><span class="line">git fetch -p  </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 切换到出现问题的分支</span></span><br><span class="line">git checkout target_branch</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 关联分支</span></span><br><span class="line">git branch --set-upstream-to=origin/master &lt;target_branch&gt;</span><br><span class="line"></span><br><span class="line">git push --set-upstream origin &lt;local_branch&gt;</span><br></pre></td></tr></table></figure>

<h2 id="Q18mogodb更新失败"><a href="#Q18mogodb更新失败" class="headerlink" title="Q18mogodb更新失败"></a>Q18mogodb更新失败</h2><h3 id="Info-3"><a href="#Info-3" class="headerlink" title="-Info"></a>-Info</h3><p>在更新ipdate_one()时出现update error</p>
<h3 id="Analysis-3"><a href="#Analysis-3" class="headerlink" title="-Analysis"></a>-Analysis</h3><p>查看所使用的是否是原生语法, 如果使用http连接更新, 则尝试使用原生语句进行更新</p>
<h2 id="Q17linux连接目标主机报错-ssh"><a href="#Q17linux连接目标主机报错-ssh" class="headerlink" title="Q17linux连接目标主机报错[ssh]"></a>Q17linux连接目标主机报错[ssh]</h2><h3 id="Info-4"><a href="#Info-4" class="headerlink" title="-Info"></a>-Info</h3><p><strong>问题一</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通过linux主机，远程其他linux服务器时报错：Unable to negotiate with xx.xxx.xxx.x port 22:no matching cipher found. Their offer: aes128-cbc,aes256-cbc,3des-cbc,des-cbc</span><br></pre></td></tr></table></figure>

<p><strong>问题二</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">远程其他linux服务器时又报错：Unable to negotiate with xx.xx.xx.xx port 22: no matching key exchange method.found.Their.offer:diffie-hellman-group-exchange-sha1,diffie-hellman-group1-sha1</span><br></pre></td></tr></table></figure>

<h3 id="Analysis-4"><a href="#Analysis-4" class="headerlink" title="-Analysis"></a>-Analysis</h3><p><strong>问题一</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">由于发起远程访问端的主机openssh版本过高（我的这台主机为最新8.1版本），导致不支持对低版本的远程连接主机的ssh解密，故报错。</span><br></pre></td></tr></table></figure>

<p><strong>问题二</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">根据提示，ssh不能远程登录的原因为：没有找到相关的主机密钥类型。</span><br></pre></td></tr></table></figure>

<h3 id="Soultion"><a href="#Soultion" class="headerlink" title="-Soultion"></a>-Soultion</h3><p><strong>问题一</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 修改发起远程访问的本机SSH客户端配置（/etc/ssh/ssh_config）文件，将默认注释的：</span></span><br><span class="line">Ciphers aes128-ctr,aes192-ctr,aes256-ctr,aes128-cbc,3des-cbc</span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用即可。</span></span><br></pre></td></tr></table></figure>

<p><strong>问题二</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 修改发起远程访问的本机SSH客户端配置（/etc/ssh/ssh_config）文件，在最后加上一行：</span></span><br><span class="line">KexAlgorithms +diffie-hellman-group1-sha1</span><br></pre></td></tr></table></figure>

<h2 id="Q16Docker连接redis失败"><a href="#Q16Docker连接redis失败" class="headerlink" title="Q16Docker连接redis失败"></a>Q16Docker连接redis失败</h2><h3 id="Info-5"><a href="#Info-5" class="headerlink" title="-Info"></a>-Info</h3><p>在docker-container中发现container重启</p>
<p><code>docker logs -f --tail 100 container_id&lt;container name&gt;</code></p>
<p>发现是连接redis报错</p>
<h3 id="Analysis-5"><a href="#Analysis-5" class="headerlink" title="-Analysis"></a>-Analysis</h3><p>分析发现是docker连接不到redis</p>
<h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="-Solution"></a>-Solution</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看docker状态</span></span><br><span class="line">services docker status</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启docker</span></span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>



<h2 id="Q15Docker运行脚本"><a href="#Q15Docker运行脚本" class="headerlink" title="Q15Docker运行脚本"></a>Q15Docker运行脚本</h2><h3 id="Info-6"><a href="#Info-6" class="headerlink" title="-Info"></a>-Info</h3><p>在需要跑数据时, 可以 [根据场景选择] :</p>
<ol>
<li>写script</li>
<li>写临时API</li>
</ol>
<h3 id="Solution-4"><a href="#Solution-4" class="headerlink" title="-Solution"></a>-Solution</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> config.config <span class="keyword">import</span> Table</span><br><span class="line"><span class="keyword">from</span> model.base_model <span class="keyword">import</span> BaseModel</span><br><span class="line"></span><br><span class="line">phone = [<span class="string">&#x27;16620132242&#x27;</span>, <span class="string">&#x27;16676748179&#x27;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">export_excel</span>():</span></span><br><span class="line">    friend_count = []</span><br><span class="line">    <span class="keyword">for</span> sim <span class="keyword">in</span> phone:</span><br><span class="line">        print(<span class="string">f&#x27;---------sim:<span class="subst">&#123;sim&#125;</span>&#x27;</span>)</span><br><span class="line">        bot_username = <span class="keyword">await</span> BaseModel.fetch_one(</span><br><span class="line">            Table.BotInfo,</span><br><span class="line">            <span class="string">&quot;*&quot;</span>,</span><br><span class="line">            BaseModel.where_dict(&#123;<span class="string">&quot;sim&quot;</span>: sim&#125;)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> bot_username:</span><br><span class="line">            friend_count.append(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        friend_count_info = <span class="keyword">await</span> BaseModel.count_(</span><br><span class="line">            Table.Friend,</span><br><span class="line">            BaseModel.where_dict(&#123;<span class="string">&quot;bot_username&quot;</span>: bot_username.username, <span class="string">&quot;is_friend&quot;</span>: <span class="number">1</span>&#125;)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        friend_count.append(friend_count_info)</span><br><span class="line">    <span class="keyword">return</span> friend_count</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    task = asyncio.Task(export_excel())</span><br><span class="line">    done, pending = <span class="keyword">await</span> asyncio.wait(&#123;task&#125;)</span><br><span class="line">    <span class="keyword">if</span> task <span class="keyword">in</span> done:</span><br><span class="line">        print(task)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">  	<span class="comment"># 需要初始化BaseModel的model_dict()</span></span><br><span class="line">    BaseModel.init_model_dict()</span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    loop.run_until_complete(main())</span><br><span class="line">    loop.close()</span><br></pre></td></tr></table></figure>

<h3 id="Review-1"><a href="#Review-1" class="headerlink" title="-Review"></a>-Review</h3><p>使用到的命令:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># copy file from linux-server to another linux-server</span></span><br><span class="line">scp source_file root@remote_ip:/target_directory/</span><br><span class="line"></span><br><span class="line"><span class="comment"># create file</span></span><br><span class="line">vim target_file.py</span><br><span class="line"></span><br><span class="line"><span class="comment"># copy file from linux-server to linux-server-container</span></span><br><span class="line">docker cp source_file container_id[name]:/target_directory/</span><br></pre></td></tr></table></figure>

<p>需要注意的:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 需要初始化BaseModel的model_dict()</span></span><br><span class="line">BaseModel.init_model_dict()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导出excel</span></span><br><span class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> Workbook</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">people_count_list = [<span class="number">4190</span>, <span class="number">1415</span>]</span><br><span class="line">book = Workbook()</span><br><span class="line">sheet = book.active</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> index, value <span class="keyword">in</span> <span class="built_in">enumerate</span>(people_count_list):</span><br><span class="line">    sheet[<span class="string">f&quot;A<span class="subst">&#123;index+<span class="number">1</span>&#125;</span>&quot;</span>] = value</span><br><span class="line">    print(value)</span><br><span class="line"></span><br><span class="line">book.save(<span class="string">&quot;/Users/edy/Desktop/sample.xlsx&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="Q14导出大数据Excel"><a href="#Q14导出大数据Excel" class="headerlink" title="Q14导出大数据Excel"></a>Q14导出大数据Excel</h2><h3 id="Info-7"><a href="#Info-7" class="headerlink" title="-Info"></a>-Info</h3><p>在导出群-机器人数据时, 涉及到群数据量很大导出excel失败</p>
<h3 id="Solution-5"><a href="#Solution-5" class="headerlink" title="-Solution"></a>-Solution</h3><p>使用page pagesize进行分页导出</p>
<h2 id="Q13字典获取key"><a href="#Q13字典获取key" class="headerlink" title="Q13字典获取key"></a>Q13字典获取key</h2><p>获取dict中key所对应的vaule, 使用. get [“key”]有什么区别?</p>
<h2 id="Q12unhashed-type-dict"><a href="#Q12unhashed-type-dict" class="headerlink" title="Q12unhashed type dict"></a>Q12unhashed type dict</h2><h3 id="Info-8"><a href="#Info-8" class="headerlink" title="-Info"></a>-Info</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERROR: unhashed <span class="built_in">type</span> <span class="built_in">dict</span></span><br></pre></td></tr></table></figure>

<h3 id="Analysis-6"><a href="#Analysis-6" class="headerlink" title="-Analysis"></a>-Analysis</h3><p>字典不能存储在集合</p>
<h2 id="Q11生成器对象不可下标"><a href="#Q11生成器对象不可下标" class="headerlink" title="Q11生成器对象不可下标"></a>Q11生成器对象不可下标</h2><h3 id="Infolocal"><a href="#Infolocal" class="headerlink" title="-Infolocal"></a>-Infolocal</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TypeError: ‘generator’ <span class="built_in">object</span> <span class="keyword">is</span> <span class="keyword">not</span> subscriptable </span><br></pre></td></tr></table></figure>

<h3 id="Analysis-7"><a href="#Analysis-7" class="headerlink" title="-Analysis"></a>-Analysis</h3><p>通常是list.append(generator)</p>
<h3 id="Solution-6"><a href="#Solution-6" class="headerlink" title="-Solution"></a>-Solution</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a = []</span><br><span class="line">b = []</span><br><span class="line">a.append([<span class="keyword">for</span> item <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">5</span>)])</span><br><span class="line">b.extend(<span class="keyword">for</span> item <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">5</span>))</span><br><span class="line"></span><br><span class="line">[[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列表生成器</span></span><br><span class="line">[<span class="keyword">for</span> item <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">5</span>)]</span><br></pre></td></tr></table></figure>

<h2 id="Q10导入包含同名文件冲突"><a href="#Q10导入包含同名文件冲突" class="headerlink" title="Q10导入包含同名文件冲突"></a>Q10导入包含同名文件冲突</h2><h3 id="Info-9"><a href="#Info-9" class="headerlink" title="-Info"></a>-Info</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import resolves to its containing file</span><br><span class="line"></span><br><span class="line">file&gt; component</span><br><span class="line">import time</span><br></pre></td></tr></table></figure>

<h3 id="Analysis-8"><a href="#Analysis-8" class="headerlink" title="-Analysis"></a>-Analysis</h3><p>在<code>component</code>目录下有<code>time</code>文件,且import 了 time(python) 与python自带的第三方time库冲突</p>
<h3 id="Solution-7"><a href="#Solution-7" class="headerlink" title="-Solution"></a>-Solution</h3><h2 id="Q9Mongodb保存-插入字段失败"><a href="#Q9Mongodb保存-插入字段失败" class="headerlink" title="Q9Mongodb保存|插入字段失败"></a>Q9Mongodb保存|插入字段失败</h2><ul>
<li><input disabled="" type="checkbox"> 1.查看Table定义==&gt;fiedls = fiedls.<strong>IntFields()</strong>   ==&gt;需要加()</li>
</ul>
<h2 id="Q8虚拟环境配置"><a href="#Q8虚拟环境配置" class="headerlink" title="Q8虚拟环境配置"></a>Q8虚拟环境配置</h2><ul>
<li><input disabled="" type="checkbox"> 拉取项目后如何配置虚拟环境?</li>
<li><input disabled="" type="checkbox"> 如何激活虚拟环境, 并每次进入pycharm的terminal都保证是venv?</li>
</ul>
<ol>
<li>venv的目录和interpreter的目录要配置相同</li>
</ol>
<p>![image-20211018164551110](/Users/edy/Library/Application Support/typora-user-images/image-20211018164551110.png)</p>
<p>![image-20211018164714977](/Users/edy/Library/Application Support/typora-user-images/image-20211018164714977.png)</p>
<ol start="2">
<li>terminal的配置如下</li>
</ol>
<p>![image-20211018164922890](/Users/edy/Library/Application Support/typora-user-images/image-20211018164922890.png)</p>
<h2 id="Q7Nginx-Timeout-504"><a href="#Q7Nginx-Timeout-504" class="headerlink" title="Q7Nginx Timeout 504"></a>Q7Nginx Timeout 504</h2><h3 id="Info-10"><a href="#Info-10" class="headerlink" title="-Info"></a>-Info</h3><p>在前端导出excel时, 导出失败并返回<code>GateWay TimeOut 504</code></p>
<h3 id="Analysis-9"><a href="#Analysis-9" class="headerlink" title="-Analysis"></a>-Analysis</h3><ul>
<li>重新导出查看log</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">url: /channel/get_excel?token=ab5c40fa9da40d74f5a2ba17d84dcf63</span><br><span class="line">GET /channel/get_excel?token=ab5c40fa9da40d74f5a2ba17d84dcf63 (183.81.181.194) 67000.83ms</span><br></pre></td></tr></table></figure>

<ul>
<li>说明导出正常, 其中导出时间大于<code>60s</code></li>
<li>nginx做反向代理，默认请求是有一个60秒的超时，如果http请求超过了60秒，再返回，连接就会被nginx中断，前端就会得到504的错误：gateway time-out。</li>
</ul>
<h3 id="Solution-8"><a href="#Solution-8" class="headerlink" title="-Solution"></a>-Solution</h3><blockquote>
<p>修改nginx的配置, 将超时设置延长至300s</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">docker ps </span><br><span class="line"></span><br><span class="line">docker exec -it nginx_container_id bash</span><br><span class="line"></span><br><span class="line">whereis nginx.conf</span><br><span class="line"></span><br><span class="line">cd /etc/config</span><br><span class="line"></span><br><span class="line">vim nginx.conf</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    keepalive_timeout 300;</span><br><span class="line">    proxy_connect_timeout 300;</span><br><span class="line">    proxy_send_timeout 300;</span><br><span class="line">    proxy_read_timeout 300;</span><br><span class="line">    send_timeout 300;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用挂载修复</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 进入服务器</span></span><br><span class="line">ssh root@xxx</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 编辑volumne</span></span><br><span class="line">vim docker-compose.yaml</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加挂载</span></span><br><span class="line"> nginx-proxy:</span><br><span class="line">    image: registry.cn-beijing.aliyuncs.com/doododmain/nginx-proxy:20mbody</span><br><span class="line">    container_name: nginx-proxy</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;80:80&quot;</span><br><span class="line">      - &quot;443:443&quot;</span><br><span class="line">    volumes:</span><br><span class="line">      - /certs:/etc/nginx/certs</span><br><span class="line">      - /var/run/docker.sock:/tmp/docker.sock:ro</span><br><span class="line">      - /root/nginx/nginx.conf:/etx/nginx/nginx.conf</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在外部创建对应的挂载文件[宿主机]</span></span><br><span class="line">vim /root/nginx/nginx.conf</span><br><span class="line"></span><br><span class="line">user  nginx;</span><br><span class="line">worker_processes  auto;</span><br><span class="line"></span><br><span class="line">error_log  /var/log/nginx/error.log warn;</span><br><span class="line">pid        /var/run/nginx.pid;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       /etc/nginx/mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span><br><span class="line">                      &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span><br><span class="line">                      &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span><br><span class="line"></span><br><span class="line">    access_log  /var/log/nginx/access.log  main;</span><br><span class="line"></span><br><span class="line">    sendfile        on;</span><br><span class="line">    #tcp_nopush     on;</span><br><span class="line"></span><br><span class="line">    keepalive_timeout 300;</span><br><span class="line"></span><br><span class="line">    proxy_connect_timeout 300;</span><br><span class="line"></span><br><span class="line">    proxy_send_timeout 300;</span><br><span class="line"></span><br><span class="line">    proxy_read_timeout 300;</span><br><span class="line"></span><br><span class="line">    send_timeout 300;</span><br><span class="line"></span><br><span class="line">    #gzip  on;</span><br><span class="line"></span><br><span class="line">    include /etc/nginx/conf.d/*.conf;</span><br><span class="line">&#125;</span><br><span class="line">daemon off;</span><br></pre></td></tr></table></figure>

<h3 id="Review-2"><a href="#Review-2" class="headerlink" title="-Review"></a>-Review</h3><ul>
<li>如果程序正常, log也没有报错, 很可能是配置的原因</li>
</ul>
<h2 id="Q6mongodb插入数据报错"><a href="#Q6mongodb插入数据报错" class="headerlink" title="Q6mongodb插入数据报错"></a>Q6mongodb插入数据报错</h2><h3 id="Info-11"><a href="#Info-11" class="headerlink" title="-Info"></a>-Info</h3><p>在mongodb中插入数据报错<code>&#123;&#39;code&#39;: -1, &#39;msg&#39;: &#39;exception&#39;&#125;</code></p>
<h3 id="Analysis-10"><a href="#Analysis-10" class="headerlink" title="-Analysis"></a>-Analysis</h3><p>经过排查不是以下原因:</p>
<ul>
<li>插入字段类型与定义不符</li>
<li>缺少必要字段</li>
</ul>
<h3 id="Solution-9"><a href="#Solution-9" class="headerlink" title="-Solution"></a>-Solution</h3><p>在mongodb表中定义字段如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 群发任务</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AssistantBatchSend</span>(<span class="params">BaseModel</span>):</span></span><br><span class="line">    __table__ = <span class="string">&#x27;assistant_batch_send&#x27;</span></span><br><span class="line">    client_id = fields.IntField()     <span class="comment"># 创建人</span></span><br><span class="line">    task_id = fields.IntField()       <span class="comment"># 任务标识</span></span><br><span class="line">    message_list = fields.JsonField()  <span class="comment"># 发送内容</span></span><br><span class="line">    bot_username_list = fields.JsonField()  <span class="comment"># 机器人id</span></span><br></pre></td></tr></table></figure>

<p>在插入的数据中</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">task_identification = <span class="built_in">int</span>(<span class="built_in">str</span>(self.user_info.client_id) + <span class="built_in">str</span>(<span class="built_in">int</span>(time.time()*<span class="number">1000000</span>))) <span class="comment"># 任务标识</span></span><br><span class="line">immediate_info = CM(Table.AssistantBatchSend)</span><br><span class="line">immediate_info.task_id = task_identification</span><br></pre></td></tr></table></figure>

<p>其中task_id定义为<code>intfiled</code>长度最大</p>
<p>为:</p>
<p>![image-20211011134300296](/Users/edy/Library/Application Support/typora-user-images/image-20211011134300296.png)</p>
<p>但是传入的长度为<code>22</code>, 应该把此字段定义为<code>StringField</code></p>
<h2 id="Q5SSH连接VCM断开"><a href="#Q5SSH连接VCM断开" class="headerlink" title="Q5SSH连接VCM断开"></a>Q5SSH连接VCM断开</h2><h3 id="Question"><a href="#Question" class="headerlink" title="-Question"></a>-Question</h3><p><strong>报错信息</strong></p>
<p><strong>info1</strong></p>
<p>client_loop: send disconnect: Broken pipe</p>
<p><strong>info2</strong></p>
<p>yum-config-manager client_loop: send disconnect: Broken pipe</p>
<h3 id="Analysis-11"><a href="#Analysis-11" class="headerlink" title="-Analysis"></a>-Analysis</h3><p><strong>info1</strong></p>
<p>终端连接服务器无响应且没用自动间隔连接配置<strong>VCM的问题</strong></p>
<h3 id="Solution-10"><a href="#Solution-10" class="headerlink" title="-Solution"></a>-Solution</h3><p><strong>info1</strong></p>
<p>修改<code>/etc/ssh/sshd_config</code>文件, 修改<code>ClientAliveInterval 120</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过每 300 秒（每 5 分钟）进行响应确认来保持连接。 我认为这个部分的数字可以是60或120。</span></span><br><span class="line">&gt;/etc/ssh/sshd_config</span><br><span class="line"><span class="comment">#PermitUserEnvironment no</span></span><br><span class="line"><span class="comment">#Compression delayed</span></span><br><span class="line">ClientAliveInterval 60</span><br><span class="line"><span class="comment">#ClientAliveCountMax 3</span></span><br></pre></td></tr></table></figure>

<p>重新启动ssh服务</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart sshd</span><br></pre></td></tr></table></figure>

<p>或者在客户端进行更改<code>/etc/ssh/ssh_config</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 添加参数</span></span><br><span class="line">TCPKeepAlive yes</span><br><span class="line">ServerAliveInterval 60</span><br></pre></td></tr></table></figure>

<p><strong>info2</strong></p>
<p>配置<code>/etc/ssh/ssh_config</code>文件，增加以下内容即可：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Host *</span><br><span class="line">				IPQoS=throughput</span><br><span class="line">        <span class="comment"># 断开时重试连接的次数</span></span><br><span class="line">        ServerAliveCountMax 5</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 每隔5秒自动发送一个空的请求以保持连接</span></span><br><span class="line">        ServerAliveInterval 5</span><br></pre></td></tr></table></figure>

<p>重新启动ssh服务</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart sshd</span><br></pre></td></tr></table></figure>

<h3 id="Review-3"><a href="#Review-3" class="headerlink" title="-Review"></a>-Review</h3><p><strong>1.在服务端进行修改</strong></p>
<p>在服务器端， 可以让服务器发送“心跳”信号测试提醒客户端进行保持连接</p>
<p>通过修改 sshd 的配置文件，能够让 SSH Server 发送“心跳”信号来维持持续连接，下面是设置的内容</p>
<p>打开服务器 <code>/etc/ssh/sshd_config</code>，我在最后增加一行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ClientAliveInterval 60</span><br><span class="line">ClientAliveCountMax 1</span><br></pre></td></tr></table></figure>

<p>这样，SSH Server 每 60 秒就会自动发送一个信号给 Client，而等待 Client 回应，（注意：是服务器发心跳信号，不是客户端，这个有别于一些 FTP Client 发送的 KeepAlives 信号），如果客户端没有回应，会记录下来直到记录数超过 ClientAliveCountMax 的值时，才会断开连接。</p>
<p><strong>2.在客户端进行修改</strong></p>
<p>只要在/etc/ssh/ssh_config文件里加两个参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TCPKeepAlive yes</span><br><span class="line">ServerAliveInterval 60</span><br></pre></td></tr></table></figure>

<p>前一个参数是说要保持连接，后一个参数表示每过1分钟发一个数据包到服务器表示“我还活着”</p>
<p>如果你没有root权限，修改或者创建~/.ssh/ssh_config也是可以的</p>
<h2 id="Q4vim安装失败"><a href="#Q4vim安装失败" class="headerlink" title="Q4vim安装失败"></a>Q4vim安装失败</h2><h3 id="Question-1"><a href="#Question-1" class="headerlink" title="-Question"></a>-Question</h3><ol>
<li>在使用<code>vim</code>时发现报错<code>bash: vim: command not found</code></li>
</ol>
<h3 id="Analysis-12"><a href="#Analysis-12" class="headerlink" title="-Analysis"></a>-Analysis</h3><p>使用<code>cat /proc/version</code>查看系统版本</p>
<p>![image-20210928202753365](/Users/edy/Library/Application Support/typora-user-images/image-20210928202753365.png)</p>
<p>查看系统镜像中是否有<code>vim</code>, 发现<code>red hat 5</code>才有<code>vim</code></p>
<h3 id="Solution-11"><a href="#Solution-11" class="headerlink" title="-Solution"></a>-Solution</h3><ul>
<li>使用<code>apt install vim </code>安装<code>vim</code></li>
<li>发现<code>Unable to locate package vim</code></li>
</ul>
<p>![image-20210928203059115](/Users/edy/Library/Application Support/typora-user-images/image-20210928203059115.png)</p>
<ul>
<li>需要输入：<code>apt-get update</code>（作用是：同步 /etc/apt/sources.list 和 /etc/apt/sources.list.d 中列出的源的索引，这样才能获取到最新的软件包）</li>
<li>之后再输入<code>apt-get install vim</code>安装（非root用户登录，<code>root apt-get intall vim</code>）</li>
</ul>
<h3 id="Review-4"><a href="#Review-4" class="headerlink" title="-Review"></a>-Review</h3><p><strong>docker常用命令</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 修改了image内的文件后重启image</span></span><br><span class="line">docker restart image_id</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动container中的所有image</span></span><br><span class="line">docker start $(docker ps -a | awk &#x27;&#123; print $1&#125;&#x27; | tail -n +2)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 停止container中的所有image</span></span><br><span class="line">docker stop $(docker ps -a | awk &#x27;&#123; print $1&#125;&#x27; | tail -n +2)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除container中的所有image</span></span><br><span class="line">docker rm $(docker ps -a | awk &#x27;&#123; print $1&#125;&#x27; | tail -n +2)</span><br></pre></td></tr></table></figure>

<h2 id="Q3镜像部署失败"><a href="#Q3镜像部署失败" class="headerlink" title="Q3镜像部署失败"></a>Q3镜像部署失败</h2><h3 id="Question-2"><a href="#Question-2" class="headerlink" title="-Question"></a>-Question</h3><ol>
<li>部署对应的tag的时候出现<code>error</code></li>
</ol>
<p>![image-20210928155639667](/Users/edy/Library/Application Support/typora-user-images/image-20210928155639667.png)</p>
<ol start="2">
<li>有正在运行的container, 无法部署</li>
</ol>
<h3 id="Analysis-13"><a href="#Analysis-13" class="headerlink" title="-Analysis"></a>-Analysis</h3><ul>
<li>在部署的过程中存在正在运行的container</li>
<li>需要将所有的正在运行的container停下来或者删除所有正在运行的container中的image</li>
</ul>
<h3 id="Solution-12"><a href="#Solution-12" class="headerlink" title="-Solution"></a>-Solution</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动所有image</span></span><br><span class="line">docker start $(docker ps -a | awk <span class="string">&#x27;&#123; print $1&#125;&#x27;</span> | tail -n +2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止运行所有image</span></span><br><span class="line">docker stop $(docker ps -a | awk <span class="string">&#x27;&#123; print $1&#125;&#x27;</span> | tail -n +2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除container中的所有image</span></span><br><span class="line">docker rm $(docker ps -a | awk <span class="string">&#x27;&#123; print $1&#125;&#x27;</span> | tail -n +2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新部署</span></span><br><span class="line">sh deploy-debug.sh 1.0.0.65</span><br></pre></td></tr></table></figure>

<h3 id="Review-5"><a href="#Review-5" class="headerlink" title="-Review"></a>-Review</h3><ul>
<li>使用<code>docker ps -a</code>container中的所有image包括正在运行和未运行的</li>
<li><code>docker rmi -f &#39;docker iamges&#39; </code>删除的已经存在但未运行的image</li>
<li><code>docker rm image_id</code>删除正在运行的image</li>
</ul>
<h2 id="Q2镜像重启"><a href="#Q2镜像重启" class="headerlink" title="Q2镜像重启"></a>Q2镜像重启</h2><h3 id="Question-3"><a href="#Question-3" class="headerlink" title="-Question"></a>-Question</h3><ol>
<li>Docker ps 查看镜像状态显示<code>restart</code></li>
</ol>
<p>![image-20210928095953991](/Users/edy/Library/Application Support/typora-user-images/image-20210928095953991.png)</p>
<ol start="2">
<li>RabbitMQ只有生产者没有消费者</li>
</ol>
<h3 id="Analysis-14"><a href="#Analysis-14" class="headerlink" title="-Analysis"></a>-Analysis</h3><ol>
<li>部分服务器没起来</li>
</ol>
<h3 id="Solution-13"><a href="#Solution-13" class="headerlink" title="-Solution"></a>-Solution</h3><ol>
<li><code>docker logs -f image_name </code>查看对应的image日志</li>
<li>找到报错信息</li>
</ol>
<p>![image-20210928095931103](/Users/edy/Library/Application Support/typora-user-images/image-20210928095931103.png)</p>
<p><code>cerely can&#39;t find module name &#39;component.task.member_change_task.component&#39;</code></p>
<p><strong>cerely配置错误</strong></p>
<h3 id="Review-6"><a href="#Review-6" class="headerlink" title="-Review"></a>-Review</h3><ul>
<li>docker logs -f </li>
<li>command r 搜索已经使用的order</li>
</ul>
<h2 id="Q1磁盘溢出"><a href="#Q1磁盘溢出" class="headerlink" title="Q1磁盘溢出"></a>Q1磁盘溢出</h2><h3 id="Question-4"><a href="#Question-4" class="headerlink" title="-Question"></a>-<strong>Question</strong></h3><ol>
<li>mongodb连接失败报错<ul>
<li><code>failed to read 4 bytes from socket within 300000 milliseconds</code></li>
</ul>
</li>
<li>紫豆超管后台登陆失败<ul>
<li><code>login 无响应</code></li>
</ul>
</li>
<li>机器人正常但不可用<ul>
<li><code>机器人上报heartbeat给服务器但服务器不callback</code></li>
</ul>
</li>
</ol>
<h3 id="Analysis-15"><a href="#Analysis-15" class="headerlink" title="-Analysis"></a>-Analysis</h3><ol>
<li>登陆紫豆服务器<code>ssh root@ip</code><ul>
<li>报错显示disk overflower</li>
</ul>
</li>
<li><code>df -h</code>查看disk存储情况</li>
</ol>
<p><img src="file:///Users/edy/Library/Application%20Support/typora-user-images/image-20210926170428181.png?lastModify=1632625187" alt="image-20210926170428181"></p>
<h3 id="Solution-14"><a href="#Solution-14" class="headerlink" title="-Solution"></a><strong>-Solution</strong></h3><ol>
<li><p>删除不用的container|容器修剪</p>
<ul>
<li>PRO环境具有一定的风险</li>
<li><code>docker system prune</code>  <code>docker container prune</code></li>
</ul>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker container prune</span><br><span class="line">WARNING! This will remove all stopped containers.</span><br><span class="line">Are you sure you want to continue? [y/N] y</span><br><span class="line">Deleted Containers:</span><br><span class="line"><span class="number">4</span>a7f7eebae0f63178aff7eb0aa39cd3f0627a203ab2df258c1a00b456cf20063</span><br><span class="line">f98f9c2aa1eaf727e4ec9c0283bc7d4aa4762fbdba7f26191f26c97f64090360</span><br><span class="line"></span><br><span class="line">Total reclaimed space: <span class="number">212</span> B</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>删除镜像[优先选择]</strong></p>
<ul>
<li><pre><code class="bahs">docker rmi -f `docker images`
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   - docker image需&#96;</span><br><span class="line"></span><br><span class="line">   - **删除已经存在的镜像「不包括正在运行的」**</span><br><span class="line"></span><br><span class="line">### -Review</span><br><span class="line"></span><br><span class="line">**docker rmi :** 删除本地一个或多个镜像。</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;docker</span><br><span class="line">docker rmi [OPTIONS] IMAGE [IMAGE...]</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ol>
<p><strong>OPTIONS说明：</strong></p>
<ul>
<li>**-f :**强制删除；</li>
<li>**–no-prune :**不移除该镜像的过程镜像，默认移除；</li>
</ul>
<hr>
<p><strong>docker prune 命令</strong></p>
<p>prune 命令用来删除不再使用的 docker 对象。</p>
<p>删除所有未被 tag 标记和未被容器使用的镜像:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker image prune</span><br><span class="line">WARNING! This will remove all dangling images.</span><br><span class="line">Are you sure you want to <span class="built_in">continue</span>? [y/N] y</span><br></pre></td></tr></table></figure>

<p>删除所有未被容器使用的镜像:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image prune -a</span><br></pre></td></tr></table></figure>

<p>删除所有停止运行的容器:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container prune</span><br></pre></td></tr></table></figure>

<p>删除所有未被挂载的卷:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker volume prune</span><br></pre></td></tr></table></figure>

<p>删除所有网络:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker network prune</span><br></pre></td></tr></table></figure>

<p>删除 docker 所有资源:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker system prune</span><br></pre></td></tr></table></figure>

<p><strong>docker system prune</strong> 命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">This will remove:</span><br><span class="line">        - all stopped containers</span><br><span class="line">        - all networks not used by at least one container</span><br><span class="line">        - all dangling images</span><br><span class="line">        - all dangling build cache</span><br></pre></td></tr></table></figure>

<p>删除停止的容器、删除所有未被容器使用的网络、删除所有none的镜像。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://drinkle.top/2021/10/07/Question/" data-id="ckugvc4kn0000wwf5bh7l07c6" data-title="Question" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Drink/" rel="tag">Drink</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-My-Project" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/10/07/My-Project/" class="article-date">
  <time class="dt-published" datetime="2021-10-07T11:34:45.000Z" itemprop="datePublished">2021-10-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/10/07/My-Project/">My-Project</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><h3 id="详细对比"><a href="#详细对比" class="headerlink" title="详细对比"></a>详细对比</h3><img src="https://pic1.zhimg.com/v2-8dd72a44b6c9936bcf5e03ea21028eb3_r.jpg?source=1940ef5c" alt="preview" style="zoom:200%;" />

<h3 id="轻量应用服务器"><a href="#轻量应用服务器" class="headerlink" title="轻量应用服务器"></a>轻量应用服务器</h3><p><strong>单机类应用</strong></p>
<ul>
<li>个人网站</li>
<li>博客</li>
<li>云端测试等轻量级应用<ul>
<li>技术小白</li>
<li>不想搭建云服务器环境</li>
<li>没有云平台内网需求</li>
<li>本身自带运行环境</li>
</ul>
</li>
<li>特点<ul>
<li>轻运维、开箱即用</li>
</ul>
</li>
</ul>
<h3 id="云服务器CVM"><a href="#云服务器CVM" class="headerlink" title="云服务器CVM"></a>云服务器CVM</h3><p><strong>专业级应用</strong></p>
<ul>
<li>集群</li>
<li>高可用应用</li>
<li>特点<ul>
<li>高并发网站</li>
<li>视频编解码</li>
<li>大型游戏</li>
<li>复杂分布式集群应用</li>
</ul>
</li>
</ul>
<h2 id="终端连接CVM"><a href="#终端连接CVM" class="headerlink" title="终端连接CVM"></a>终端连接CVM</h2><ol>
<li><strong>CVM生成hash密钥</strong></li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在云服务器配置中生成密钥rsa</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 需要注意生成的后只能绑定已经关机的实例</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>修改rsa证书权限</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将在CVM生成的pem证书文件移动到指定目录下</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在次目录下运行</span></span><br><span class="line">chomd 400 &lt;target_rsa.pem&gt;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>item远程链接服务器</strong></li>
</ol>
<p><strong>配置信息如下</strong></p>
<table>
<thead>
<tr>
<th>Profiles</th>
<th>-</th>
<th>order</th>
</tr>
</thead>
<tbody><tr>
<td>name</td>
<td>-</td>
<td></td>
</tr>
<tr>
<td>title</td>
<td>job</td>
<td></td>
</tr>
<tr>
<td>command</td>
<td>command</td>
<td><strong>ssh -i order</strong></td>
</tr>
<tr>
<td>working directory</td>
<td>home directory</td>
<td></td>
</tr>
</tbody></table>
<ul>
<li>ssh order<code>ssh [-i login_name] [-p port] [user@]hostname</code></li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -i ~/.ssh/drink_rsa.pem root@110.40.240.39</span><br></pre></td></tr></table></figure>

<ul>
<li>ssh -i :ssh命令, 指定用户登录<ul>
<li> [-i identity_file]</li>
<li> &lt;必须指定&gt;</li>
</ul>
</li>
<li>~/.ssh/drink_rsa.pem : cvm生成的rsa证书</li>
<li>root : cvm主机用户</li>
<li>110.40.240.39 : cvm公网ip地址</li>
</ul>
<h3 id="ssh操作"><a href="#ssh操作" class="headerlink" title="ssh操作"></a>ssh操作</h3><p> ssh命令用于远程登陆上Linux主机</p>
<p>ssh默认port: 22</p>
<p>不指定用户：服务器</p>
<blockquote>
<p>ssh 192.168.0.11网络</p>
</blockquote>
<p>指定用户：</p>
<blockquote>
<p>ssh -l root 192.168.0.11ssh</p>
</blockquote>
<blockquote>
<p>ssh <a href="mailto:&#x72;&#111;&#111;&#116;&#x40;&#x31;&#57;&#50;&#46;&#49;&#54;&#56;&#46;&#x30;&#46;&#49;&#49;&#116;&#x63;&#x70;">&#x72;&#111;&#111;&#116;&#x40;&#x31;&#57;&#50;&#46;&#49;&#54;&#56;&#46;&#x30;&#46;&#49;&#49;&#116;&#x63;&#x70;</a><br>若是修改过ssh登陆端口的能够：工具</p>
</blockquote>
<blockquote>
<p>ssh -p 12333 192.168.0.11spa</p>
</blockquote>
<blockquote>
<p>ssh -l root -p 12333 216.230.230.114操作系统</p>
</blockquote>
<blockquote>
<p>ssh -p 12333 <a href="mailto:&#x72;&#111;&#111;&#x74;&#x40;&#50;&#49;&#54;&#46;&#x32;&#51;&#48;&#46;&#x32;&#51;&#48;&#x2e;&#x31;&#x31;&#52;">&#x72;&#111;&#111;&#x74;&#x40;&#50;&#49;&#54;&#46;&#x32;&#51;&#48;&#46;&#x32;&#51;&#48;&#x2e;&#x31;&#x31;&#52;</a></p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ssh [-b bind_address] [-c cipher_spec]</span><br><span class="line">[-D [bind_address:]port] [-E log_file] </span><br><span class="line">[-e escape_char] [-F configfile] </span><br><span class="line">[-I pkcs11] [-i identity_file]</span><br><span class="line">[-J [user@]host[:port]] [-L address]</span><br><span class="line">[-l login_name] [-m mac_spec]</span><br><span class="line">[-O ctl_cmd] [-o option] [-p port]</span><br><span class="line">[-Q query_option] [-R address]</span><br><span class="line">[-S ctl_path] [-W host:port] </span><br><span class="line">[-wlocal_tun[:remote_tun]][user@]hostname [command]</span><br></pre></td></tr></table></figure>

<p><strong>默认配置文件和SSH端口</strong></p>
<p>/etc/ssh/sshd_config：OpenSSH服务器配置文件；</p>
<p>/etc/ssh/ssh_config：OpenSSH客户端配置文件；</p>
<p>~/.ssh/：用户SSH配置目录；</p>
<p>~/.ssh/authorized_keys：用户公钥（RSA或DSA）；</p>
<p>/etc/nologin：若是存在这个文件，sshd会拒绝除root用户外的其它用户登陆；</p>
<p>/etc/hosts.allow和/etc/hosts.deny：定义tcp-wrapper执行的访问控制列表；</p>
<ol start="3">
<li><strong>mac终端连接(需要CVM密码)</strong></li>
</ol>
<ul>
<li>打开mac终端</li>
<li>输入<code>chmod 400 &lt;CVM-ssh-的绝对路径&gt;</code></li>
<li>输入<code>ssh root@CVM.ip</code></li>
<li>输入<code>CVM密码</code></li>
</ul>
<hr>
<ul>
<li>打开mac终端</li>
<li>输入<code>chmod 400 &lt;CVM-ssh-的绝对路径&gt;</code></li>
<li>输入<code>ssh -i ~/.ssh/id_rsa root@CVM.ip</code></li>
<li><strong>(无需密码即可)</strong></li>
</ul>
<hr>
<ul>
<li>打开mac终端</li>
<li>输入<code>chmod 400 &lt;CVM-ssh-的绝对路径&gt;</code></li>
<li>输入<code>ssh -l root -p 22 CVM.ip</code></li>
<li><strong>(VCM密码)</strong></li>
</ul>
<h2 id="0-Linux基础"><a href="#0-Linux基础" class="headerlink" title="0.Linux基础"></a>0.Linux基础</h2><p><strong>查看系统内核</strong></p>
<p><code>uname -r</code></p>
<p><strong>查看系统版本</strong></p>
<p><code>cat /etc/os-release</code></p>
<p><strong>用户与主机名</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> [root@localhost]</span></span><br><span class="line">root: 当前登陆的用户</span><br><span class="line">localhost: 当前的主机名</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改主机名</span></span><br><span class="line">1.临时修改</span><br><span class="line">sudo hostname &lt;new-hostname&gt;</span><br><span class="line"></span><br><span class="line">2.永久修改 命令修改|配置修改</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> sudo hostnamectl set-hostname &lt;newhostname&gt;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> vim手动修改/etc/hostname文件</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看当前主机名</span></span><br><span class="line">hostnamectl</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改之后重启生效</span></span><br><span class="line">reboot</span><br></pre></td></tr></table></figure>

<p><strong>退出|关机|重启linux</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">退出:</span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line"></span><br><span class="line">关机命令：</span><br><span class="line">1、halt 立刻关机</span><br><span class="line">2、poweroff 立刻关机</span><br><span class="line">3、shutdown -h now 立刻关机(root用户使用)</span><br><span class="line">4、shutdown -h 10 10分钟后自动关机 如果是通过shutdown命令设置关机的话，可以用shutdown -c命令取消重启</span><br><span class="line">5、init0 停机或者关机</span><br><span class="line"></span><br><span class="line">重启命令：</span><br><span class="line">1、reboot</span><br><span class="line">2、shutdown -r now 立刻重启(root用户使用)</span><br><span class="line">3、shutdown -r 10 过10分钟自动重启(root用户使用)</span><br><span class="line">4、init6 重启</span><br><span class="line"></span><br><span class="line">init一共分为7个级别，这7个级别的所代表的含义如下</span><br><span class="line">0：停机或者关机（千万不能将initdefault设置为0）</span><br><span class="line">1：单用户模式，只root用户进行维护</span><br><span class="line">2：多用户模式，不能使用NFS(Net File System)</span><br><span class="line">3：完全多用户模式（标准的运行级别）</span><br><span class="line">4：安全模式</span><br><span class="line">5：图形化（即图形界面）</span><br><span class="line">6：重启（千万不要把initdefault设置为6）</span><br></pre></td></tr></table></figure>

<h3 id="yum命令"><a href="#yum命令" class="headerlink" title="yum命令"></a>yum命令</h3><blockquote>
<p>yum（ Yellow dog Updater, Modified）是一个在 Fedora 和 RedHat 以及 SUSE 中的 Shell 前端软件包管理器。</p>
</blockquote>
<p>基于 RPM 包管理，能够从指定的服务器自动下载 RPM 包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包，无须繁琐地一次次下载、安装。</p>
<h3 id="SSH登陆"><a href="#SSH登陆" class="headerlink" title="SSH登陆"></a>SSH登陆</h3><ul>
<li>从CVM中获取<code>rsa_pub.pem</code></li>
<li>将<code>rsa_pub.pem</code>保存在client的<code>./ssh</code>目录下</li>
<li>从client<code>./ssh</code>中获取<code>rsa_pub</code></li>
<li>将<code>rsa_pub</code>中的内容放在CVM的<code>/root/.ssh/authorized_keys</code>中</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> client</span> </span><br><span class="line">ssh root@ip</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> ori</span></span><br><span class="line">ssh -i ~/.ssh/rsa_CVM.pub root@CVM.ip</span><br></pre></td></tr></table></figure>

<h4 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h4><p><code>/root/.ssh/authorized_keys</code></p>
<p><strong>远程主机将用户的公钥，保存在此</strong></p>
<ul>
<li>存放访问的client的pub_rsa</li>
</ul>
<hr>
<p><code>/etc/ssh/sshd_config</code></p>
<p><code>/etc/ssh/ssh_config</code></p>
<ul>
<li><p>ssh_config是针对客户端的配置文件</p>
</li>
<li><p>sshd_config是针对服务器的配置文件</p>
</li>
</ul>
<p><strong>ssh服务配置文件</strong></p>
<p><strong>文件修改后使用:</strong></p>
<p><code>service sshd restart </code>保存</p>
<h2 id="1-安装docker"><a href="#1-安装docker" class="headerlink" title="1.安装docker"></a>1.安装docker</h2><p>1⃣️卸载旧版本docker</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$  sudo yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-engine</span><br></pre></td></tr></table></figure>

<p>2⃣️安装yum</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum install -y yum-utils</span><br></pre></td></tr></table></figure>

<p>3⃣️设置镜像仓库</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>

<p>4⃣️更新yum索引和cache</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum makecache fast</span><br></pre></td></tr></table></figure>

<p>5⃣️安装docker</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install docker-ce docker-ce-cli container.io</span><br></pre></td></tr></table></figure>

<p>6⃣️启动docker</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure>

<p>7⃣️查看docker配置|版本</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker version</span><br></pre></td></tr></table></figure>

<p>8⃣️启动hello world</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run hell-world</span><br></pre></td></tr></table></figure>

<p>9⃣️查看docker的images</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>

<h3 id="阿里云镜像加速"><a href="#阿里云镜像加速" class="headerlink" title="阿里云镜像加速"></a>阿里云镜像加速</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://drinkle.top/2021/10/07/My-Project/" data-id="ckugv58gh0000ysf50hvq0wbm" data-title="My-Project" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Drink/" rel="tag">Drink</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-我的学习" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/09/25/%E6%88%91%E7%9A%84%E5%AD%A6%E4%B9%A0/" class="article-date">
  <time class="dt-published" datetime="2021-09-25T15:53:35.000Z" itemprop="datePublished">2021-09-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/09/25/%E6%88%91%E7%9A%84%E5%AD%A6%E4%B9%A0/">我的学习</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="阅读书籍"><a href="#阅读书籍" class="headerlink" title="阅读书籍"></a>阅读书籍</h2><h3 id="框架思维"><a href="#框架思维" class="headerlink" title="框架思维"></a>框架思维</h3><ul>
<li><input disabled="" type="checkbox"> 数据密集型应用</li>
</ul>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><ul>
<li><input disabled="" type="checkbox"> </li>
</ul>
<h3 id="底层源码"><a href="#底层源码" class="headerlink" title="底层源码"></a>底层源码</h3><ul>
<li><input disabled="" type="checkbox"> </li>
</ul>
<h2 id="目前学习"><a href="#目前学习" class="headerlink" title="目前学习"></a>目前学习</h2><h3 id="网络基础原理"><a href="#网络基础原理" class="headerlink" title="网络基础原理"></a>网络基础原理</h3><p><strong>source: wait</strong></p>
<ul>
<li><input disabled="" type="checkbox"> 网络基础原理</li>
</ul>
<h3 id="Docker基础"><a href="#Docker基础" class="headerlink" title="Docker基础"></a>Docker基础</h3><p><strong>source：b站|狂神</strong></p>
<ul>
<li><input disabled="" type="checkbox"> Docker基本概念</li>
<li><input disabled="" type="checkbox"> Docker基本语法</li>
<li><input disabled="" type="checkbox"> Docker进阶</li>
<li><input disabled="" type="checkbox"> Docker实践操作</li>
<li><input disabled="" type="checkbox"> Docker复盘</li>
</ul>
<h3 id="Nginx基础"><a href="#Nginx基础" class="headerlink" title="Nginx基础"></a>Nginx基础</h3><p><strong>source：b站|狂神</strong></p>
<ul>
<li><input disabled="" type="checkbox"> nginx基本概念</li>
<li><input disabled="" type="checkbox"> nginx基本语法</li>
<li><input disabled="" type="checkbox"> nginx进阶</li>
<li><input disabled="" type="checkbox"> nginx实践操作</li>
<li><input disabled="" type="checkbox"> nginx复盘</li>
</ul>
<h2 id="计划学习"><a href="#计划学习" class="headerlink" title="计划学习"></a>计划学习</h2><ul>
<li><input disabled="" type="checkbox"> Nginx</li>
<li><input disabled="" type="checkbox"> 网络基础</li>
<li><input disabled="" type="checkbox"> Celery</li>
<li><input disabled="" type="checkbox"> RabbitMQ</li>
<li><input disabled="" type="checkbox"> Docker</li>
<li><input disabled="" type="checkbox"> Mysql</li>
<li><input disabled="" type="checkbox"> ElasticSearch</li>
<li><input disabled="" type="checkbox"> Hadoop</li>
</ul>
<h2 id="已经学习"><a href="#已经学习" class="headerlink" title="已经学习"></a>已经学习</h2><h3 id="Mongodb"><a href="#Mongodb" class="headerlink" title="Mongodb"></a>Mongodb</h3><p><strong>source：b站|黑马</strong></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> mongodb基本概念</li>
<li><input checked="" disabled="" type="checkbox"> mongodb基本语法</li>
<li><input disabled="" type="checkbox"> mongodb进阶</li>
<li><input disabled="" type="checkbox"> mongodb实践操作</li>
<li><input disabled="" type="checkbox"> mongodb复盘</li>
</ul>
<h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><p><strong>source：b站|狂神</strong></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> redis基本概念</li>
<li><input checked="" disabled="" type="checkbox"> redis基本语法</li>
<li><input disabled="" type="checkbox"> redis进阶</li>
<li><input disabled="" type="checkbox"> redis实践操作</li>
<li><input disabled="" type="checkbox"> redis复盘</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://drinkle.top/2021/09/25/%E6%88%91%E7%9A%84%E5%AD%A6%E4%B9%A0/" data-id="cktzzenlq0000i0f58tkx7ytw" data-title="我的学习" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/825%E8%AE%A1%E5%88%92/" rel="tag">825计划</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-数据库索引原理" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/29/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86/" class="article-date">
  <time class="dt-published" datetime="2021-08-29T05:41:59.000Z" itemprop="datePublished">2021-08-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/08/29/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86/">数据库索引原理</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="数据库索引原理"><a href="#数据库索引原理" class="headerlink" title="数据库索引原理"></a>数据库索引原理</h2><h3 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a><strong>推荐阅读</strong></h3><p><a target="_blank" rel="noopener" href="https://liuchenyang0515.blog.csdn.net/article/details/118004118"><strong>MySQL索引——入门进阶必备</strong></a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_34115899/article/details/118308424"><strong>MySQL中B+树索引的应用场景大全</strong></a></p>
<hr>
<p><a target="_blank" rel="noopener" href="https://haicoder.net/mongodb/mongodb-index-principle.html"><strong>MongoDB索引原理</strong></a></p>
<hr>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/348074129"><strong>关系型数据库和非关系型数据库之间的区别</strong></a></p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1784274"><strong>非关系型数据库（NOSQL）和关系型数据库（SQL）区别详解</strong></a></p>
<hr>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/lh_hebine/article/details/99051646"><strong>什么是事务？事务的四大特性是什么？</strong></a></p>
<p>B+树索引是B+树在数据库中的一种实现，是最常见也是数据库中使用最为频繁的一种索引。B+树中的B代表平衡（balance），而不是二叉（binary），因为B+树是从最早的平衡二叉树演化而来的。在讲B+树之前必须先了解二叉查找树、平衡二叉树（AVLTree）和平衡多路查找树（B-Tree），B+树即由这些树逐步优化而来。</p>
<h3 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h3><p>二叉树具有以下性质：左子树的键值小于根的键值，右子树的键值大于根的键值。<br>如下图所示就是一棵二叉查找树，</p>
<p><img src="https://img-blog.csdn.net/20160202203355523" alt="索引"></p>
<p>对该二叉树的节点进行查找发现深度为1的节点的查找次数为1，深度为2的查找次数为2，深度为n的节点的查找次数为n，因此其平均查找次数为 (1+2+2+3+3+3) / 6 = 2.3次</p>
<p>二叉查找树可以任意地构造，同样是2,3,5,6,7,8这六个数字，也可以按照下图的方式来构造：</p>
<p><img src="https://img-blog.csdn.net/20160202203448944" alt="索引"></p>
<p>但是这棵二叉树的查询效率就低了。因此若想二叉树的查询效率尽可能高，需要这棵二叉树是平衡的，从而引出新的定义——平衡二叉树，或称AVL树。</p>
<h3 id="平衡二叉树（AVL-Tree）"><a href="#平衡二叉树（AVL-Tree）" class="headerlink" title="平衡二叉树（AVL Tree）"></a>平衡二叉树（AVL Tree）</h3><p>平衡二叉树（AVL树）在符合二叉查找树的条件下，还满足任何节点的两个子树的高度最大差为1。下面的两张图片，左边是AVL树，它的任何节点的两个子树的高度差&lt;=1；右边的不是AVL树，其根节点的左子树高度为3，而右子树高度为1；</p>
<p><img src="https://img-blog.csdn.net/20160202203554663" alt="索引"></p>
<p>如果在AVL树中进行插入或删除节点，可能导致AVL树失去平衡，这种失去平衡的二叉树可以概括为四种姿态：LL（左左）、RR（右右）、LR（左右）、RL（右左）。它们的示意图如下：</p>
<p><img src="https://img-blog.csdn.net/20160202203648148" alt="索引"></p>
<p>这四种失去平衡的姿态都有各自的定义：</p>
<ul>
<li><p><strong>LL</strong>：LeftLeft，也称“左左”。插入或删除一个节点后，根节点的左孩子（Left Child）的左孩子（Left Child）还有非空节点，导致根节点的左子树高度比右子树高度高2，AVL树失去平衡。</p>
</li>
<li><p><strong>RR</strong>：RightRight，也称“右右”。插入或删除一个节点后，根节点的右孩子（Right Child）的右孩子（Right Child）还有非空节点，导致根节点的右子树高度比左子树高度高2，AVL树失去平衡。</p>
</li>
<li><p><strong>LR</strong>：LeftRight，也称“左右”。插入或删除一个节点后，根节点的左孩子（Left Child）的右孩子（Right Child）还有非空节点，导致根节点的左子树高度比右子树高度高2，AVL树失去平衡。</p>
</li>
<li><p><strong>RL</strong>：RightLeft，也称“右左”。插入或删除一个节点后，根节点的右孩子（Right Child）的左孩子（Left Child）还有非空节点，导致根节点的右子树高度比左子树高度高2，AVL树失去平衡。</p>
</li>
</ul>
<p>AVL树失去平衡之后，可以通过旋转使其恢复平衡。下面分别介绍四种失去平衡的情况下对应的旋转方法。</p>
<p>LL的旋转。LL失去平衡的情况下，可以通过一次旋转让AVL树恢复平衡。步骤如下：</p>
<ol>
<li>将根节点的左孩子作为新根节点。</li>
<li>将新根节点的右孩子作为原根节点的左孩子。</li>
<li>将原根节点作为新根节点的右孩子。</li>
</ol>
<p><strong>LL旋转示意图如下：</strong></p>
<p><img src="https://img-blog.csdn.net/20160202204113994" alt="索引"></p>
<p><strong>RR的旋转：</strong>RR失去平衡的情况下，旋转方法与LL旋转对称，步骤如下：</p>
<ol>
<li>将根节点的右孩子作为新根节点。</li>
<li>将新根节点的左孩子作为原根节点的右孩子。</li>
<li>将原根节点作为新根节点的左孩子。</li>
</ol>
<p><strong>RR旋转示意图如下：</strong></p>
<p><img src="https://img-blog.csdn.net/20160202204207963" alt="索引"></p>
<p>LR的旋转：LR失去平衡的情况下，需要进行两次旋转，步骤如下：</p>
<ol>
<li>围绕根节点的左孩子进行RR旋转。</li>
<li>围绕根节点进行LL旋转。</li>
</ol>
<p><strong>LR的旋转示意图如下：</strong></p>
<p><img src="https://img-blog.csdn.net/20160202204257369" alt="索引"></p>
<p>RL的旋转：RL失去平衡的情况下也需要进行两次旋转，旋转方法与LR旋转对称，步骤如下：</p>
<ol>
<li>围绕根节点的右孩子进行LL旋转。</li>
<li>围绕根节点进行RR旋转。</li>
</ol>
<p><strong>RL的旋转示意图如下：</strong></p>
<p><img src="https://img-blog.csdn.net/20160202204331073" alt="索引"></p>
<h3 id="平衡多路查找树（B-Tree）"><a href="#平衡多路查找树（B-Tree）" class="headerlink" title="平衡多路查找树（B-Tree）"></a>平衡多路查找树（B-Tree）</h3><p>B-Tree是为磁盘等外存储设备设计的一种平衡查找树。因此在讲B-Tree之前先了解下磁盘的相关知识。</p>
<p>系统从磁盘读取数据到内存时是以磁盘块（block）为基本单位的，位于同一个磁盘块中的数据会被一次性读取出来，而不是需要什么取什么。</p>
<p>InnoDB存储引擎中有页（Page）的概念，页是其磁盘管理的最小单位。InnoDB存储引擎中默认每个页的大小为16KB，可通过参数innodb_page_size将页的大小设置为4K、8K、16K，在MySQL中可通过如下命令查看页的大小：</p>
<p><code>mysql&gt; show variables like &#39;innodb_page_size&#39;;</code></p>
<p>而系统一个磁盘块的存储空间往往没有这么大，因此InnoDB每次申请磁盘空间时都会是若干地址连续磁盘块来达到页的大小16KB。InnoDB在把磁盘数据读入到磁盘时会以页为基本单位，在查询数据时如果一个页中的每条数据都能有助于定位数据记录的位置，这将会减少磁盘I/O次数，提高查询效率。</p>
<p>B-Tree结构的数据可以让系统高效的找到数据所在的磁盘块。为了描述B-Tree，首先定义一条记录为一个二元组[key, data] ，key为记录的键值，对应表中的主键值，data为一行记录中除主键外的数据。对于不同的记录，key值互不相同。</p>
<p>一棵m阶的B-Tree有如下特性：</p>
<ol>
<li>每个节点最多有m个孩子。</li>
<li>除了根节点和叶子节点外，其它每个节点至少有Ceil(m/2)个孩子。</li>
<li>若根节点不是叶子节点，则至少有2个孩子</li>
<li>所有叶子节点都在同一层，且不包含其它关键字信息</li>
<li>每个非终端节点包含n个关键字信息（P0,P1,…Pn, k1,…kn）</li>
<li>关键字的个数n满足：ceil(m/2)-1 &lt;= n &lt;= m-1</li>
<li>ki(i=1,…n)为关键字，且关键字升序排序。</li>
<li>Pi(i=1,…n)为指向子树根节点的指针。P(i-1)指向的子树的所有节点关键字均小于ki，但都大于k(i-1)</li>
</ol>
<p>B-Tree中的每个节点根据实际情况可以包含大量的关键字信息和分支，如下图所示为一个3阶的B-Tree：</p>
<p><img src="https://img-blog.csdn.net/20160202204827368" alt="索引"></p>
<p>每个节点占用一个盘块的磁盘空间，一个节点上有两个升序排序的关键字和三个指向子树根节点的指针，指针存储的是子节点所在磁盘块的地址。两个关键词划分成的三个范围域对应三个指针指向的子树的数据的范围域。以根节点为例，关键字为17和35，P1指针指向的子树的数据范围为小于17，P2指针指向的子树的数据范围为17~35，P3指针指向的子树的数据范围为大于35。</p>
<p><strong>模拟查找关键字29的过程：</strong></p>
<ol>
<li>根据根节点找到磁盘块1，读入内存。【磁盘I/O操作第1次】</li>
<li>比较关键字29在区间（17,35），找到磁盘块1的指针P2。</li>
<li>根据P2指针找到磁盘块3，读入内存。【磁盘I/O操作第2次】</li>
<li>比较关键字29在区间（26,30），找到磁盘块3的指针P2。</li>
<li>根据P2指针找到磁盘块8，读入内存。【磁盘I/O操作第3次】</li>
<li>在磁盘块8中的关键字列表中找到关键字29。</li>
</ol>
<p>分析上面过程，发现需要3次磁盘I/O操作，和3次内存查找操作。由于内存中的关键字是一个有序表结构，可以利用二分法查找提高效率。而3次磁盘I/O操作是影响整个B-Tree查找效率的决定因素。B-Tree相对于AVLTree缩减了节点个数，使每次磁盘I/O取到内存的数据都发挥了作用，从而提高了查询效率。</p>
<h3 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B+Tree"></a>B+Tree</h3><p>B+Tree是在B-Tree基础上的一种优化，使其更适合实现外存储索引结构，InnoDB存储引擎就是用B+Tree实现其索引结构。</p>
<p>从上一节中的B-Tree结构图中可以看到每个节点中不仅包含数据的key值，还有data值。而每一个页的存储空间是有限的，如果data数据较大时将会导致每个节点（即一个页）能存储的key的数量很小，当存储的数据量很大时同样会导致B-Tree的深度较大，增大查询时的磁盘I/O次数，进而影响查询效率。在B+Tree中，所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上，而非叶子节点上只存储key值信息，这样可以大大加大每个节点存储的key值数量，降低B+Tree的高度。</p>
<p>B+Tree相对于B-Tree有几点不同：</p>
<ol>
<li>非叶子节点只存储键值信息。</li>
<li>所有叶子节点之间都有一个链指针。</li>
<li>数据记录都存放在叶子节点中。</li>
</ol>
<p>将上一节中的B-Tree优化，由于B+Tree的非叶子节点只存储键值信息，假设每个磁盘块能存储4个键值及指针信息，则变成B+Tree后其结构如下图所示：</p>
<p><img src="https://img-blog.csdn.net/20160202205105560" alt="索引"></p>
<p>通常在B+Tree上有两个头指针，一个指向根节点，另一个指向关键字最小的叶子节点，而且所有叶子节点（即数据节点）之间是一种链式环结构。因此可以对B+Tree进行两种查找运算：一种是对于主键的范围查找和分页查找，另一种是从根节点开始，进行随机查找。</p>
<p>可能上面例子中只有22条数据记录，看不出B+Tree的优点，下面做一个推算：</p>
<p>InnoDB存储引擎中页的大小为16KB，一般表的主键类型为INT（占用4个字节）或BIGINT（占用8个字节），指针类型也一般为4或8个字节，也就是说一个页（B+Tree中的一个节点）中大概存储16KB/(8B+8B)=1K个键值（因为是估值，为方便计算，这里的K取值为10^3^)。也就是说一个深度为3的B+Tree索引可以维护10^3 * 10^3 * 10^3 = 10亿 条记录。</p>
<p>实际情况中每个节点可能不能填充满，因此在数据库中，B+Tree的高度一般都在2<del>4层。MySQL的InnoDB存储引擎在设计时是将根节点常驻内存的，也就是说查找某一键值的行记录时最多只需要1</del>3次磁盘I/O操作。</p>
<p>数据库中的B+Tree索引可以分为聚集索引（clustered index）和辅助索引（secondary index）。上面的B+Tree示例图在数据库中的实现即为聚集索引，聚集索引的B+Tree中的叶子节点存放的是整张表的行记录数据。辅助索引与聚集索引的区别在于辅助索引的叶子节点并不包含行记录的全部数据，而是存储相应行数据的聚集索引键，即主键。当通过辅助索引来查询数据时，InnoDB存储引擎会遍历辅助索引找到主键，然后再通过主键在聚集索引中找到完整的行记录数据。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://drinkle.top/2021/08/29/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86/" data-id="ckswtcg150001kcf5gvrl6l3n" data-title="数据库索引原理" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/DataBase/" rel="tag">DataBase</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Mongodb" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/28/Mongodb/" class="article-date">
  <time class="dt-published" datetime="2021-08-28T03:38:04.000Z" itemprop="datePublished">2021-08-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/08/28/Mongodb/">Mongodb</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Mongodb"><a href="#Mongodb" class="headerlink" title="Mongodb"></a>Mongodb</h1><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><p><a target="_blank" rel="noopener" href="https://www.codenong.com/6452021/"><strong>mongodb时间戳</strong></a></p>
<h2 id="id"><a href="#id" class="headerlink" title="_id"></a>_id</h2><p>打开 MongoDB 数据库中的任何一个文档，你会注意到文档中有一个 _id 字段，实际上，ObjectId 或 _id 是每个 MongoDB 文档中都存在的字段。</p>
<h3 id="bjectId-的结构"><a href="#bjectId-的结构" class="headerlink" title="bjectId 的结构"></a>bjectId 的结构</h3><p>这些是 _id 的一些主要特征的摘要：</p>
<ul>
<li>_id 是集合中文档的主键，用于区分文档（记录）。</li>
<li>_id自动编入索引。指定 { _id: } 的查找将 _id 索引作为其指南。</li>
<li>默认情况下，_id 字段的类型为 ObjectID，是 MongoDB 的 BSON 类型之一。如果需要，用户还可以将 _id 覆盖为 ObjectID 以外的其他内容。</li>
</ul>
<p>ObjectID 长度为 12 字节，由几个 2-4 字节的链组成。每个链代表并指定文档身份的具体内容。以下的值构成了完整的 12 字节组合：</p>
<p><strong>一个字节两个字符</strong></p>
<ul>
<li>一个 4 字节的值，表示自 Unix 纪元以来的秒数–&gt;8位16进制</li>
<li>一个 3 字节的机器标识符</li>
<li>一个 2 字节的进程 ID</li>
<li>一个 3 字节的计数器，以随机值开始</li>
</ul>
<p><img src="http://www.navicat.com.cn/link/Blog/Image/2019/20190326/_id.png" alt="img"></p>
<p>通常，你不必担心要如何生成 ObjectID。如果文档尚未分配 _id 值，MongoDB 将自动生成一个 _id 值。</p>
<h3 id="创建新的-ObjectId"><a href="#创建新的-ObjectId" class="headerlink" title="创建新的 ObjectId"></a>创建新的 ObjectId</h3><p>如果你想自己生成新的 ObjectId，可以使用以下代码：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newObjectId = ObjectId()</span><br></pre></td></tr></table></figure>

<p>你也可以直接在 Navicat 编辑器中输入它。</p>
<p>这将会生成一个唯一的 _id，例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ObjectId(&quot;5349b4ddd2781d08c09890f3&quot;)</span><br></pre></td></tr></table></figure>

<p>或者，你亦可以提供一个 12 字节的 ID：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myObjectId = ObjectId(&quot;5349b4ddd2781d08c09890f4&quot;)</span><br></pre></td></tr></table></figure>

<h3 id="文档的创建时间戳"><a href="#文档的创建时间戳" class="headerlink" title="文档的创建时间戳"></a>文档的创建时间戳</h3><p>由于 _id ObjectId 默认存储了 4 字节的时间戳，因此在大多数情况下，你不需要存储任何文档的创建时间。你可以使用 getTimestamp 方法获取文档的创建时间：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ObjectId(&quot;5349b4ddd2781d08c09890f4&quot;).getTimestamp()</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;</span></span><br><span class="line">ObjectId(&quot;612b264173e5b4a6bda0abdb&quot;)</span><br></pre></td></tr></table></figure>

<p>这将以 ISO 日期格式返回此文档的创建时间</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ISODate(&quot;2019-09-12T30:39:17Z&quot;)</span><br></pre></td></tr></table></figure>

<h3 id="将-ObjectId-转换为字符串（String）"><a href="#将-ObjectId-转换为字符串（String）" class="headerlink" title="将 ObjectId 转换为字符串（String）"></a>将 ObjectId 转换为字符串（String）</h3><p>在某些情况下，你可能需要得到字符串格式的 ObjectId 值。若要转换 ObjectId 为字符串，请使用以下代码：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newObjectId.str</span><br></pre></td></tr></table></figure>

<p>上面的代码将返回 Guid 的字符串格式的 ObjectId：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5349b4ddd2781d08c09890f3</span><br></pre></td></tr></table></figure>

<h3 id="文档排序"><a href="#文档排序" class="headerlink" title="文档排序"></a>文档排序</h3><p>由于每个 ObjectId 都包含一个时间戳，因此你可以用 _id 字段将文档按创建时间排序。但请务必注意，此排序方法并不代表排序是严格或精确的，因为 ID 的其他组件也会影响，导致次序会反映其他变量，而不仅仅是创建时间。</p>
<h3 id="更改-ObjectId"><a href="#更改-ObjectId" class="headerlink" title="更改 ObjectId"></a>更改 ObjectId</h3><p>_id 字段基本上是不可变的。在创建文档之后，根据定义，它已被分配了一个无法更改的 _id。话虽如此，在插入新文档时是可以覆盖 _id 的。覆盖文档的 _id 字段可能有其用处，但是当这样做时，你有责任确保每个文档的 _id 值都是唯一的。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://drinkle.top/2021/08/28/Mongodb/" data-id="ckswtcg130000kcf5h35y6ngc" data-title="Mongodb" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Mongodb/" rel="tag">Mongodb</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-English-Study-5" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/25/English-Study-5/" class="article-date">
  <time class="dt-published" datetime="2021-08-25T13:08:38.000Z" itemprop="datePublished">2021-08-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/08/25/English-Study-5/">English-Study-5</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Day7"><a href="#Day7" class="headerlink" title="Day7"></a>Day7</h2><ul>
<li><input disabled="" type="checkbox"> detach |蒂塔迟～| n v 分离 分开 派遣</li>
<li><input disabled="" type="checkbox"> STDIN  标准输入</li>
<li><input disabled="" type="checkbox"> interactive |艾特.rua^棵.忒.夫.| adj  web n 交互的 相互配合的</li>
<li><input disabled="" type="checkbox"> isolation |艾涩.雷神.| n adj web 隔离 分离 分析 绝缘</li>
</ul>
<hr>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">-i, --interactive                    </span><br><span class="line">	 Keep STDIN open even if not attached</span><br><span class="line">	 </span><br><span class="line">     --ip string</span><br><span class="line">     IPv4 address (e.g., 172.30.100.104)</span><br><span class="line">     </span><br><span class="line">     --ip6 string</span><br><span class="line">     IPv6 address (e.g., 2001:db8::33)</span><br><span class="line">     </span><br><span class="line">     --ipc string</span><br><span class="line">     IPC mode to use</span><br><span class="line">     </span><br><span class="line">     --isolation string</span><br><span class="line">     Container isolation technology</span><br><span class="line">     </span><br><span class="line">     --kernel-memory bytes</span><br><span class="line">     Kernel memory limit</span><br></pre></td></tr></table></figure>



<h2 id="Day6"><a href="#Day6" class="headerlink" title="Day6"></a>Day6</h2><ul>
<li><input disabled="" type="checkbox"> digest |得艾.杰.斯特| n 摘要 汇编 v 消化 理解 领会 web 忍受</li>
<li><input disabled="" type="checkbox"> suffix |撒.费.刻丝-| n 后缀</li>
<li><input disabled="" type="checkbox"> discard|滴.斯.嘎得.| n 抛弃 垫出的牌 v 抛弃 解雇 web 丢弃</li>
</ul>
<h2 id="Day5"><a href="#Day5" class="headerlink" title="Day5"></a>Day5</h2><ul>
<li><input disabled="" type="checkbox"> dimension |呆.门.身.| n 纬度</li>
</ul>
<h2 id="Day4"><a href="#Day4" class="headerlink" title="Day4"></a>Day4</h2><ul>
<li><input disabled="" type="checkbox"> stock |丝.大.渴| n 股票 库存 储备 v 库存 放鱼 adj 老一套 常备的 web 存库 紫罗兰 </li>
<li><input disabled="" type="checkbox"> purchase |泼.企^鹅.丝| n v 购买 买卖</li>
</ul>
<h2 id="Day3"><a href="#Day3" class="headerlink" title="Day3"></a>Day3</h2><ul>
<li><input disabled="" type="checkbox"> async |A.醒颗| n 异步</li>
<li><input disabled="" type="checkbox"> commodity |渴.贸得.忒| n 商品 产品 大宗商品</li>
<li><input disabled="" type="checkbox"> distribution |低丝泼.biu.什恩| n 分布 分配 分发 web 配送 发行 配销</li>
<li><input disabled="" type="checkbox"> refund |瑞.放得饿| n v 退款 返还款 偿还金额</li>
</ul>
<h2 id="Day2"><a href="#Day2" class="headerlink" title="Day2"></a>Day2</h2><ul>
<li><input disabled="" type="checkbox"> scalability |斯.盖楼.biu乐^特A| n 可扩展性</li>
<li><input disabled="" type="checkbox"> cipher |撒.佛沃.| n 密码 密码索引 v 计算 web 暗号 密文 加密算法</li>
</ul>
<h2 id="Day1"><a href="#Day1" class="headerlink" title="Day1"></a>Day1</h2><ul>
<li><input disabled="" type="checkbox"> fuzzy |佛爱.Z(en)·| adj 模糊的, 有绒毛的, 失帧的</li>
<li><input disabled="" type="checkbox"> essence|艾森.s~| n 本质的 实质 香精 精华 要素</li>
<li><input disabled="" type="checkbox"> snapshot|斯.奈普,少特er| n 简介 快照</li>
<li><input disabled="" type="checkbox"> resource|瑞扫丝.| n 资源</li>
<li><input disabled="" type="checkbox"> quantity|框内A^特A.| n 数量 大量 订购数量 </li>
<li><input disabled="" type="checkbox"> retrieve|瑞.吹无^v| n 恢复 v 取回, 挽回 检索</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://drinkle.top/2021/08/25/English-Study-5/" data-id="cksrl3vnz0000vkf52qcq85vv" data-title="English-Study-5" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/English-Study/" rel="tag">English Study</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/825%E8%AE%A1%E5%88%92/" rel="tag">825计划</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Algorithm/" rel="tag">Algorithm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/BuiltIn/" rel="tag">BuiltIn</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Daily-Plan/" rel="tag">Daily Plan</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Data-Structure/" rel="tag">Data Structure</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DataBase/" rel="tag">DataBase</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Drink/" rel="tag">Drink</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/English-Study/" rel="tag">English Study</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GoodNotes/" rel="tag">GoodNotes</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hexo/" rel="tag">Hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LeeCode/" rel="tag">LeeCode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mongodb/" rel="tag">Mongodb</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Object-Oriented/" rel="tag">Object Oriented</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Postgraduate/" rel="tag">Postgraduate</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/" rel="tag">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python%E5%90%8E%E7%AB%AF/" rel="tag">Python后端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spirit/" rel="tag">Spirit</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/consciousness/" rel="tag">consciousness</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/django/" rel="tag">django</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/source-code/" rel="tag">source-code</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%96%E7%95%8C%E8%A7%82/" rel="tag">世界观</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%96%E7%95%8C%E8%A7%82-%E6%96%B9%E6%B3%95%E8%AE%BA/" rel="tag">世界观 方法论</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AE%9E%E8%B7%B5/" rel="tag">实践</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B7%A6%E7%BF%BC%E5%90%8C%E7%9B%9F%E4%BC%9A/" rel="tag">左翼同盟会</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%96%B0%E9%97%BB%E8%81%94%E6%92%AD/" rel="tag">新闻联播</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%8B%AC%E5%88%B0%E7%A7%91%E6%8A%80/" rel="tag">独到科技</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%87%B4%E4%BD%A0%E7%9A%84%E4%B8%80%E5%B0%81%E4%BF%A1/" rel="tag">致你的一封信</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/825%E8%AE%A1%E5%88%92/" style="font-size: 13.33px;">825计划</a> <a href="/tags/Algorithm/" style="font-size: 10px;">Algorithm</a> <a href="/tags/BuiltIn/" style="font-size: 10px;">BuiltIn</a> <a href="/tags/Daily-Plan/" style="font-size: 10px;">Daily Plan</a> <a href="/tags/Data-Structure/" style="font-size: 10px;">Data Structure</a> <a href="/tags/DataBase/" style="font-size: 10px;">DataBase</a> <a href="/tags/Drink/" style="font-size: 13.33px;">Drink</a> <a href="/tags/English-Study/" style="font-size: 20px;">English Study</a> <a href="/tags/GoodNotes/" style="font-size: 10px;">GoodNotes</a> <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/LeeCode/" style="font-size: 10px;">LeeCode</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/Mongodb/" style="font-size: 10px;">Mongodb</a> <a href="/tags/MySQL/" style="font-size: 10px;">MySQL</a> <a href="/tags/Object-Oriented/" style="font-size: 10px;">Object Oriented</a> <a href="/tags/Postgraduate/" style="font-size: 10px;">Postgraduate</a> <a href="/tags/Python/" style="font-size: 16.67px;">Python</a> <a href="/tags/Python%E5%90%8E%E7%AB%AF/" style="font-size: 10px;">Python后端</a> <a href="/tags/Spirit/" style="font-size: 10px;">Spirit</a> <a href="/tags/consciousness/" style="font-size: 10px;">consciousness</a> <a href="/tags/django/" style="font-size: 10px;">django</a> <a href="/tags/source-code/" style="font-size: 10px;">source-code</a> <a href="/tags/%E4%B8%96%E7%95%8C%E8%A7%82/" style="font-size: 13.33px;">世界观</a> <a href="/tags/%E4%B8%96%E7%95%8C%E8%A7%82-%E6%96%B9%E6%B3%95%E8%AE%BA/" style="font-size: 10px;">世界观 方法论</a> <a href="/tags/%E5%AE%9E%E8%B7%B5/" style="font-size: 10px;">实践</a> <a href="/tags/%E5%B7%A6%E7%BF%BC%E5%90%8C%E7%9B%9F%E4%BC%9A/" style="font-size: 10px;">左翼同盟会</a> <a href="/tags/%E6%96%B0%E9%97%BB%E8%81%94%E6%92%AD/" style="font-size: 10px;">新闻联播</a> <a href="/tags/%E7%8B%AC%E5%88%B0%E7%A7%91%E6%8A%80/" style="font-size: 10px;">独到科技</a> <a href="/tags/%E8%87%B4%E4%BD%A0%E7%9A%84%E4%B8%80%E5%B0%81%E4%BF%A1/" style="font-size: 10px;">致你的一封信</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">二月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">十一月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">十月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">九月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">八月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">七月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">六月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">五月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">四月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">三月 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/02/22/python%E9%9D%A2%E8%AF%95%E9%A2%98/">python面试题</a>
          </li>
        
          <li>
            <a href="/2022/02/06/%E6%B5%81%E7%95%85%E7%9A%84python/">流畅的python</a>
          </li>
        
          <li>
            <a href="/2021/11/14/%E7%BB%8F%E6%B5%8E%E5%88%86%E6%9E%90-1/">经济分析[1]</a>
          </li>
        
          <li>
            <a href="/2021/11/14/%E6%96%B0%E9%97%BB%E8%81%94%E6%92%AD-2/">新闻联播[2]</a>
          </li>
        
          <li>
            <a href="/2021/10/07/Question/">Question</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 Drink<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>