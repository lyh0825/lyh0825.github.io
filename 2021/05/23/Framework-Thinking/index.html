<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Framework-Thinking | Drink`s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="Backtracking Algorithm算法介绍实际场景中，解决问题的出发点有多种，为了确认这些出发点是否真的可以解决问题，我们需要逐一测试，找出 1 个甚至所有可行的解决方案，必要时还需要从众多可行方案中找出一个最优的方案。这种情况下，就可以优先考虑回溯算法。 回溯是一种可查找部分甚至全部解决方案的算法，它能够对所有的可行性方案进行测试，一旦判定某个方案无效，则以回溯的方式继续测试其它的方案">
<meta property="og:type" content="article">
<meta property="og:title" content="Framework-Thinking">
<meta property="og:url" content="https://drinkle.top/2021/05/23/Framework-Thinking/index.html">
<meta property="og:site_name" content="Drink&#96;s Blog">
<meta property="og:description" content="Backtracking Algorithm算法介绍实际场景中，解决问题的出发点有多种，为了确认这些出发点是否真的可以解决问题，我们需要逐一测试，找出 1 个甚至所有可行的解决方案，必要时还需要从众多可行方案中找出一个最优的方案。这种情况下，就可以优先考虑回溯算法。 回溯是一种可查找部分甚至全部解决方案的算法，它能够对所有的可行性方案进行测试，一旦判定某个方案无效，则以回溯的方式继续测试其它的方案">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/20210708164033.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/20210708164113.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/20210708213932.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/20210708164837.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/20210708163344.png">
<meta property="article:published_time" content="2021-05-23T10:35:51.000Z">
<meta property="article:modified_time" content="2021-07-13T03:21:23.601Z">
<meta property="article:author" content="Drink">
<meta property="article:tag" content="consciousness">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/20210708164033.png">
  
    <link rel="alternate" href="/atom.xml" title="Drink`s Blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Drink`s Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://drinkle.top"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-Framework-Thinking" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/23/Framework-Thinking/" class="article-date">
  <time class="dt-published" datetime="2021-05-23T10:35:51.000Z" itemprop="datePublished">2021-05-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      Framework-Thinking
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Backtracking-Algorithm"><a href="#Backtracking-Algorithm" class="headerlink" title="Backtracking Algorithm"></a>Backtracking Algorithm</h2><h3 id="算法介绍"><a href="#算法介绍" class="headerlink" title="算法介绍"></a>算法介绍</h3><p>实际场景中，解决问题的出发点有多种，为了确认这些出发点是否真的可以解决问题，我们需要逐一测试，找出 1 个甚至所有可行的解决方案，必要时还需要从众多可行方案中找出一个最优的方案。这种情况下，就可以优先考虑回溯算法。</p>
<p>回溯是一种可查找部分甚至全部解决方案的算法，它能够对所有的可行性方案进行测试，一旦判定某个方案无效，则以回溯的方式继续测试其它的方案，直至测试完所有的方案。</p>
<p>回溯可以简单地理解为“回退”或者“原路返回”，我们以一个实例来理解回溯的含义。如下图所示，找出从 A 到 K 的路径：<br><img src="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/20210708164033.png"><br>图 1 回溯的含义<br>显然，从 A 到 K 的路径为 A-E-J-K，但如果要编程实现查找可行的路径，需要一一测试从 A 出发的所有路径，整个查找的过程为：</p>
<ul>
<li>从 A 出发，有 2 条路径可以选择，先选择 A-B；从 B 出发，又有 2 条路径，先选择 B-C；</li>
<li>到达 C 后，发现无法达到 K，所以放弃此路线，回退至 B，继续测试其他路径（第一次回溯）；</li>
<li>继续探查 B-D，发现也无法到达 K，回退到 B，继续探测其他路径（第二次回溯）；</li>
<li>除 B-C 和 B-D 外，没有其他路径可供选择，回退至 A，探测其他路径（第三次回溯）；</li>
<li>除了 A-B 外，还可以选择 A-E，测试过程同测试 A-B 部分的方式完全相同。</li>
</ul>
<p>下图给您描绘了测试所有路径所经历的过程：</p>
<p><img src="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/20210708164113.png"><br>通过不断的回溯，找到解决问题的所有可行方案，这样的算法就称为回溯算法。</p>
<h3 id="算法运用"><a href="#算法运用" class="headerlink" title="算法运用"></a>算法运用</h3><p>回溯算法经常以递归的方式实现，该算法常用于解决以下 3 类问题：</p>
<ol>
<li>决策问题：从众多选择中找到一个可行的解决方案；</li>
<li>优化问题：从众多选择中找到一个最佳的解决方案；</li>
<li>枚举问题：找出能解决问题的所有方案。</li>
</ol>
<p>经典的适合用回溯算法解决的问题有 <a target="_blank" rel="noopener" href="https://www.biancheng.net/algorithm/n-queens-problem.html">N皇后问题</a>、<a target="_blank" rel="noopener" href="https://www.biancheng.net/algorithm/maze-puzzle.html">迷宫问题</a>等，我们会在后续章节给大家做详细的讲解。</p>
<h2 id="Divide-and-conquer-algorithm"><a href="#Divide-and-conquer-algorithm" class="headerlink" title="Divide and conquer algorithm"></a>Divide and conquer algorithm</h2><p><code>用空间换时间</code></p>
<h3 id="算法介绍-1"><a href="#算法介绍-1" class="headerlink" title="算法介绍"></a>算法介绍</h3><p>实际开发中，我们经常会使用一些巧妙的算法解决问题，分治算法就是其中之一。</p>
<p>分治算法是指采用分而治之的思想，将一个复杂的问题划分成很多相互独立的小问题，通过逐个解决这些小问题，使整个问题得到解决。</p>
<p>使用分治算法解决问题，大致经历 3 个阶段：</p>
<ol>
<li>分：将整个问题划分为很多相互独立的小问题（子问题），很多小问题还可以进行更细致地划分，直至这些问题不可再分；</li>
<li>治：逐个解决每个子问题，整个过程通常采用递归的方式实现；</li>
<li>合并：合并所有子问题的解决方案，得到整个问题的解决方案。</li>
</ol>
<h3 id="算法特点"><a href="#算法特点" class="headerlink" title="算法特点"></a>算法特点</h3><p>分治算法擅长解决一些规模较大的问题，直接解决此类问题的难度较大，通过将大问题“分而治之”，可以简化问题的难度。此外，由于分解得到的诸多小问题之间是相互独立的，所以可以采用并发执行的方式，提高问题的解决效率。</p>
<p>分治算法的缺陷也很明显，该算法常常采用递归的方式实现，整个过程需要消耗大量的系统资源，严重时还会导致程序崩溃。</p>
<h3 id="算法运用-1"><a href="#算法运用-1" class="headerlink" title="算法运用"></a>算法运用</h3><ul>
<li>解决<a target="_blank" rel="noopener" href="https://www.biancheng.net/algorithm/max-min-problem.html">数组最大值和最小值问题</a>；</li>
<li>实现<a target="_blank" rel="noopener" href="https://www.biancheng.net/algorithm/binary_search.html">二分查找算法</a>；</li>
<li>实现<a target="_blank" rel="noopener" href="https://www.biancheng.net/algorithm/merge_sort.html">归并排序算法</a>；</li>
<li>实现<a target="_blank" rel="noopener" href="https://www.biancheng.net/algorithm/stable-sorting.html">快速排序算法</a>；</li>
<li>解决<a target="_blank" rel="noopener" href="https://www.biancheng.net/algorithm/tower_of_hanoi.html">汉诺塔问题</a>。</li>
</ul>
<h2 id="Greedy-Algorithm"><a href="#Greedy-Algorithm" class="headerlink" title="Greedy Algorithm"></a>Greedy Algorithm</h2><ul>
<li>计算性价比</li>
<li>根据性价比进行排序（包括weight、value）等</li>
<li>使用while循环控制每次取局部最优解</li>
</ul>
<h3 id="算法介绍-2"><a href="#算法介绍-2" class="headerlink" title="算法介绍"></a>算法介绍</h3><p>贪心算法又称贪婪算法，是所有算法中最简单、最易实现的一种算法。</p>
<p>一个问题通常对应有多种算法，每种算法由多个步骤组成。贪心算法解决问题的核心思想是：算法的每一步都选择当前场景中最优的解决方案（又称局部最优解）。</p>
<p>举个例子，假设我们有面值分别为 1、2、5、10 的硬币，要求用尽可能少的硬币拼凑出的总面值为 18。如果采用贪心算法解决此问题，则解决方案为：</p>
<ol>
<li>选择一个面值为 10 的硬币，可最大程度解决问题，剩余需要拼凑的面值数为 8；</li>
<li>选择一个面值为 5 的硬币，可最大程度解决问题，剩余需要拼凑的面值数为 3；</li>
<li>选择一个面值为 2 的硬币，可最大程度解决问题，剩余需要拼凑的面值数为 1；</li>
<li>选择一个面值为 1 的硬币。</li>
</ol>
<p>贪心算法每一步都选择的是当前所允许的最大面值的硬币（即局部最优解），整个解决方案也是最优的。</p>
<p>注意，贪心算法并不是在任何场景中都可以得出最优的解决方案。比如，有面值分别为 1、7、10 的硬币，要求用尽可能少的硬币拼凑出的总面值为 15。如果采用贪心算法，则解决方案为：</p>
<ol>
<li>选择一个面值为 10 的硬币，剩余面值为 5；</li>
<li>选择一个面值为 1 的硬币，剩余面值为 4；</li>
<li>选择一个面值为 1 的硬币，剩余面值为 3；</li>
<li>选择一个面值为 1 的硬币，剩余面值为 2；</li>
<li>选择一个面值为 1 的硬币，剩余面值为 1；</li>
<li>选择一个面值为 1 的硬币。</li>
</ol>
<p>贪心算法使用了“10+1+1+1+1+1”共 6 枚硬币，但实际上，最优的解决方案只需要“7+7+1”共 3 枚硬币。所以，贪心算法追求的是局部最优解，它并不关心设计的整个解决方案是否最优。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">target = <span class="number">18</span></span><br><span class="line">price = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">10</span>]</span><br><span class="line"></span><br><span class="line">price.sort(reverse=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line">count = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> target &gt; <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">if</span> price[i] &lt;= target:</span><br><span class="line">        target -= price[i]</span><br><span class="line">        print(<span class="string">&#x27;the %d take:%d&#x27;</span> % (count, price[i]))</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="算法运用-2"><a href="#算法运用-2" class="headerlink" title="算法运用"></a>算法运用</h3><p>贪心算法可用于解决很多实际问题，例如：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.biancheng.net/algorithm/fractional-knapsack.html">部分背包问题</a>；</li>
<li>使用<a target="_blank" rel="noopener" href="https://www.biancheng.net/algorithm/kruskal.html">克鲁斯卡尔算法</a>求最小生成树；</li>
<li>使用<a target="_blank" rel="noopener" href="https://www.biancheng.net/algorithm/dijkstra.html">迪杰斯特拉算法</a>求两个顶点之间的最短路径。</li>
</ul>
<h2 id="Dynamic-Programming"><a href="#Dynamic-Programming" class="headerlink" title="Dynamic Programming"></a>Dynamic Programming</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><ol>
<li><p>画表，明确dp[i]与dp[i-1]代表的是什么</p>
</li>
<li><p>初始化dp[0]=[0]…</p>
</li>
<li><p>考虑状态转移方程</p>
<p>一般为dp[i] = max/min(dp[i-1], fun(dp[i-1], dp_temp[i]))</p>
</li>
</ol>
<p><strong>即是否考虑此物品的收益</strong></p>
<p>​    4.完善选此物品和不选此物品的方程即【3】中的方程式</p>
<h3 id="算法介绍-3"><a href="#算法介绍-3" class="headerlink" title="算法介绍"></a>算法介绍</h3><p>和分治算法类似，动态规划算法也是先将问题分解成多个规模更小、更容易解决的小问题，通过解决这些小问题，从而找到解决整个问题的方法。<strong>不同之处在于，分治算法分解的每个小问题都是相互独立的，而动态规划算法分解的小问题之间往往存在关联，比如要想解决问题 A 和问题 B，必须先解决问题 C。</strong></p>
<p>讲解贪心算法时，我们举过一个例子：假设有 3 种面值分别为 1、7 和 10 的硬币，要求用尽可能少的硬币拼凑出的总面值为 15。贪心算法的解决方案为共需要 6 枚硬币（10+1+1+1+1+1），但如果采用动态规划算法，可以找到更优的解决方案，只需要 3 枚硬币（ 7+7+1）。</p>
<p>动态规划算法的解题思路是：用 f(n) 表示凑齐面值为 n 所需要的最少的硬币数量，则面值 15 的拼凑方案有以下 3 种：</p>
<ul>
<li>f(15) = f(14) +1：选择一枚面值为 1 的硬币，f(14) 表示拼凑出面值 14 所需要的最少的硬币数量；</li>
<li>f(15) = f(8) + 1：选择一枚面值为 7 的硬币，f(8) 表示拼凑出面值 8 所需要的最少的硬币数量；</li>
<li>f(15) = f(5) + 1：选择一枚面值为10 的硬币，f(5) 表示拼凑出面值 5 所需要的最少的硬币数量。</li>
</ul>
<p>由此，我们将求 f(15) 的值，转换成为了求 min( f(14) , f(8) , f(5) ) 的值（min() 表示取三者中的最小值）。在此基础上，f(14)、f(8)、f(5) 还可以分解为更小的问题：</p>
<ul>
<li>f(5) = f(4) + 1；</li>
<li>f(8) = f(7) + 1 = f(1) +1；</li>
<li>f(14) = f(13)+1 = f(7) + 1 = f(4) +1。</li>
</ul>
<p>通过不断地分解，问题的规模会不断地减小，直至分解为 f(0) 或 f(1) 这类很简单的子问题。也就是说，我们只需要求得 f(0) 和f(1) 的值，所有小问题都可以得到解决（如表 1 所示）。</p>
<table>
<thead>
<tr>
<th align="center">子问题</th>
<th align="center">分解方案</th>
<th align="center">最佳方案</th>
<th align="center">硬币数量</th>
</tr>
</thead>
<tbody><tr>
<td align="center">f(0)</td>
<td align="center">不可再分</td>
<td align="center">不选择任何硬币</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">f(1)</td>
<td align="center">f(0) + 1</td>
<td align="center">“1”</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">f(2)</td>
<td align="center">f(1) + 1</td>
<td align="center">“1+1”</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">f(3)</td>
<td align="center">f(2) + 1</td>
<td align="center">“1+1+1”</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">f(4)</td>
<td align="center">f(3) + 1</td>
<td align="center">“1+1+1+1”</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center">f(5)</td>
<td align="center">f(4) + 1</td>
<td align="center">“1+1+1+1+1”</td>
<td align="center">5</td>
</tr>
<tr>
<td align="center">f(6)</td>
<td align="center">f(5) + 1</td>
<td align="center">“1+1+1+1+1+1”</td>
<td align="center">6</td>
</tr>
<tr>
<td align="center">f(7)</td>
<td align="center">f(6) + 1 , f(0) + 1</td>
<td align="center">“7”</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">f(8)</td>
<td align="center">f(7) + 1 , f(1) + 1</td>
<td align="center">“7+1”</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">f(9)</td>
<td align="center">f(8) + 1 , f(2) + 1</td>
<td align="center">“7+1+1”</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">f(10)</td>
<td align="center">f(9) + 1 , f(3) + 1 , f(0) + 1</td>
<td align="center">“10”</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">f(11)</td>
<td align="center">f(10) + 1 , f(4) + 1 , f(1) + 1</td>
<td align="center">“10+1”</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">f(12)</td>
<td align="center">f(11) + 1 , f(5) + 1 , f(2) + 1</td>
<td align="center">“10+1+1”</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">f(13)</td>
<td align="center">f(12) + 1 , f(6) + 1 , f(3) + 1</td>
<td align="center">“10+1+1+1”</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center">f(14)</td>
<td align="center">f(13) + 1 , f(7) + 1 , f(4) + 1</td>
<td align="center">“7+7”</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">f(15)</td>
<td align="center">f(14) + 1 , f(8) + 1 , f(5) + 1</td>
<td align="center">“7+7+1”</td>
<td align="center">3</td>
</tr>
</tbody></table>
<p>表 1 中借助 f(0) 和 f(1) 的值，依次推导出了 f(2)~f(15) 的值。因此，我们可以很容易得出“拼凑总面值为 15 只需要 7+7+1 共 3 个硬币”的最佳解决方案，这样解决问题的方法就称为动态规划算法。</p>
<h3 id="算法运用-3"><a href="#算法运用-3" class="headerlink" title="算法运用"></a>算法运用</h3><p>如下给您列举了几个适合采用动态规划算法解决的经典案例：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.biancheng.net/algorithm/01_knapsack.html">0-1背包问题</a>；</li>
<li><a target="_blank" rel="noopener" href="https://www.biancheng.net/algorithm/floyd-warshall.html">弗洛伊德算法</a>解决最短路径问题；</li>
<li>最长公共子序列问题；</li>
</ul>
<hr>
<p><strong>经典算法题</strong></p>
<hr>
<h2 id="N皇后问题-回溯-递归"><a href="#N皇后问题-回溯-递归" class="headerlink" title="N皇后问题[回溯+递归]"></a>N皇后问题[回溯+递归]</h2><h3 id="问题介绍"><a href="#问题介绍" class="headerlink" title="问题介绍"></a>问题介绍</h3><p>在国际象棋中，皇后是整个棋盘上实力最强的一种棋子，可以直走、横走和斜着走（沿 45 ° 角移动），可以攻击行走路线上的任何棋子。</p>
<p>N 皇后问题就源自国际象棋，它研究的是：如何将 N 个皇后摆放在 N*N 的棋盘中，使它们不能相互攻击。也就是说，棋盘上各个皇后无论直走、横走还是斜着走，都无法相互攻击。</p>
<p>举个例子，如下在 4*4 的棋盘中摆放了 4 个皇后，它们都用 Q 来表示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/20210708213932.png"></p>
<h3 id="问题思路"><a href="#问题思路" class="headerlink" title="问题思路"></a>问题思路</h3><p>显然要想使各个皇后不相互攻击，应保证它们不位于同一行（或者同一列）。借助<a target="_blank" rel="noopener" href="https://www.biancheng.net/algorithm/backtracking.html">回溯</a>算法，我们可以逐一测试出每一行皇后所在的位置，最终得出 N 皇后问题的解决方案。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">count = <span class="number">0</span>    <span class="comment">#统计解决方案的个数</span></span><br><span class="line">q = [<span class="number">0</span>]*<span class="number">20</span>   <span class="comment">#记录各个皇后的放置位置，最终放置 20 个皇后</span></span><br><span class="line"><span class="comment">#输出 N 皇后问题的解决方案</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">display</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">global</span> count</span><br><span class="line">    count = count + <span class="number">1</span></span><br><span class="line">    print(<span class="string">&quot;输出第%d个解：&quot;</span> % (count))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span> , n + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span> , n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> q[i] != j:</span><br><span class="line">                print(<span class="string">&quot;x&quot;</span>,end=<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                print(<span class="string">&quot;Q&quot;</span>,end=<span class="string">&quot; &quot;</span>);</span><br><span class="line">        print()</span><br><span class="line">    print()</span><br><span class="line"><span class="comment">#检验第k行的第j列是否可以摆放皇后</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isSafe</span>(<span class="params">k , j</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span> , k):</span><br><span class="line">        <span class="comment">#如果有其它皇后位置同一列上，或者位于该位置的斜线位置上，则该位置无法使用</span></span><br><span class="line">        <span class="keyword">if</span> q[i] == j <span class="keyword">or</span> <span class="built_in">abs</span>(i - k) == <span class="built_in">abs</span>(q[i] - j):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"><span class="comment">#放置皇后到棋盘上</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">n_queens</span>(<span class="params">k , n</span>):</span></span><br><span class="line">    <span class="keyword">if</span> k &gt; n:      <span class="comment">#递归的出口</span></span><br><span class="line">        display(n)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span> , n + <span class="number">1</span>): <span class="comment">#试探第k行的每一列，找到符合要求的列</span></span><br><span class="line">            <span class="keyword">if</span> isSafe(k , j):</span><br><span class="line">                q[k] = j</span><br><span class="line">                n_queens(k + <span class="number">1</span> , n); <span class="comment">#在确认第 k 行皇后位置的前提下，继续测试下一行皇后的位置</span></span><br><span class="line">print(<span class="string">&quot;请输入皇后个数：&quot;</span>)</span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>());</span><br><span class="line">n_queens(<span class="number">1</span>,n)</span><br><span class="line">print(<span class="string">&quot;共有 %d 种不同的排列&quot;</span> % (count))</span><br></pre></td></tr></table></figure>

<h2 id="迷宫问题-回溯-递归"><a href="#迷宫问题-回溯-递归" class="headerlink" title="迷宫问题[回溯+递归]"></a>迷宫问题[回溯+递归]</h2><h3 id="问题介绍-1"><a href="#问题介绍-1" class="headerlink" title="问题介绍"></a>问题介绍</h3><p>假设有一个 N*N 的正方形迷宫（如图 1 所示），老鼠必须从起始点移动到终点，它可以向上、向下、向左、向右移动，但仅限于在白色区域内移动。</p>
<p><img src="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/20210708164837.png"></p>
<p>回溯算法可以很好地解决类似的迷宫问题，该算法能够从起点开始，逐一测试所有的移动路线，并最终找到能够达到终点的移动路线。</p>
<h3 id="问题思路-1"><a href="#问题思路-1" class="headerlink" title="问题思路"></a>问题思路</h3><p>通过使用回溯不断“试错”，直到找出最优路径</p>
<p>假设迷宫中可行走的白色区域用 1 表示， 不能行走的黑色区域用 0 表示，图 1 的迷宫可以用如下的矩阵表示：</p>
<p>1 0 1 1 1<br>1 1 1 0 1<br>1 0 0 1 1<br>1 0 0 1 0<br>1 0 0 1 1</p>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定地图的行数和列数</span></span><br><span class="line">ROW = <span class="number">5</span></span><br><span class="line">COL = <span class="number">5</span></span><br><span class="line"><span class="comment"># 初始化地图</span></span><br><span class="line">maze = [[<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;1&#x27;</span>],</span><br><span class="line">        [<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>],</span><br><span class="line">        [<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;1&#x27;</span>],</span><br><span class="line">        [<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;0&#x27;</span>],</span><br><span class="line">        [<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;1&#x27;</span>]]</span><br><span class="line"><span class="comment"># 假设当前迷宫中没有起点到终点的路线</span></span><br><span class="line">find = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 回溯算法查找可行路线</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maze_puzzle</span>(<span class="params">maze, row, col, outrow, outcol</span>):</span></span><br><span class="line">    <span class="keyword">global</span> find</span><br><span class="line">    maze[row][col] = <span class="string">&#x27;Y&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> row == outrow <span class="keyword">and</span> col == outcol:</span><br><span class="line">        find = <span class="literal">True</span></span><br><span class="line">        print(<span class="string">&quot;成功走出迷宫,路线图为：&quot;</span>)</span><br><span class="line">        printmaze(maze)</span><br><span class="line">    <span class="keyword">if</span> canMove(maze, row-<span class="number">1</span>, col):</span><br><span class="line">        maze_puzzle(maze, row - <span class="number">1</span>, col, outrow, outcol)</span><br><span class="line">    <span class="comment"># 如果程序不结束，表明此路不通，恢复该区域的标记</span></span><br><span class="line">        maze[row - <span class="number">1</span>][col] = <span class="string">&#x27;1&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> canMove(maze, row, col - <span class="number">1</span>):</span><br><span class="line">        maze_puzzle(maze, row, col - <span class="number">1</span>, outrow, outcol)</span><br><span class="line">    <span class="comment"># 如果程序不结束，表明此路不通，恢复该区域的标记</span></span><br><span class="line">        maze[row][col - <span class="number">1</span>] = <span class="string">&#x27;1&#x27;</span></span><br><span class="line">    <span class="comment"># 尝试向下移动</span></span><br><span class="line">    <span class="keyword">if</span> canMove(maze, row + <span class="number">1</span>, col):</span><br><span class="line">        maze_puzzle(maze, row + <span class="number">1</span>, col, outrow, outcol)</span><br><span class="line">    <span class="comment"># 如果程序不结束，表明此路不通，恢复该区域的标记</span></span><br><span class="line">        maze[row + <span class="number">1</span>][col] = <span class="string">&#x27;1&#x27;</span></span><br><span class="line">    <span class="comment"># 尝试向右移动</span></span><br><span class="line">    <span class="keyword">if</span> canMove(maze, row, col + <span class="number">1</span>):</span><br><span class="line">        maze_puzzle(maze, row, col + <span class="number">1</span>, outrow, outcol)</span><br><span class="line">    <span class="comment"># 如果程序不结束，表明此路不通，恢复该区域的标记</span></span><br><span class="line">        maze[row][col + <span class="number">1</span>] = <span class="string">&#x27;1&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断指定路线是否可以行走</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">canMove</span>(<span class="params">maze, row, col</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> &lt;= row &lt;= ROW - <span class="number">1</span> <span class="keyword">and</span> <span class="number">0</span> &lt;= col &lt;= COL - <span class="number">1</span> <span class="keyword">and</span> maze[row][col] != <span class="string">&#x27;0&#x27;</span> <span class="keyword">and</span> maze[row][col] != <span class="string">&#x27;Y&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出行走路线</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printmaze</span>(<span class="params">maze</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, ROW):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, COL):</span><br><span class="line">            print(maze[i][j], end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">        print(end=<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">maze_puzzle(maze, <span class="number">0</span>, <span class="number">0</span>, ROW-<span class="number">1</span>, COL-<span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> find <span class="keyword">is</span> <span class="literal">False</span>:</span><br><span class="line">    print(<span class="string">&quot;未找到可行路线&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="部分背包问题-贪婪算法"><a href="#部分背包问题-贪婪算法" class="headerlink" title="部分背包问题[贪婪算法]"></a>部分背包问题[贪婪算法]</h2><h3 id="问题介绍-2"><a href="#问题介绍-2" class="headerlink" title="问题介绍"></a>问题介绍</h3><p>背包问题指的是在背包所能承受的重量范围内，将哪些物品装入背包可以获得最大的收益？</p>
<p>举个例子，一个小偷正在商店行窃，他随身携带的背包可以装一定重量的商品，商店中摆放着不同重量和价值的商品，小偷应该如何选择才能获得最大的收益？这样的问题就属于背包问题。</p>
<p>根据所选物品是否可再分（比如选择某物品的 1/2），背包问题可分为以下两种：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.biancheng.net/algorithm/01_knapsack.html">0-1 背包问题</a>：挑选物品时，单个物品要么放弃，要么全部装入背包，不存在“装入 1/2 物品”的情况；</li>
<li>部分背包问题：挑选物品时，单个物品可再分，例如将物品的 1/2 装入背包。</li>
</ul>
<p>本节给您讲解的是如何使用贪心算法解决部分背包问题。</p>
<h3 id="问题思路-2"><a href="#问题思路-2" class="headerlink" title="问题思路"></a>问题思路</h3><p>接下来以“小偷在商店行窃，商店的商品都可再分”为例，给您讲解如何解决部分背包问题。</p>
<p>为了方便讲解，我们做以下假设：</p>
<ul>
<li>背包最多可以承受的商品重量为 W（后续简称承重）；</li>
<li>商店共有 n 件商品，它们都是可再分的，其中第 i 件商品的总重量为 Wi，总收益为 Pi。</li>
</ul>
<p>显然，要想获得最大的收益，小偷需要做到以下 2 点：</p>
<ul>
<li>充分利用背包的承重，背包装的商品越多，获得收益就越大；</li>
<li>确保选中的 W 重量商品中，单位重量下获得的收益最大。</li>
</ul>
<p>结合以上 2 点，我们可以采用贪心算法来解决这个问题，具体的解决方案是：计算每个商品的收益率（即 Pi/Wi），优先选择收益率最大的商品，直至选择的商品总重量恰好为 W。</p>
<p>假设背包的承重为 20，商店中共有 3 种商品，它们的重量和收益分别为：</p>
<ul>
<li>商品 1：重量 10，收益 60，单位重量的收益为 6；</li>
<li>商品 2：重量 20，收益 100，单位重量的收益为 5；</li>
<li>商品 3：重量 30，收益 120，单位重量的收益为 4。</li>
</ul>
<p>通过比较收益率，以上 3 种商品装入背包的顺序依次为：商品 1 &gt; 商品 2 &gt; 商品 3。受到背包承重的限制，商品 1 可以全部装入背包，而商品 2 只能装一半（10 斤），商品 3 无法被装入。</p>
<h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">W = <span class="number">50</span></span><br><span class="line">w = [<span class="number">10</span>, <span class="number">30</span>, <span class="number">20</span>]</span><br><span class="line">p = [<span class="number">60</span>, <span class="number">100</span>, <span class="number">120</span>]</span><br><span class="line">value = <span class="number">0</span></span><br><span class="line">result = [<span class="number">0</span>] * <span class="built_in">len</span>(w)</span><br><span class="line"></span><br><span class="line">v = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(w)):</span><br><span class="line">    v.append(p[i]/w[i])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(w)):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(j+<span class="number">1</span>, <span class="built_in">len</span>(w)):</span><br><span class="line">        <span class="keyword">if</span> v[j] &lt; v[i]:</span><br><span class="line">            v[j], v[i] = v[i], v[j]</span><br><span class="line">            w[j], w[i] = w[i], w[j]</span><br><span class="line">            p[j], p[i] = p[i], p[j]</span><br><span class="line"></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> W &gt; <span class="number">0</span>:</span><br><span class="line">    temp = <span class="built_in">min</span>(W, w[i])</span><br><span class="line">    result[i] = temp / w[i]</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line">    W -= temp</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(result)):</span><br><span class="line">    <span class="keyword">if</span> result[i] == <span class="number">1</span>:</span><br><span class="line">        print(<span class="string">&#x27;weight:%f, total value:%f--&gt;100%%&#x27;</span> % (w[i], p[i]))</span><br><span class="line">        value += p[i]</span><br><span class="line">    <span class="keyword">elif</span> result[i] == <span class="number">0</span>:</span><br><span class="line">        print(<span class="string">&#x27;weight:%f, total value:%f--&gt;0%%&#x27;</span> % (w[i], p[i]))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">&#x27;weight:%f, total value:%f--&gt;%f&#x27;</span> % (w[i], p[i], result[i]*<span class="number">100</span>))</span><br><span class="line">        value += p[i]*result[i]</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;the total value:%f&#x27;</span> % value)</span><br></pre></td></tr></table></figure>

<h2 id="01背包问题-动态规划"><a href="#01背包问题-动态规划" class="headerlink" title="01背包问题[动态规划]"></a>01背包问题[动态规划]</h2><h3 id="问题介绍-3"><a href="#问题介绍-3" class="headerlink" title="问题介绍"></a>问题介绍</h3><p>仍以小偷在商店行窃为例，他随身携带的背包可以装一定重量的商品，商店中摆放着不同重量和价值的商品，小偷如何选择能获得最大的收益？在 01背包问题中，每种商品都是不可再分的，小偷在选择商品时，要么装入整个商品，要么放弃装该商品，不存在“装某商品的 1/2”的情况。</p>
<p>贪心算法仅适用于解决部分背包问题，不再适合解决 01背包问题。举个例子，假设商店摆放着以下几种商品：</p>
<ul>
<li>商品 1 ：重量为 6，收益为 6；</li>
<li>商品 2 ：重量为 2，收益为 4；</li>
<li>商品 3 ：重量为 3，收益为 4；</li>
<li>商品 4 ：重量为 5，收益为 3。</li>
</ul>
<p>假设背包可容纳商品的最大重量为 7，如果采用贪心算法，首先会选取收益最大的商品 1，此时背包的剩余承重为 1，无法再装下其他商品，因此最终获得的收益为 6。实际上还有一种更好的解决方案，即选择装入商品 2 和商品 3，总重量为 5（&lt;7），总收益为 4 + 4 = 8。</p>
<p>显然，贪心算法不再适用于解决 01背包问题，解决此问题可以使用<a target="_blank" rel="noopener" href="https://www.biancheng.net/algorithm/dynamic-programming.html">动态规划算法</a>。</p>
<h3 id="问题思路-3"><a href="#问题思路-3" class="headerlink" title="问题思路"></a>问题思路</h3><p>假设背包可以承受的最大重量为 11，商店有 5 种商品，它们的重量和价值分别为：</p>
<p>wi 表示第 i 种商品的重量，vi 表示第 i 种商品的价值<br>w1 = 1，v1 = 1<br>w2 = 2，v2 = 6<br>w3 = 5，v3 = 18<br>w4 = 6，v4 = 22<br>w5 = 7，v5 = 28</p>
<p>采用动态规划算法解决此问题的具体过程是：</p>
<ol>
<li>从背包所能承受的最大重量为 1 开始，依次推导出各个承重条件下所能获得的最大收益。</li>
</ol>
<p>建立如下这张表格，逐一分析出各个载重量下每一个商品装与不装对收益值的影响，从而获得各个载重量对应的最大收益值。</p>
<table>
<thead>
<tr>
<th>背包载重量</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
<th>11</th>
</tr>
</thead>
<tbody><tr>
<td>w1 = 1，v1 = 1</td>
<td>0</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>w2 = 2，v2 = 6</td>
<td>0</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>w3 = 5，v3 = 18</td>
<td>0</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>w4 = 6，v4 = 22</td>
<td>0</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>w5 = 7，v5 = 28</td>
<td>0</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><strong>当背包载重量为 0 时，无法装入各个商品，因此收益一直为 0。</strong></p>
<ol start="2">
<li>首先考虑商品 (w1 , v1)，当背包载重量分别为 1、2、…、11 时，都可以装入此商品，且和不装该商品相比（背包是空的），装该商品的收益更大，因此对上表进行更新：</li>
</ol>
<table>
<thead>
<tr>
<th>背包载重量</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
<th>11</th>
</tr>
</thead>
<tbody><tr>
<td>w1 = 1，v1 = 1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>w2 = 2，v2 = 6</td>
<td>0</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>w3 = 5，v3 = 18</td>
<td>0</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>w4 = 6，v4 = 22</td>
<td>0</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>w5 = 7，v5 = 28</td>
<td>0</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<ol start="3">
<li>再分析商品 (w2，v2)：</li>
</ol>
<ul>
<li><p>载重量为 1 时：w2&gt;1，无法装入该商品，最大收益仍为 1。</p>
</li>
<li><p>载重量为 2 时：背包可以装入此商品，装入此商品对应的总收益可以用 6+f(0) 表示，其中 f(0) 指的是载重量为 0 时装 (w1,v1) 对应的最佳收益。从上表可知，f(0) = 0，因此 6+f(0)=6，比先前只装 (w1 , v1) 的收益大。</p>
</li>
<li><p>载重量为 3 时：背包可以装入此商品，装入此商品对应的总收益可以用 6+f(1) 表示，f(1) 指的是载重量为 1 时装 (w1 , v1) 对应的最佳收益。从上表可知，f(1) = 1，因此 6+f(1) = 7，比先前只装 (w1 , v1) 的收益大。</p>
</li>
<li><p>载重量为 4~11：背包可以装入此商品，且装此商品的收益总比不装时的大，总收益都为 7。 </p>
<p>继续对表格进行更新：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>背包载重量</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
<th>11</th>
</tr>
</thead>
<tbody><tr>
<td>w1 = 1，v1 = 1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>w2 = 2，v2 = 6</td>
<td>0</td>
<td>1</td>
<td>6</td>
<td>7</td>
<td>7</td>
<td>7</td>
<td>7</td>
<td>7</td>
<td>7</td>
<td>7</td>
<td>7</td>
<td>7</td>
</tr>
<tr>
<td>w3 = 5，v3 = 18</td>
<td>0</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>w4 = 6，v4 = 22</td>
<td>0</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>w5 = 7，v5 = 28</td>
<td>0</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<ol start="4">
<li>再分析商品 (w3 , v3)：</li>
</ol>
<ul>
<li>载重量为 1 时：w3&gt;1，无法装入该商品，最大收益仍为 1。</li>
<li>载重量为 2 时：w3&gt;1，无法装入该商品，最大收益仍为 6。</li>
<li>载重量为 3~4 时：w3&gt;1，无法装入该商品，最大收益仍为 7。</li>
<li>载重量为 5：背包可以装入此商品，且装此商品的总收益可以用 18+f(0) 表示，f(0) 指的是载重量为 0 时装 (w2 , v2) 对应的最佳收益。从上表可知，f(0) = 0，因此 18+f(0) = 18，比先前统计的收益值更高。</li>
<li>载重量为 6：背包可以装入此商品，且装此商品的总收益可以用 18+f(1) 表示，f(1) 指的是载重量为 1 时装 (w2 , v2) 对应的最佳收益。从上表可知，f(1) = 1，因此 18+f(1) = 19，比先前统计的收益值更高。</li>
<li>载重量为 7：背包可以装入此商品，且装此商品的总收益可以用 18+f(2) 表示，f(2) 指的是载重量为 2 时装 (w2 , v2) 对应的最佳收益。从上表可知，f(2) = 6，因此 18+f(2) = 24，比先前统计的收益值更高。</li>
<li>根据此规律可以依次求得载重量分别为 8、9、…、11 时，对应的总收益为 25。</li>
</ul>
<p>继续对表格进行更新：</p>
<table>
<thead>
<tr>
<th>背包载重量</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
<th>11</th>
</tr>
</thead>
<tbody><tr>
<td>w1 = 1，v1 = 1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>w2 = 2，v2 = 6</td>
<td>0</td>
<td>1</td>
<td>6</td>
<td>7</td>
<td>7</td>
<td>7</td>
<td>7</td>
<td>7</td>
<td>7</td>
<td>7</td>
<td>7</td>
<td>7</td>
</tr>
<tr>
<td>w3 = 5，v3 = 18</td>
<td>0</td>
<td>1</td>
<td>6</td>
<td>7</td>
<td>7</td>
<td>18</td>
<td>19</td>
<td>24</td>
<td>25</td>
<td>25</td>
<td>25</td>
<td>25</td>
</tr>
<tr>
<td>w4 = 6，v4 = 22</td>
<td>0</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>w5 = 7，v5 = 28</td>
<td>0</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<ol start="5">
<li>借助 (w3 , v3) 的收益数据，我们可以继续推导出不同载重量对应的 (w4 , v4) 商品的收益值；同理借助 (w4 , v4) 的收益数据，可以推导出不同载重量对应的 (w5 , v5) 商品的收益值。推导结果如下所示：</li>
</ol>
<table>
<thead>
<tr>
<th align="center">背包载重量</th>
<th align="center">0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
<th>11</th>
</tr>
</thead>
<tbody><tr>
<td align="center">w1 = 1，v1 = 1</td>
<td align="center">0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td align="center">w2 = 2，v2 = 6</td>
<td align="center">0</td>
<td>1</td>
<td>6</td>
<td>7</td>
<td>7</td>
<td>7</td>
<td>7</td>
<td>7</td>
<td>7</td>
<td>7</td>
<td>7</td>
<td>7</td>
</tr>
<tr>
<td align="center">w3 = 5，v3 = 18</td>
<td align="center">0</td>
<td>1</td>
<td>6</td>
<td>7</td>
<td>7</td>
<td>18</td>
<td>19</td>
<td>24</td>
<td>25</td>
<td>25</td>
<td>25</td>
<td>25</td>
</tr>
<tr>
<td align="center">w4 = 6，v4 = 22</td>
<td align="center">0</td>
<td>1</td>
<td>6</td>
<td>7</td>
<td>7</td>
<td>18</td>
<td>22</td>
<td>24</td>
<td>28</td>
<td>29</td>
<td>29</td>
<td>40</td>
</tr>
<tr>
<td align="center">w5 = 7，v5 = 28</td>
<td align="center">0</td>
<td>1</td>
<td>6</td>
<td>7</td>
<td>7</td>
<td>18</td>
<td>22</td>
<td>28</td>
<td>29</td>
<td>34</td>
<td>35</td>
<td>40</td>
</tr>
</tbody></table>
<p>因此借助动态规划算法，当背包的载重量为 11 时，获得的最大收益为 40。</p>
<h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">N = <span class="number">5</span>       <span class="comment"># 设定商品的种类</span></span><br><span class="line">W = <span class="number">11</span>      <span class="comment"># 设定背包的最大载重量</span></span><br><span class="line">w = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]    <span class="comment"># 商品的载重，不使用 w[0]</span></span><br><span class="line">v = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">18</span>, <span class="number">22</span>, <span class="number">28</span>]   <span class="comment"># 商品的价值，不使用 v[0]</span></span><br><span class="line"><span class="comment"># 二维列表，记录统计数据</span></span><br><span class="line">result = [[<span class="number">0</span>]*(W+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(w))]</span><br><span class="line"><span class="comment"># 动态规划算法解决01背包问题</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 逐个遍历每个商品</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, N+<span class="number">1</span>):</span><br><span class="line">    <span class="comment"># 求出从 1 到 W 各个载重对应的最大收益</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, W+<span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 如果背包载重小于商品总重量，则该商品无法放入背包，收益不变</span></span><br><span class="line">        <span class="keyword">if</span> j &lt; w[i]:</span><br><span class="line">            result[i][j] = result[i-<span class="number">1</span>][j]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 比较装入该商品和不装该商品，哪种情况获得的收益更大，记录最大收益值</span></span><br><span class="line">            result[i][j] = <span class="built_in">max</span>(result[i-<span class="number">1</span>][j], v[i]+result[i-<span class="number">1</span>][j-w[i]])</span><br><span class="line">print(result)</span><br><span class="line">print(<span class="string">&quot;背包可容纳重量为 %d,最大收益为 %d&quot;</span> % (W, result[N][W]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 追溯选中的商品</span></span><br><span class="line">n = N</span><br><span class="line">bagw = W</span><br><span class="line"><span class="comment"># 逐个商品进行判断</span></span><br><span class="line">print(<span class="string">&quot;所选商品为:&quot;</span>)</span><br><span class="line"><span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">    <span class="comment"># 如果在指定载重量下，该商品对应的收益和上一个商品对应的收益相同，则表明未选中</span></span><br><span class="line">    <span class="keyword">if</span> result[n][bagw] == result[n-<span class="number">1</span>][bagw]:</span><br><span class="line">        n = n - <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 输出被选用商品的重量和价值</span></span><br><span class="line">        print(<span class="string">&quot;(%d,%d) &quot;</span> % (w[n], v[n]))</span><br><span class="line">        <span class="comment"># 删除被选用商品的载重量，以便继续遍历</span></span><br><span class="line">        bagw = bagw - w[n]</span><br><span class="line">        n = n - <span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/20210708163344.png"></p>
<p>简化后的code</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">N = <span class="number">5</span></span><br><span class="line">W = <span class="number">11</span></span><br><span class="line">w = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line">v = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">18</span>, <span class="number">22</span>, <span class="number">28</span>]</span><br><span class="line"></span><br><span class="line">result = [[<span class="number">0</span>]*(W+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(N+<span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, N+<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, W+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> j &lt; w[i]:</span><br><span class="line">            result[i][j] = result[i-<span class="number">1</span>][j]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result[i][j] = <span class="built_in">max</span>(result[i-<span class="number">1</span>][j], v[i]+result[i-<span class="number">1</span>][j-w[i]])</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;bag`s weight:%d, total value:%d&#x27;</span> % (W, result[N][W]))</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;The selected products are:&#x27;</span>)</span><br><span class="line">n = N</span><br><span class="line">bagw = W</span><br><span class="line"><span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">if</span> result[n][bagw] == result[n-<span class="number">1</span>][bagw]:</span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">&#x27;(&#123;&#125;, &#123;&#125;)&#x27;</span>.<span class="built_in">format</span>(w[n], v[n]))</span><br><span class="line">        bagw -= w[n]</span><br><span class="line">        n -= <span class="number">1</span></span><br></pre></td></tr></table></figure>



<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><ol>
<li>一般情况下使用index进行列表的切分比使用[:]–&gt;[start:end)的时间复杂度更低，效率也更高O(1）&lt;–&gt;O（n）</li>
<li>对于具有特殊意义的index一般追踪起来比较困难，我们选择直接再terminal中return对应的information而不是return index</li>
</ol>
<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><h2 id="Dictionary"><a href="#Dictionary" class="headerlink" title="Dictionary"></a>Dictionary</h2><h2 id="Tuple"><a href="#Tuple" class="headerlink" title="Tuple"></a>Tuple</h2><h2 id="Linked-List"><a href="#Linked-List" class="headerlink" title="Linked List"></a>Linked List</h2><p>使用指针(pointer)</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://drinkle.top/2021/05/23/Framework-Thinking/" data-id="ckp1cbb4x0000ukf5cn4v72te" data-title="Framework-Thinking" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/consciousness/" rel="tag">consciousness</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2021/06/06/Python-BuiltIn/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">前一篇</strong>
      <div class="article-nav-title">
        
          Python-BuiltIn
        
      </div>
    </a>
  
  
    <a href="/2021/05/15/Python-Underlying-Structure/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">后一篇</strong>
      <div class="article-nav-title">Python-Underlying-Structure</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/825%E8%AE%A1%E5%88%92/" rel="tag">825计划</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Algorithm/" rel="tag">Algorithm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/BuiltIn/" rel="tag">BuiltIn</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Daily-Plan/" rel="tag">Daily Plan</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DataBase/" rel="tag">DataBase</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/English-Study/" rel="tag">English Study</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GoodNotes/" rel="tag">GoodNotes</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hexo/" rel="tag">Hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LeeCode/" rel="tag">LeeCode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mongodb/" rel="tag">Mongodb</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Object-Oriented/" rel="tag">Object Oriented</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Postgraduate/" rel="tag">Postgraduate</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/" rel="tag">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python%E5%90%8E%E7%AB%AF/" rel="tag">Python后端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spirit/" rel="tag">Spirit</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/consciousness/" rel="tag">consciousness</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/django/" rel="tag">django</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/source-code/" rel="tag">source-code</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%96%E7%95%8C%E8%A7%82/" rel="tag">世界观</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%96%E7%95%8C%E8%A7%82-%E6%96%B9%E6%B3%95%E8%AE%BA/" rel="tag">世界观 方法论</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AE%9E%E8%B7%B5/" rel="tag">实践</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B7%A6%E7%BF%BC%E5%90%8C%E7%9B%9F%E4%BC%9A/" rel="tag">左翼同盟会</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%96%B0%E9%97%BB%E8%81%94%E6%92%AD/" rel="tag">新闻联播</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%8B%AC%E5%88%B0%E7%A7%91%E6%8A%80/" rel="tag">独到科技</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%87%B4%E4%BD%A0%E7%9A%84%E4%B8%80%E5%B0%81%E4%BF%A1/" rel="tag">致你的一封信</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/825%E8%AE%A1%E5%88%92/" style="font-size: 10px;">825计划</a> <a href="/tags/Algorithm/" style="font-size: 10px;">Algorithm</a> <a href="/tags/BuiltIn/" style="font-size: 10px;">BuiltIn</a> <a href="/tags/Daily-Plan/" style="font-size: 10px;">Daily Plan</a> <a href="/tags/DataBase/" style="font-size: 10px;">DataBase</a> <a href="/tags/English-Study/" style="font-size: 20px;">English Study</a> <a href="/tags/GoodNotes/" style="font-size: 10px;">GoodNotes</a> <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/LeeCode/" style="font-size: 10px;">LeeCode</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/Mongodb/" style="font-size: 10px;">Mongodb</a> <a href="/tags/MySQL/" style="font-size: 10px;">MySQL</a> <a href="/tags/Object-Oriented/" style="font-size: 10px;">Object Oriented</a> <a href="/tags/Postgraduate/" style="font-size: 10px;">Postgraduate</a> <a href="/tags/Python/" style="font-size: 15px;">Python</a> <a href="/tags/Python%E5%90%8E%E7%AB%AF/" style="font-size: 10px;">Python后端</a> <a href="/tags/Spirit/" style="font-size: 10px;">Spirit</a> <a href="/tags/consciousness/" style="font-size: 10px;">consciousness</a> <a href="/tags/django/" style="font-size: 10px;">django</a> <a href="/tags/source-code/" style="font-size: 10px;">source-code</a> <a href="/tags/%E4%B8%96%E7%95%8C%E8%A7%82/" style="font-size: 15px;">世界观</a> <a href="/tags/%E4%B8%96%E7%95%8C%E8%A7%82-%E6%96%B9%E6%B3%95%E8%AE%BA/" style="font-size: 10px;">世界观 方法论</a> <a href="/tags/%E5%AE%9E%E8%B7%B5/" style="font-size: 10px;">实践</a> <a href="/tags/%E5%B7%A6%E7%BF%BC%E5%90%8C%E7%9B%9F%E4%BC%9A/" style="font-size: 10px;">左翼同盟会</a> <a href="/tags/%E6%96%B0%E9%97%BB%E8%81%94%E6%92%AD/" style="font-size: 10px;">新闻联播</a> <a href="/tags/%E7%8B%AC%E5%88%B0%E7%A7%91%E6%8A%80/" style="font-size: 10px;">独到科技</a> <a href="/tags/%E8%87%B4%E4%BD%A0%E7%9A%84%E4%B8%80%E5%B0%81%E4%BF%A1/" style="font-size: 10px;">致你的一封信</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">八月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">七月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">六月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">五月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">四月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">三月 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/08/29/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86/">数据库索引原理</a>
          </li>
        
          <li>
            <a href="/2021/08/28/Mongodb/">Mongodb</a>
          </li>
        
          <li>
            <a href="/2021/08/25/English-Study-5/">English-Study-5</a>
          </li>
        
          <li>
            <a href="/2021/08/02/%E7%8B%AC%E5%88%B0%E7%A7%91%E6%8A%80/">独到科技</a>
          </li>
        
          <li>
            <a href="/2021/07/26/%E6%AF%8F%E6%97%A5%E5%A4%8D%E7%9B%98/">每日复盘</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 Drink<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>