<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Python-Underlying-Structure | Drink`s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="Python底层结构Operators&#x2F;&#x2F;:rounding down &#x3D;&#x3D;&gt; 7&#x2F;&#x2F;2 &#x3D; 3.5 —&gt; 3 [start:end]&#x3D;&#x3D;&gt;contains start except end [1, 2, 3, 4, 5] &#x3D;&#x3D;[2:]&#x3D;&#x3D;&gt;[3, 4, 5] [1, 2, 3, 4, 5] &#x3D;&#x3D;[:2]&#x3D;&#x3D;&gt;[1, 2] [1, 2, 3, 4, 5] &#x3D;&#x3D;[1:3">
<meta property="og:type" content="article">
<meta property="og:title" content="Python-Underlying-Structure">
<meta property="og:url" content="https://drinkle.top/2021/05/15/Python-Underlying-Structure/index.html">
<meta property="og:site_name" content="Drink&#96;s Blog">
<meta property="og:description" content="Python底层结构Operators&#x2F;&#x2F;:rounding down &#x3D;&#x3D;&gt; 7&#x2F;&#x2F;2 &#x3D; 3.5 —&gt; 3 [start:end]&#x3D;&#x3D;&gt;contains start except end [1, 2, 3, 4, 5] &#x3D;&#x3D;[2:]&#x3D;&#x3D;&gt;[3, 4, 5] [1, 2, 3, 4, 5] &#x3D;&#x3D;[:2]&#x3D;&#x3D;&gt;[1, 2] [1, 2, 3, 4, 5] &#x3D;&#x3D;[1:3">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/20210529144951.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/20210529145101.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/20210523203737.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/20210523205439.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/20210523213913.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/20210523232121.png">
<meta property="article:published_time" content="2021-05-15T07:14:15.000Z">
<meta property="article:modified_time" content="2021-06-04T08:05:32.362Z">
<meta property="article:author" content="Drink">
<meta property="article:tag" content="Python">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/20210529144951.png">
  
    <link rel="alternate" href="/atom.xml" title="Drink`s Blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Drink`s Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://drinkle.top"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-Python-Underlying-Structure" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/15/Python-Underlying-Structure/" class="article-date">
  <time class="dt-published" datetime="2021-05-15T07:14:15.000Z" itemprop="datePublished">2021-05-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      Python-Underlying-Structure
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Python底层结构"><a href="#Python底层结构" class="headerlink" title="Python底层结构"></a>Python底层结构</h1><h2 id="Operators"><a href="#Operators" class="headerlink" title="Operators"></a>Operators</h2><p><code>//</code>:rounding down ==&gt; 7//2 = 3.5 —&gt; 3</p>
<p><code>[start:end]</code>==&gt;contains start except end</p>
<p>[1, 2, 3, 4, 5] ==[2:]==&gt;[3, 4, 5]</p>
<p>[1, 2, 3, 4, 5] ==[:2]==&gt;[1, 2]</p>
<p>[1, 2, 3, 4, 5] ==[1:3]==&gt;[2, 3]</p>
<p>split操作[start:end]==&gt;[start， end)</p>
<h2 id="BuiltIn"><a href="#BuiltIn" class="headerlink" title="BuiltIn"></a>BuiltIn</h2><h3 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h3><h4 id="dict"><a href="#dict" class="headerlink" title="dict()"></a>dict()</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__dict__ &lt;==difference==&gt; dic()</span><br></pre></td></tr></table></figure>

<p><code>__dict__与dir()</code>的区别：</p>
<ol>
<li>dir()是一个函数，返回的是list；</li>
<li><code>__dict__</code>是一个字典，键为属性名，值为属性值；</li>
<li>dir()用来寻找一个对象的所有属性，包括<code>__dict__</code>中的属性，<code>__dict__</code>是dir()的子集；</li>
<li> <strong>并不是所有对象都拥有<code>__dict__</code>属性。</strong>许多内建类型就[没有<code>__dict__</code>属性，如list，此时就需要用dir()来列出对象的所有属性。</li>
</ol>
<p><strong><code>__dict__</code>是用来存储对象属性的一个字典，其键为属性名，值为属性的值。</strong></p>
<p><strong>注意:</strong></p>
<ol>
<li><p>实例的<code>__dict__</code>仅存储与该实例相关的实例属性，</p>
<p>正是因为实例的<code>__dict__</code>属性，每个实例的实例属性才会互不影响。</p>
</li>
<li><p>类的<code>__dict__</code>存储所有实例共享的变量和函数(类属性，方法等)，类的<code>__dict__</code>并不包含其父类的属性。</p>
</li>
</ol>
<p><strong>结论：</strong></p>
<p>dir()函数会自动寻找一个对象的所有属性，包括<code>__dict__</code>中的属性。</p>
<p><code>__dict__</code>是dir()的子集，dir()包含<code>__dict__</code>中的属性。</p>
<p>dir()是Python提供的一个API函数，<strong>dir()函数会自动寻找一个对象的所有属性</strong>(包括从父类中继承的属性)。</p>
<p> 一个实例的<code>__dict__</code>属性仅仅是那个实例的实例属性的集合，并不包含该实例的所有有效属性。所以如果想获取一个对象所有有效属性，应使用dir()。</p>
<hr>
<h4 id="dir"><a href="#dir" class="headerlink" title="dir()"></a>dir()</h4><p><strong>dir()</strong> 函数不带参数时，返回当前范围内的变量、方法和定义的类型列表；带参数时，返回参数的属性、方法列表。如果参数包含方法<strong>dir</strong>()，该方法将被调用。如果参数不包含<strong>dir</strong>()，该方法将最大限度地收集参数信息。</p>
<h4 id="GET-amp-Attribute"><a href="#GET-amp-Attribute" class="headerlink" title="GET&amp;Attribute"></a>GET&amp;Attribute</h4><p>如果在类中定义了<strong>getitem</strong>()方法，那么他的实例对象（假设为P）就可以这样P[key]取值。当实例对象做P[key]运算时，就会调用类中的<strong>getitem</strong>()方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__getitem__(self,key):返回键对应的值。</span><br><span class="line"></span><br><span class="line">__setitem__(self,key,value)：设置给定键的值</span><br><span class="line"></span><br><span class="line">__delitem__(self,key):删除给定键对应的元素。</span><br><span class="line"></span><br><span class="line">__len__():返回元素的数量</span><br></pre></td></tr></table></figure>

<p>python的一切数据都是对象，包括函数、基本数据类型、自定义数据类型等等，这其中最复杂的就是对象内部存储的数据结构(引用)，包括类属性、数据描述符、实例属性及非数据描述符，不仅它们的优先级不一样，而且它们的回调函数也存在很大的差异，这也是本文需要阐述的地方。</p>
<p>如果以前有过Javascript的编程经验，初上Python肯定会对“.”运算符与“[]”之间的差异难以理解，它们不仅不能替换，而且完全不相关，如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mem = &#123;<span class="string">&#x27;username&#x27;</span>: <span class="string">&#x27;yiifaa&#x27;</span>&#125;</span><br><span class="line"><span class="comment"># 无法通过.运算符进行计算</span></span><br><span class="line">mem.username</span><br><span class="line"><span class="comment"># 声明String</span></span><br><span class="line">name = <span class="built_in">str</span>(<span class="string">&#x27;yiifaa&#x27;</span>)</span><br><span class="line"><span class="comment"># 无法使用“[]”运算符</span></span><br><span class="line">name[<span class="string">&#x27;upper&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p><strong>1. 为实例添加“[]”运算符支持</strong></p>
<p>这也是“<em>_ getattribute_</em>”与“<em>_ getitem_</em>”的最大差异，示例如下：<br>“<em>_ getattribute_</em>”只适用于所有的“.”运算符；<br>“<em>_ getitem_</em>”只适用于所有的“[]”运算符；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, username, age</span>):</span></span><br><span class="line">        self.username = username</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattribute__</span>(<span class="params">self, attr</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>(Employee, self).__getattribute__(attr)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span>(<span class="params">self, attr</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>(Employee, self).__getattribute__(attr)</span><br><span class="line"></span><br><span class="line">em = Employee(<span class="string">&#x27;yiifaa&#x27;</span>, <span class="number">32</span>)</span><br><span class="line"><span class="built_in">print</span> em.username</span><br><span class="line"><span class="comment">#   现在支持“[]”运算符</span></span><br><span class="line"><span class="built_in">print</span> em[<span class="string">&#x27;username&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>通过实现“<em>_ getitem_</em>”回调接口，现在Employee可以支持“[]”运算符。</p>
<ol start="2">
<li><strong>避免语法错误错误</strong></li>
</ol>
<p>在对象属性的调用中，如果没有调用了不存在的属性，则Python解释器会报错，如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">AttributeError: <span class="string">&#x27;str&#x27;</span> <span class="built_in">object</span> has no attribute <span class="string">&#x27;length&#x27;</span></span><br></pre></td></tr></table></figure>

<p>通过覆盖实现“<em>_ getattr_</em>”回调接口可以解决此问题，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#   直接返回空对象，将此方法添加到类Employee的声明中</span><br><span class="line">def __getattr__(self, attr):</span><br><span class="line">    return None</span><br><span class="line"></span><br><span class="line"># 现在调用不存在的属性也不会报错</span><br><span class="line">print em.company</span><br></pre></td></tr></table></figure>

<p>那“<em>_ getattribute_</em>”与“<em>_ getattr_</em>”的最大差异在于：</p>
<ol>
<li>无论调用对象的什么属性，包括不存在的属性，都会首先调用“<em>_ getattribute_</em>”方法；</li>
<li>只有找不到对象的属性时，才会调用“<em>_ getattr_</em>”方法；</li>
</ol>
<p><strong>3. 将对象作为数据描述符</strong></p>
<p>这就是“<em>_ get_</em>”的作用了，将整个对象都作为数据描述符，但是请记住<strong>，要想_ get_作为数据描述符，那么此对象只能作为类属性</strong>，作为实例属性则无效，如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dept</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">          self.name = name</span><br><span class="line"></span><br><span class="line">      <span class="comment"># target是拥有此属性的对象</span></span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">__get__</span>(<span class="params">self, target, <span class="built_in">type</span>=<span class="literal">None</span></span>):</span></span><br><span class="line">        <span class="comment"># 默认返回self与obj都可以</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Dept&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Company</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="comment">#   一定要作为类属性，作为实例属性无效</span></span><br><span class="line">    dept = Dept(<span class="string">&#x27;organ&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 现在的测试结果</span></span><br><span class="line">x = Company()</span><br><span class="line"><span class="comment">#   返回True</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">type</span>(x.dept) == <span class="built_in">str</span></span><br></pre></td></tr></table></figure>

<p><strong>4. 获取对象属性数据的三种方法</strong></p>
<p>对象的所有属性都存储在“<em>_ dict_</em>”中（启用了“<em>_ slots_</em>”除外），所以访问对象的属性数据有如下三种方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print yiifaa.name</span><br><span class="line">print yiifaa.__dict__[&#39;name&#39;]</span><br><span class="line">print getattr(yiifaa, &#39;name&#39;)</span><br></pre></td></tr></table></figure>

<p><strong>结论</strong></p>
<p>每个以“__ get”为前缀的方法都是获取对象内部数据的钩子，但名称不一样，用途也存在较大的差异，只有在实践中理解它们，才能真正掌握它们的用法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">class Examp(object):</span><br><span class="line">    def __init__(self, username, age):</span><br><span class="line">        self.username &#x3D; username</span><br><span class="line">        self.age &#x3D; age</span><br><span class="line"></span><br><span class="line">    # 1. “_ getattribute_”只适用于所有的“.”运算符；</span><br><span class="line">    def __getattribute__(self, item):</span><br><span class="line">        print(&#39;---getattribute----&#39;)</span><br><span class="line">        return super(Examp, self).__getattribute__(item)</span><br><span class="line"></span><br><span class="line">    # 2. “_ getitem_”只适用于所有的“[]”运算符；</span><br><span class="line">    def __getitem__(self, item):</span><br><span class="line">        print(&#39;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;getitem&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#39;)</span><br><span class="line">        return super(Examp, self).__getattribute__(item)</span><br><span class="line"></span><br><span class="line">    # 3. 解决了访问不存在的属性报错问题, 找不到属性时会被调用：</span><br><span class="line">    def __getattr__(self, item):</span><br><span class="line">        return None</span><br><span class="line"></span><br><span class="line">    # 4. ““__get__””作为数据描述符，那么此对象只能作为类属性，作为实例属性则无效</span><br><span class="line">    def __get__(self, instance, owner):</span><br><span class="line">        # instance 访问此描述符的对象若通过类访问则为None   ower 指所有者的类</span><br><span class="line">        # print(id(instance), id(owner),id(Obj1))</span><br><span class="line">        print(&#39;____get____&#39;)</span><br><span class="line">        return self</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">em &#x3D; Examp(&#39;xiao66&#39;, 32)</span><br><span class="line"># print(em.username) # 输出 ---getattribute----  xiao66</span><br><span class="line"># print(em[&#39;username&#39;]) # 输出 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;getitem&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; xiao66</span><br><span class="line"># print(em.length) # 输出 ---getattribute---- None</span><br><span class="line"></span><br><span class="line"># 获取对象属性的三种方法</span><br><span class="line"># print(em.username)</span><br><span class="line"># print(em.__dict__[&#39;username&#39;])</span><br><span class="line"># print(getattr(em, &#39;username&#39;))</span><br><span class="line"></span><br><span class="line"># __get__ 作用</span><br><span class="line">class Obj1(object):</span><br><span class="line">    #一定要作为类属性，作为实例属性无效</span><br><span class="line">    attr &#x3D; Examp(&#39;xiao66&#39;,12)</span><br><span class="line"></span><br><span class="line">x &#x3D; Obj1()</span><br><span class="line">print(x.attr)</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong><br>“__getattribute__”与“__getattr__”的最大差异在于：<br>1.无论调用对象的什么属性，包括不存在的属性，都会首先调用“__getattribute__”方法；<br>2.只有找不到对象的属性时，才会调用“__getattr__”方法；</p>
<p>仅希望以某种特殊的方式使用少数属性，而其他属性则按照普通属性操作。这些普通属性不会触发任何特殊代码，也不会因为遍历方法代码而浪费时间。在这些情况下，您可以对属性使用描述符<br>每次访问descriptor（即实现了__get__的类），都会先经过__get__函数。</p>
<p>需要注意的是，当使用类访问不存在的变量是，不会经过__getattr__函数。而descriptor不存在此问题，只是把instance标识为none而已</p>
<h3 id="快捷操作"><a href="#快捷操作" class="headerlink" title="快捷操作"></a>快捷操作</h3><h4 id="bin"><a href="#bin" class="headerlink" title="bin()"></a>bin()</h4><p><strong>bin()</strong> 返回一个整数 int 或者长整数 long int 的二进制表示。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="built_in">bin</span>(<span class="number">10</span>))</span><br><span class="line">&gt;&gt;</span><br><span class="line"><span class="number">0b1010</span></span><br><span class="line"><span class="comment"># 0b 指二进制标识，在c语言中用0b标识二进制</span></span><br></pre></td></tr></table></figure>

<h4 id="format"><a href="#format" class="headerlink" title=".format()"></a>.format()</h4><p>Python2.6 开始，新增了一种格式化字符串的函数 **str.format()**，它增强了字符串格式化的功能。</p>
<p>基本语法是通过 <strong>{}</strong> 和 <strong>:</strong> 来代替以前的 <strong>%</strong> 。</p>
<p>format 函数可以接受不限个参数，位置可以不按顺序。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="string">&quot;&#123;&#125; &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>)    </span><br><span class="line"><span class="comment"># 不设置指定位置，按默认顺序</span></span><br><span class="line"><span class="string">&#x27;hello world&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;&#123;0&#125; &#123;1&#125;&quot;</span>.<span class="built_in">format</span>(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>)  </span><br><span class="line"><span class="comment"># 设置指定位置</span></span><br><span class="line"><span class="string">&#x27;hello world&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;&#123;1&#125; &#123;0&#125; &#123;1&#125;&quot;</span>.<span class="built_in">format</span>(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>) </span><br><span class="line"><span class="comment"># 设置指定位置</span></span><br><span class="line"><span class="string">&#x27;world hello world&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="特殊方法"><a href="#特殊方法" class="headerlink" title="特殊方法"></a>特殊方法</h3><h4 id="ord-–chr"><a href="#ord-–chr" class="headerlink" title="ord()–chr()"></a>ord()–chr()</h4><p>ord():返回对应的ASCII值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(ord(&#39;A&#39;))</span><br><span class="line">&gt;&gt;65</span><br></pre></td></tr></table></figure>

<p>chr():返回对应的 Unicode 数值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(chr(65))</span><br><span class="line">&gt;&gt;A</span><br></pre></td></tr></table></figure>

<h4 id="slots"><a href="#slots" class="headerlink" title="slots"></a>slots</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__slots__</span><br></pre></td></tr></table></figure>

<ol>
<li>节省memory。在上面的例子里，如果我们看看<code>bar</code>和<code>slotted_bar</code>就看到，<code>slotted_bar</code>并没有<code>__dict__</code>而<code>bar</code>却含有<code>__dict__</code>。<code>__slots__</code>正是通过避免定义动态的数据结构<code>__dict__</code>来实现对memory的节省，大约能节省30%的memory</li>
<li>.access attributes更快。事实上，在CPython的实现里，<code>__slots__</code>是一个静态数据结构（static），里面存的是value references，比<code>__dict__</code>更快</li>
</ol>
<p>此处要注意一点，正因为<code>__slots__</code>是static的，定义了<code>__slots__</code>之后，你将不能创造新的attribute</p>
<p>如果你想获得<code>__slots__</code>的好处并且可以创造新的attribute，你可以将<code>__dict__</code>作为<code>__slots__</code>中的一个element（见下面code）：</p>
<p><strong>什么情况下该使用<code>__slots__</code>?</strong></p>
<p>当你事先知道class的attributes的时候，建议使用slots来节省memory以及获得更快的attribute access。</p>
<p>注意不应当把防止创造<code>__slots__</code>之外的新属性作为使用<code>__slots__</code>的原因，可以使用decorators以及getters，setters来实现attributes control。</p>
<p><strong>使用<code>__slots__</code>的特殊注意事项</strong></p>
<ol>
<li>当inherit from a slotted class，那么子类自动变成slotted并且获得parent class的slots；子类可以定义新的elements加入到inherited slots里。slots里面的每一个element，只能在inheritance里面定义一次（否则就是redundant）</li>
<li>在multiple inheritance（比如mixedins）里，如果两个parents定义了不同的nonempty __slots__，那么python会报错。这个时候，就进一步factor out 母类的slots。</li>
</ol>
<h4 id="if–name–-’–main–’"><a href="#if–name–-’–main–’" class="headerlink" title="if–name–==’–main–’:"></a>if–name–==’–main–’:</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br></pre></td></tr></table></figure>

<p>当你在写 .py 的时候</p>
<p>一般是以两种方式存在的</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> <strong>1、作为脚本直接运行</strong> </li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/20210529144951.png"></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> <strong>2、作为模块给别人导入</strong></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/20210529145101.png"></p>
<p>的代码在被执行的时候，Python 解释器会先去读取你的 Python 代码然后定义一些全局的内置变量，而我们常常写的这个 –name–就是其中的变量之一，如果判断出 –name– 的值是 –main–就说明这里是程序入口，而非被别的 py 文件 import</p>
<p>所以你的 .py 可以作为自己的脚本运行，在 –main– 中做一些测试，或者本身程序的运行，当然你也可以使用你的 .py 作为模块给别人使用，给别人提供一些便利，为了不让别人一导入你的模块就直接运行整个脚本那么使用 **if –name– == ‘–main–’**其中的代码就不会在被 import 时被执行。</p>
<h4 id="yield-lt-gt-send-gt-next"><a href="#yield-lt-gt-send-gt-next" class="headerlink" title="yield&lt;==&gt;send==&gt;next"></a>yield&lt;==&gt;send==&gt;next</h4><p>首先，如果你还没有对yield有个初步分认识，那么你先把yield看做“return”，这个是直观的，它首先是个return，普通的return是什么意思，就是在程序中返回某个值，返回之后程序就不再往下运行了。看做return之后再把它看做一个是生成器（generator）的一部分（带yield的函数才是真正的迭代器），好了，如果你对这些不明白的话，那先把yield看做return,然后直接看下面的程序，你就会明白yield的全部意思了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>():</span></span><br><span class="line">    print(<span class="string">&quot;starting...&quot;</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        res = <span class="keyword">yield</span> <span class="number">4</span></span><br><span class="line">        print(<span class="string">&quot;res:&quot;</span>,res)</span><br><span class="line">g = foo()</span><br><span class="line">print(<span class="built_in">next</span>(g))</span><br><span class="line">print(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line">print(<span class="built_in">next</span>(g))</span><br><span class="line">&gt;&gt;</span><br><span class="line">starting...</span><br><span class="line"><span class="number">4</span></span><br><span class="line">********************</span><br><span class="line">res: <span class="literal">None</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>我直接解释代码运行顺序，相当于代码单步调试：</p>
<ol>
<li><p>程序开始执行以后，因为foo函数中有yield关键字，所以foo函数并不会真的执行，而是先得到一个生成器g(相当于一个对象)</p>
</li>
<li><p>直到调用next方法，foo函数正式开始执行，先执行foo函数中的print方法，然后进入while循环</p>
</li>
<li><p>程序遇到yield关键字，然后把yield想想成return,return了一个4之后，程序停止，并没有执行赋值给res操作，此时next(g)语句执行完成，所以输出的前两行（第一个是while上面的print的结果,第二个是return出的结果）是执行print(next(g))的结果，</p>
</li>
<li><p>程序执行print(“*”<em>20)，输出20个</em></p>
</li>
<li><p>又开始执行下面的print(next(g)),这个时候和上面那个差不多，不过不同的是，这个时候是从刚才那个next程序停止的地方开始执行的，也就是要执行res的赋值操作，这时候要注意，这个时候赋值操作的右边是没有值的（因为刚才那个是return出去了，并没有给赋值操作的左边传参数），所以这个时候res赋值是None,所以接着下面的输出就是res:None,</p>
</li>
<li><p>程序会继续在while里执行，又一次碰到yield,这个时候同样return 出4，然后程序停止，print函数输出的4就是这次return出的4.</p>
</li>
</ol>
<p>到这里你可能就明白yield和return的关系和区别了，带yield的函数是一个生成器，而不是一个函数了，这个生成器有一个函数就是next函数，next就相当于“下一步”生成哪个数，这一次的next开始的地方是接着上一次的next停止的地方执行的，所以调用next的时候，生成器并不会从foo函数的开始执行，只是接着上一步停止的地方开始，然后遇到yield后，return出要生成的数，此步就结束。</p>
<hr>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>():</span></span><br><span class="line">    print(<span class="string">&quot;starting...&quot;</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        res = <span class="keyword">yield</span> <span class="number">4</span></span><br><span class="line">        print(<span class="string">&quot;res:&quot;</span>,res)</span><br><span class="line">g = foo()</span><br><span class="line">print(<span class="built_in">next</span>(g))</span><br><span class="line">print(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line">print(g.send(<span class="number">7</span>))</span><br><span class="line">&gt;&gt;</span><br><span class="line">starting...</span><br><span class="line"><span class="number">4</span></span><br><span class="line">********************</span><br><span class="line">res: <span class="number">7</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>先大致说一下send函数的概念：此时你应该注意到上面那个的紫色的字，还有上面那个res的值为什么是None，这个变成了7，到底为什么，这是因为，send是发送一个参数给res的，因为上面讲到，return的时候，并没有把4赋值给res，下次执行的时候只好继续执行赋值操作，只好赋值为None了，而如果用send的话，开始执行的时候，先接着上一次（return 4之后）执行，先把7赋值给了res,然后执行next的作用，遇见下一回的yield，return出结果后结束。</p>
<ol>
<li><p>程序执行g.send(7)，程序会从yield关键字那一行继续向下运行，send会把7这个值赋值给res变量</p>
</li>
<li><p>由于send方法中包含next()方法，所以程序会继续向下运行执行print方法，然后再次进入while循环</p>
</li>
<li><p>程序执行再次遇到yield关键字，yield会返回后面的值后，程序再次暂停，直到再次调用next方法或send方法。</p>
</li>
</ol>
<p><strong>简要理解：yield就是 return 返回一个值，并且记住这个返回的位置，下次迭代就从这个位置后开始。</strong></p>
<h2 id="测试code性能"><a href="#测试code性能" class="headerlink" title="测试code性能"></a>测试code性能</h2><h3 id="Performance"><a href="#Performance" class="headerlink" title="Performance"></a>Performance</h3><h4 id="1-timeit"><a href="#1-timeit" class="headerlink" title="1.timeit"></a><strong>1.timeit</strong></h4><p>timeit只输出被测试代码的总运行时间</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> timeit</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span>():</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">        a = i * i</span><br><span class="line"></span><br><span class="line">cost_time = timeit.timeit(<span class="string">&#x27;fun()&#x27;</span>, <span class="string">&#x27;from __main__ import fun&#x27;</span>, number=<span class="number">1000</span>)</span><br><span class="line">print(cost_time)</span><br><span class="line"></span><br><span class="line">&gt;&gt;</span><br><span class="line"><span class="number">0.0074794</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-profile-函数时间"><a href="#2-profile-函数时间" class="headerlink" title="2.profile[函数时间]"></a><strong>2.profile[函数时间]</strong></h4><p>profile：纯Python实现的性能测试模块，接口和cProfile一样。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> profile</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span>():</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">        a = i * i</span><br><span class="line">        </span><br><span class="line">profile.run(<span class="string">&#x27;fun()&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>ncall：函数运行次数</li>
<li>tottime： 函数的总的运行时间，减去函数中调用子函数的运行时间</li>
</ul>
<p>第一个percall：percall = tottime / nclall</p>
<ul>
<li>cumtime:函数及其所有子函数调整的运行时间，也就是函数开始调用到结束的时间。</li>
</ul>
<p>第二个percall：percall = cumtime / nclall</p>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ncalls</td>
<td align="center">函数被调用次数</td>
</tr>
<tr>
<td align="center">tottime</td>
<td align="center">函数（除去子函数）总运行时间</td>
</tr>
<tr>
<td align="center">percall</td>
<td align="center">平均时间，等于tottime/ncalls</td>
</tr>
<tr>
<td align="center">cumtime</td>
<td align="center">函数（包括子函数）总运行时间</td>
</tr>
<tr>
<td align="center">percall</td>
<td align="center">平均时间，等于cumtime/ncalls</td>
</tr>
<tr>
<td align="center">filename</td>
<td align="center">文件：行号（函数）</td>
</tr>
</tbody></table>
<p><img src="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/20210523203737.png"></p>
<hr>
<h4 id="3-cProfiler-函数时间"><a href="#3-cProfiler-函数时间" class="headerlink" title="3.cProfiler[函数时间]"></a><strong>3.cProfiler[函数时间]</strong></h4><p>profile：c语言实现的性能测试模块，接口和profile一样。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cProfile</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span>():</span></span><br><span class="line">    a = <span class="number">0</span></span><br><span class="line">    b = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000</span>):</span><br><span class="line">        a = a + i * i</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        b += <span class="number">1</span></span><br><span class="line">        time.sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cProfile.run(<span class="string">&#x27;fun()&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>result：</p>
<p><img src="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/20210523205439.png"></p>
<p><strong>profiler 和 cProfiler 都只能检测整个函数的运行时间，要想知道每行代码运行所损耗的时间需要line_profiler或者memory_profiler（不仅可以得到每行代码运行的时间还可以统计每行代码所占用的内存大小）</strong></p>
<hr>
<h4 id="4-line-profiler-分段时间"><a href="#4-line-profiler-分段时间" class="headerlink" title="4.line_profiler[分段时间]"></a><strong>4.line_profiler[分段时间]</strong></h4><p>pip install line_profiler</p>
<p>安装之后kernprof.py会加到环境变量中。</p>
<p>line_profiler可以统计每行代码的执行次数和执行时间等，时间单位为微妙。</p>
<p>该模块常通过装饰器来使用。在安装好该模块后，编写需要测试的python程序，并在需要测试的函数上方加入<code>@profile</code>，保存为<code>*.py</code>文件。在命令行使用<code>kernprof -l -v *.py</code>，在输出打印出程序结果之后会打印性能分析。</p>
<p>输出结果的含义：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> line_profiler <span class="keyword">import</span> LineProfiler</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_stuff</span>(<span class="params">numbers</span>):</span></span><br><span class="line">    s = <span class="built_in">sum</span>(numbers)</span><br><span class="line">    l = [numbers[i] / <span class="number">43</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(numbers))]</span><br><span class="line">    m = [<span class="string">&#x27;hello&#x27;</span> + <span class="built_in">str</span>(numbers[i]) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(numbers))]</span><br><span class="line">    </span><br><span class="line">numbers = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>)]</span><br><span class="line"></span><br><span class="line">lp = LineProfiler(do_stuff)</span><br><span class="line">lp.runcall(do_stuff, numbers)</span><br><span class="line">lp.print_stats()</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">意义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Timer unit</td>
<td align="center">计时器单位，微秒</td>
</tr>
<tr>
<td align="center">Total time</td>
<td align="center">测试代码总运行时间</td>
</tr>
<tr>
<td align="center">File</td>
<td align="center">测试代码文件名</td>
</tr>
<tr>
<td align="center">Hits</td>
<td align="center">每行代码运行次数</td>
</tr>
<tr>
<td align="center">Time</td>
<td align="center">每行代码运行时间</td>
</tr>
<tr>
<td align="center">Per Hit</td>
<td align="center">每行代码运行一次的时间</td>
</tr>
<tr>
<td align="center">% Time</td>
<td align="center">每行代码运行时间的百分比</td>
</tr>
<tr>
<td align="center">Line Contents</td>
<td align="center">每行代码</td>
</tr>
</tbody></table>
<p><img src="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/20210523213913.png"></p>
<ul>
<li>Total Time：测试代码的总运行时间</li>
<li>Hits：表示每行代码运行的次数</li>
<li>Time：每行代码运行的总时间</li>
<li>Per Hits：每行代码运行一次的时间</li>
<li>% Time：每行代码运行时间的百分比</li>
</ul>
<hr>
<h4 id="5-memory-profiler-内存"><a href="#5-memory-profiler-内存" class="headerlink" title="5.memory_profiler:[内存]"></a><strong>5.memory_profiler:[内存]</strong></h4><p>memory_profiler工具可以统计每行代码占用的内存大小。</p>
<p><strong>测试代码：</strong></p>
<p>使用方法同line_profiler模块，借助装饰器调用。在需要分析的函数上方加<code>@profile</code>。在命令行使用<code>python -m memory_profiler *.py</code>运行代码。<br>输出结果中：<br>Mem usage：内存使用情况<br>Increment：每行代码运行后内存增减情况</p>
<p><strong>使用：</strong></p>
<ol>
<li>在需要测试的函数加上@profile装饰</li>
<li>执行命令： python -m memory_profiler C:Python34 est.py</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将调试文件独立出xx.py</span></span><br><span class="line"><span class="comment"># 在pycharm 的 terminal windows中使用</span></span><br><span class="line"><span class="comment"># code: python -m memory_profiler memory_profiler</span></span><br><span class="line"><span class="keyword">from</span> memory_profiler <span class="keyword">import</span> profile</span><br><span class="line"></span><br><span class="line"><span class="meta">@profile</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span>():</span></span><br><span class="line">    c = []</span><br><span class="line">    a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] * (<span class="number">2</span> ** <span class="number">20</span>)</span><br><span class="line">    b = [<span class="number">1</span>] * (<span class="number">2</span> ** <span class="number">20</span>)</span><br><span class="line">    c.extend(a)</span><br><span class="line">    c.extend(b)</span><br><span class="line">    <span class="keyword">del</span> b</span><br><span class="line">    <span class="keyword">del</span> c</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    test1()</span><br><span class="line"></span><br><span class="line">&gt;&gt;cmd -&gt;python version 3.7</span><br><span class="line">&gt;&gt;//terminal//</span><br><span class="line">&lt;python -m memory_profiler memory_profiler&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/20210523232121.png"></p>
<ul>
<li><code>Mem usage</code> 为当前总内存</li>
<li><code>Increment</code> 为增加的内存</li>
</ul>
<p>总结起来使用非常时间</p>
<ul>
<li>方法前加上 <code>@profile</code> 主键</li>
<li>使用 <code>python -m memory_profiler</code> 来运行，不过直接用 <code>python</code> 运行也可以</li>
</ul>
<p>通过上面这段代码我们可以发现，<code>del</code> 语句只是将变量删除，并不能减少内存的消耗。</p>
<p><strong>参数使用</strong></p>
<ul>
<li><code>precision</code> 显示小数点后的位数</li>
</ul>
<p>默认显示的内存单位为 <code>MiB</code>，小数点后显示一位，如果某行代码占用内存比较小，就可能显示不出来，此时可以通过调整小数点后的位数实现。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> memory_profiler <span class="keyword">import</span> profile</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@profile(<span class="params">precision=<span class="number">4</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test3</span>():</span></span><br><span class="line">    a = [<span class="number">1</span>, <span class="number">2</span>] * (<span class="number">2</span> ** <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    test3()</span><br></pre></td></tr></table></figure>

<ul>
<li><code>stream</code> 将结果输出到流中</li>
</ul>
<p>每次运行都要打印内存情况，势必会影响程序输出效果，我们可以将结果通过流输出到文件中</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> memory_profiler <span class="keyword">import</span> profile</span><br><span class="line"></span><br><span class="line"><span class="meta">@profile(<span class="params">precision=<span class="number">4</span>, @profile(<span class="params">precision=<span class="number">4</span>, stream=<span class="built_in">open</span>(<span class="params"><span class="string">&#x27;/tmp/memory_profiler.log&#x27;</span>,<span class="string">&#x27;w+&#x27;</span></span>)</span>)</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test3</span>():</span></span><br><span class="line">    a = [<span class="number">1</span>, <span class="number">2</span>] * (<span class="number">2</span> ** <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    test3()</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="6-objgraph：-待完善"><a href="#6-objgraph：-待完善" class="headerlink" title="6.objgraph：[待完善]"></a>6.objgraph：[待完善]</h4><p>objgraph是一个实用模块,可以列出当前内存中存在的对象，可用于定位内存泄露。</p>
<p>objgraph需要安装：</p>
<p>pip install objgraph</p>
<hr>
<h3 id="Time"><a href="#Time" class="headerlink" title="Time"></a>Time</h3><p>计算Python的某个程序，或者是代码块运行的时间一般有三种方法。</p>
<h4 id="1-datetime"><a href="#1-datetime" class="headerlink" title="1.datetime"></a><strong>1.datetime</strong></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line">start = datetime.datetime.now()</span><br><span class="line">run_function():</span><br><span class="line">    <span class="comment"># do something</span></span><br><span class="line"></span><br><span class="line">end = datetime.datetime.now()</span><br><span class="line"><span class="built_in">print</span> (end-start)</span><br></pre></td></tr></table></figure>

<h4 id="2-time–time"><a href="#2-time–time" class="headerlink" title="2.time–time"></a><strong>2.time–time</strong></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line">start = time.time()</span><br><span class="line">run_function()</span><br><span class="line">end = time.time()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">str</span>(end-start)</span><br></pre></td></tr></table></figure>

<h4 id="3-time-clock-version-lt-3-8"><a href="#3-time-clock-version-lt-3-8" class="headerlink" title="3.time-clock(version&lt;3.8)"></a><strong>3.time-clock(version&lt;3.8)</strong></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line">start = time.clock()</span><br><span class="line">run_function()</span><br><span class="line">end = time.clock()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">str</span>(end-start)</span><br></pre></td></tr></table></figure>

<p>通过对以上方法的比较我们发现，方法二的精度比较高。方法一基本上是性能最差的。这个其实是和系统有关系的。一般我们推荐使用方法二和方法三。我的系统是Ubuntu，也就是Linux系统，方法二返回的是UTC时间。 在很多系统中time.time()的精度都是非常低的，包括windows。</p>
<p>python 的标准库手册推荐在任何情况下尽量使用time.clock().但是这个函数在windows下返回的是真实时间（wall time）</p>
<p><strong>方法一和方法二都包含了其他程序使用CPU的时间。方法三只计算了程序运行CPU的时间。</strong></p>
<p>方法二和方法三都返回的是浮点数<br>究竟是使用 <strong>time.clock()</strong> 精度高，还是使用 <strong>time.time()</strong> 精度更高，要视乎所在的平台来决定。总概来讲，在 <strong>Unix</strong> 系统中，建议使用 **time.time()**，在 Windows 系统中，建议使用 **time.clock()**。</p>
<p><strong>我们要实现跨平台的精度性，我们可以使用timeit 来代替time</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> timeit</span><br><span class="line"></span><br><span class="line">start = timeit.default_timer()</span><br><span class="line">do_func()</span><br><span class="line">end = timeit.default_timer()</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">str</span>(end-start)</span><br></pre></td></tr></table></figure>

<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>随着问题规模的增加，<code>T(n)</code>变化最大的数量级称为时间复杂度<code>O(n)</code></p>
<h2 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h2><p>Python2中默认的编码格式是 ASCII 格式，程序文件中如果包含中文字符（包括注释部分）需要在文件开头加上 <code># -*- coding: UTF-8 -*-</code> 或者 <code>#coding=utf-8</code> 就行了</p>
<p>Python3默认支持Unicode</p>
<h2 id="保留字（关键字）"><a href="#保留字（关键字）" class="headerlink" title="保留字（关键字）"></a>保留字（关键字）</h2><p>30个关键字</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">and exec    not</span><br><span class="line">assert  finally or</span><br><span class="line">break   for pass</span><br><span class="line">class   from    print</span><br><span class="line">continue global raise</span><br><span class="line">def if  return</span><br><span class="line">del import  try</span><br><span class="line">elif    in  while</span><br><span class="line">else    is  with</span><br><span class="line">except  lambda  yield</span><br></pre></td></tr></table></figure>

<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 单行注释</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">多行注释</span></span><br><span class="line"><span class="string">多行注释</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">多行注释</span></span><br><span class="line"><span class="string">多行注释</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="变量赋值"><a href="#变量赋值" class="headerlink" title="变量赋值"></a>变量赋值</h2><p>Python是动态语言，所以在定义变量的时候不需要申明类型，直接使用即可。<br>Python会根据值判断类型。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&quot;Zeta&quot;</span> <span class="comment"># 字符串变量</span></span><br><span class="line">age = <span class="number">38</span> <span class="comment"># 整数</span></span><br><span class="line">income = <span class="number">1.23</span> <span class="comment"># 浮点数</span></span><br></pre></td></tr></table></figure>

<p>多变量赋值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a,b = <span class="number">1</span>,<span class="number">2</span> <span class="comment"># a=1; b=2</span></span><br><span class="line">c = d = <span class="number">3</span> <span class="comment"># c=3; d=3</span></span><br></pre></td></tr></table></figure>

<h2 id="标准数据类型"><a href="#标准数据类型" class="headerlink" title="标准数据类型"></a>标准数据类型</h2><h3 id="Python-的标准数据类型有："><a href="#Python-的标准数据类型有：" class="headerlink" title="Python 的标准数据类型有："></a>Python 的标准数据类型有：</h3><ul>
<li>Boolean（布尔值）</li>
<li>Number（数字）</li>
<li>String（字符串）</li>
<li>List（列表）</li>
<li>Tuple（元组）</li>
<li>Set（集合）</li>
<li>Dictionary（字典）(hash map)—遇到hash冲突时,采用的是开放寻址法而不是链接法</li>
</ul>
<h3 id="Python标准数据结构有"><a href="#Python标准数据结构有" class="headerlink" title="Python标准数据结构有:"></a>Python标准数据结构有:</h3><p><code>有序结构,可以使用index下标进行检索数据,并且序列中的元素可以重复</code></p>
<ul>
<li>List</li>
<li>Tuple</li>
<li>String</li>
</ul>
<hr>
<p><code>无序结构,不可以用index下标进行检索,序列中允许有重复元素</code></p>
<ul>
<li>Set</li>
<li>Dictionary</li>
</ul>
<h2 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h2><p>Python类型转换非常简单，用类型名作为函数名即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>(n)            <span class="comment"># 将数字n转换为一个整数</span></span><br><span class="line"><span class="built_in">float</span>(n)          <span class="comment"># 将数字n转换到一个浮点数</span></span><br><span class="line"><span class="built_in">str</span>(o)            <span class="comment"># 将对象 obj 转换为字符串</span></span><br><span class="line"><span class="built_in">tuple</span>(s)          <span class="comment"># 将序列 s 转换为一个元组</span></span><br><span class="line"><span class="built_in">list</span>(s)           <span class="comment"># 将序列 s 转换为一个列表</span></span><br><span class="line"><span class="built_in">set</span>(s)            <span class="comment"># 将序列 s 转换为一个集合</span></span><br></pre></td></tr></table></figure>

<p>另外，Python中可以直接转换数字字符串和数字：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;123&quot;</span></span><br><span class="line">i = <span class="number">456</span></span><br><span class="line">print(<span class="built_in">int</span>(s), <span class="built_in">str</span>(i))</span><br></pre></td></tr></table></figure>

<h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2><p>Python传统的判断语句如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> name == <span class="string">&#x27;zeta&#x27;</span>:          <span class="comment"># 判断变量是否为 zeta </span></span><br><span class="line">    print(<span class="string">&#x27;Welcome boss&#x27;</span>)   <span class="comment"># 并输出欢迎信息</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">&#x27;Hi, &#x27;</span> + name)</span><br></pre></td></tr></table></figure>

<p>Python不支持三元表达式，但是可以用一种类似的替代办法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">title = <span class="string">&quot;boss&quot;</span></span><br><span class="line">name = <span class="string">&quot;zeta&quot;</span> <span class="keyword">if</span> title == <span class="string">&quot;boss&quot;</span> <span class="keyword">else</span> <span class="string">&quot;chow&quot;</span></span><br><span class="line">print(name)</span><br></pre></td></tr></table></figure>

<p>逻辑与用 <code>and</code> ，逻辑或用 <code>or</code></p>
<h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><p>Python中有<code>while</code>和<code>for</code>两种循环，都可以使用<code>break</code>跳出循环和<code>continue</code>立即进入下一轮循环，另外，Python的循环语句还可以用<code>else</code>执行循环全部完毕后的代码，<code>break</code>跳出后不会执行<code>else</code>的代码</p>
<p><strong>while</strong> 条件循环，</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> (count &lt; <span class="number">9</span>):    </span><br><span class="line">    print(<span class="string">&#x27;The count is:&#x27;</span>, count)    </span><br><span class="line">    count = count + <span class="number">1</span>    </span><br><span class="line">    <span class="keyword">if</span> count == <span class="number">5</span>:        </span><br><span class="line">        <span class="keyword">break</span>   <span class="comment"># 可以比较以下break和不break的区别        </span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">else</span>:    </span><br><span class="line">        print(<span class="string">&#x27;loop over&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>for</strong> 遍历循环，循环遍历所有序列对象的子项</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">names = [<span class="string">&#x27;zeta&#x27;</span>, <span class="string">&#x27;chow&#x27;</span>,  <span class="string">&#x27;world&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> names:    </span><br><span class="line">    print(<span class="string">&#x27;Hello, &#x27;</span> + n)    </span><br><span class="line">    <span class="keyword">if</span> n == <span class="string">&#x27;world&#x27;</span>:        </span><br><span class="line">        <span class="keyword">break</span>        </span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">else</span>:    </span><br><span class="line">        print(<span class="string">&#x27;Good night!&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><code>for</code>循环中也可以用<code>else</code>，（注释掉代码中的<code>break</code>试试看。)</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>用<code>def</code>关键字定义函数，并且在Python中，作为脚本语言，调用函数必须在定义函数之后。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">name</span>):</span></span><br><span class="line">    print(<span class="string">&quot;hello, &quot;</span>+name)</span><br><span class="line">    passfoo(<span class="string">&quot;zeta&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>默认参数</strong> Python定义函数参数时，可以设置默认值，调用时如果没有传递该参数，函数内将使用默认值，默认值参数必须放在无默认值参数后面。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">name=<span class="string">&quot;zeta&quot;</span></span>):</span></span><br><span class="line">    print(<span class="string">&quot;hello, &quot;</span>+name)</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>

<p><strong>关键字参数</strong> 一般函数传递参数时，必须按照参数定于的顺序传递，但是Python中，允许使用关键字参数，这样通过指定参数明，可以不按照函数定义参数的顺序传递参数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">age, name=<span class="string">&quot;zeta&quot;</span></span>):</span></span><br><span class="line">    print(<span class="string">&quot;hello, &quot;</span>+name+<span class="string">&quot;; age=&quot;</span>+<span class="built_in">str</span>(age))</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">foo(name=<span class="string">&quot;chow&quot;</span>, age=<span class="number">18</span>)</span><br></pre></td></tr></table></figure>

<p><strong>不定长参数</strong>，Python支持不定长参数，用<code>*</code>定义参数名，调用时多个参数将作为一个元祖传递到函数内</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">*names</span>):</span></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> names:</span><br><span class="line">        print(<span class="string">&quot;hello, &quot;</span>+n)</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">foo(<span class="string">&quot;zeta&quot;</span>, <span class="string">&quot;chow&quot;</span>, <span class="string">&quot;world&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>return</strong> 返回函数结果。</p>
<h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><ul>
<li>模块是一个.py文件</li>
<li>模块在第一次被导入时执行</li>
<li>一个下划线定义保护级变量和函数，两个下划线定义私有变量和函数</li>
<li>导入模块习惯性在脚本顶部，但是不强制</li>
</ul>
<h2 id="导入包"><a href="#导入包" class="headerlink" title="导入包"></a>导入包</h2><p>在Python中，使用<code>import</code>导入模块。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python# -*- coding: UTF-8 -*- # 导入模块import support support.print_func(“Runoob”)</span></span><br></pre></td></tr></table></figure>

<p>还可以使用<code>from import</code>导入模块指定部分</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> modname <span class="keyword">import</span> name1[, name2[, ... nameN]]</span><br></pre></td></tr></table></figure>

<p>为导入的包设置别名用 <code>as</code>关键字</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime <span class="keyword">as</span> dt</span><br></pre></td></tr></table></figure>

<h2 id="错误和异常"><a href="#错误和异常" class="headerlink" title="错误和异常"></a>错误和异常</h2><p>Python中用经典的 <code>try/except</code> 捕获异常</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:&lt;语句&gt;    <span class="comment">#运行别的代码</span></span><br><span class="line">    <span class="keyword">except</span> &lt;异常名称&gt;：&lt;语句&gt;        </span><br><span class="line">    <span class="comment">#except &lt;异常名称&gt;，&lt;数据&gt;:&lt;语句&gt; </span></span><br><span class="line">    <span class="comment">#如果引发了指定名称的异常，获得附加的数据</span></span><br></pre></td></tr></table></figure>

<p>还提供了 <strong>else</strong> 和 <strong>finally</strong></p>
<p>如果没发生异常的执行<code>else</code>语句块，<code>finally</code>块的代码无论是否捕获异常都会执行</p>
<p>Python内建了很全面的异常类型名称，同时能自定义异常类型</p>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>Python完全支持面向对象的。</p>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><ol>
<li>使用<code>thread</code>模块中的<code>start_new_thread()</code>函数</li>
<li>使用<code>threading</code>模块创建线程</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Python和Go分别在动态语言和静态语言中都是最易学易用的编程语言之一。</p>
<p>它们并不存在取代关系，而是各自在其领域发挥自己的作用。</p>
<p>Python的语法简单直观，除了程序员爱不释手外也非常适合于其他领域从业者使用。</p>
<p>Go兼具语法简单和运行高效的有点，在多线程处理方面很优秀，非常适合已经掌握一定编程基础和一门主流语言的同学学习，不过，Go是不支持面向对象的，对于大多数支持面向对象语言的使用者在学习Go语言的时候，需要谨记并且转换编程思路。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://drinkle.top/2021/05/15/Python-Underlying-Structure/" data-id="ckopezsv70000cwf52kqmg664" data-title="Python-Underlying-Structure" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/" rel="tag">Python</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2021/05/23/Framework-Thinking/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">前一篇</strong>
      <div class="article-nav-title">
        
          Framework-Thinking
        
      </div>
    </a>
  
  
    <a href="/2021/05/06/%E6%88%91%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%AE%9E%E8%B7%B5/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">后一篇</strong>
      <div class="article-nav-title">我的工作实践</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/English-Study/" rel="tag">English Study</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GoodNotes/" rel="tag">GoodNotes</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hexo/" rel="tag">Hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/" rel="tag">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/consciousness/" rel="tag">consciousness</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%96%E7%95%8C%E8%A7%82-%E6%96%B9%E6%B3%95%E8%AE%BA/" rel="tag">世界观 方法论</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AE%9E%E8%B7%B5/" rel="tag">实践</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B7%A6%E7%BF%BC%E5%90%8C%E7%9B%9F%E4%BC%9A/" rel="tag">左翼同盟会</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%96%B0%E9%97%BB%E8%81%94%E6%92%AD/" rel="tag">新闻联播</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%87%B4%E4%BD%A0%E7%9A%84%E4%B8%80%E5%B0%81%E4%BF%A1/" rel="tag">致你的一封信</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/English-Study/" style="font-size: 20px;">English Study</a> <a href="/tags/GoodNotes/" style="font-size: 10px;">GoodNotes</a> <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/Python/" style="font-size: 15px;">Python</a> <a href="/tags/consciousness/" style="font-size: 10px;">consciousness</a> <a href="/tags/%E4%B8%96%E7%95%8C%E8%A7%82-%E6%96%B9%E6%B3%95%E8%AE%BA/" style="font-size: 10px;">世界观 方法论</a> <a href="/tags/%E5%AE%9E%E8%B7%B5/" style="font-size: 10px;">实践</a> <a href="/tags/%E5%B7%A6%E7%BF%BC%E5%90%8C%E7%9B%9F%E4%BC%9A/" style="font-size: 10px;">左翼同盟会</a> <a href="/tags/%E6%96%B0%E9%97%BB%E8%81%94%E6%92%AD/" style="font-size: 10px;">新闻联播</a> <a href="/tags/%E8%87%B4%E4%BD%A0%E7%9A%84%E4%B8%80%E5%B0%81%E4%BF%A1/" style="font-size: 10px;">致你的一封信</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">五月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">四月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">三月 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/05/23/Framework-Thinking/">Framework-Thinking</a>
          </li>
        
          <li>
            <a href="/2021/05/15/Python-Underlying-Structure/">Python-Underlying-Structure</a>
          </li>
        
          <li>
            <a href="/2021/05/06/%E6%88%91%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%AE%9E%E8%B7%B5/">我的工作实践</a>
          </li>
        
          <li>
            <a href="/2021/04/30/Infectious-Disease-Model/">Infectious Disease Model</a>
          </li>
        
          <li>
            <a href="/2021/04/30/Nerual-Network/">Nerual-Network</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 Drink<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>