<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Python-BuiltIn | Drink`s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="[Class魔法]–iter––str&#x2F;repr&#x2F;format–string&#x2F;represent 其实这正是反应了两者的区别，如果简单理解，这两个函数都是将一个实例转成字符串。但是不同的是，两者的使用场景不同，其中__str__更加侧重展示。所以当我们print输出给用户或者使用str函数进行类型转化的时候，Python都会默认优先调用__str__函数。而__repr__更侧重于这个实例的报告，">
<meta property="og:type" content="article">
<meta property="og:title" content="Python-BuiltIn">
<meta property="og:url" content="https://drinkle.top/2021/06/06/Python-BuiltIn/index.html">
<meta property="og:site_name" content="Drink&#96;s Blog">
<meta property="og:description" content="[Class魔法]–iter––str&#x2F;repr&#x2F;format–string&#x2F;represent 其实这正是反应了两者的区别，如果简单理解，这两个函数都是将一个实例转成字符串。但是不同的是，两者的使用场景不同，其中__str__更加侧重展示。所以当我们print输出给用户或者使用str函数进行类型转化的时候，Python都会默认优先调用__str__函数。而__repr__更侧重于这个实例的报告，">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.runoob.com/wp-content/uploads/2017/04/loading-example.gif">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/20210529144951.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/20210529145101.png">
<meta property="article:published_time" content="2021-06-06T12:46:32.000Z">
<meta property="article:modified_time" content="2021-07-09T10:31:12.267Z">
<meta property="article:author" content="Drink">
<meta property="article:tag" content="BuiltIn">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.runoob.com/wp-content/uploads/2017/04/loading-example.gif">
  
    <link rel="alternate" href="/atom.xml" title="Drink`s Blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Drink`s Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://drinkle.top"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-Python-BuiltIn" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/06/Python-BuiltIn/" class="article-date">
  <time class="dt-published" datetime="2021-06-06T12:46:32.000Z" itemprop="datePublished">2021-06-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      Python-BuiltIn
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Class魔法"><a href="#Class魔法" class="headerlink" title="[Class魔法]"></a>[Class魔法]</h2><h3 id="–iter–"><a href="#–iter–" class="headerlink" title="–iter–"></a>–iter–</h3><h3 id="–str-repr-format–"><a href="#–str-repr-format–" class="headerlink" title="–str/repr/format–"></a>–str/repr/format–</h3><p>string/represent</p>
<p>其实这正是<strong>反应了两者的区别</strong>，如果简单理解，这两个函数都是将一个实例转成字符串。但是不同的是，两者的使用场景不同，其中__str__更加侧重展示。所以当我们print<strong>输出给用户或者使用str函数进行类型转化</strong>的时候，Python都会默认优先调用__str__函数。而__repr__更侧重于这个实例的报告，除了实例当中的内容之外，我们往往还会附上它的类相关的信息，<strong>因为这些内容是给开发者看的</strong>。所以当我们在交互式窗口输出的时候，它会优先调用__repr__。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">       <span class="keyword">return</span> <span class="string">&#x27;x: %s, y: %s&#x27;</span> % (self.x, self.y)</span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">       <span class="keyword">return</span> <span class="string">&#x27;x: %s, y: %s&#x27;</span> % (self.x, self.y)</span><br></pre></td></tr></table></figure>

<p>到这里还没有结束，在有些场景当中，对于<strong>同一个对象我们可能有多种输出的格式</strong>。比如点，在有些场景下我们可能希望输出(x, y)，有时候我们又希望输出x: 3, y: 4，可能还有些场景当中，我们希望输出&lt;x, y&gt;。</p>
<p>我们针对这么多场景，如果各自实现不同的接口会非常麻烦。这个时候利用__format__当中的这个参数，就可以大大简化这个过程，我们来看代码：</p>
<p><code>.format()</code>配合<code>__format__</code>使用，减少api的设置，同时可是设置不同的输出格式</p>
<p><code>__str__</code>:侧重展示</p>
<p><code>__repr__</code>:侧重报告，可以展示类的相关信息给开发者</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dictionary</span></span><br><span class="line">formats = &#123;</span><br><span class="line">    <span class="string">&#x27;normal&#x27;</span>: <span class="string">&#x27;x: &#123;p.x&#125;, y: &#123;p.y&#125;&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;point&#x27;</span>: <span class="string">&#x27;(&#123;p.x&#125;, &#123;p.y&#125;)&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;prot&#x27;</span>: <span class="string">&#x27;&lt;&#123;p.x&#125;, &#123;p.y&#125;&gt;&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">point</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x, y</span>):</span></span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;x: %s, y: %s&#x27;</span> % (self.x, self.y)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__format__</span>(<span class="params">self, code</span>):</span></span><br><span class="line">        <span class="comment"># use dictionary[key].format(message==&gt;/dictionary_varable/attribuate)</span></span><br><span class="line">        <span class="keyword">return</span> formats[code].<span class="built_in">format</span>(p=self)</span><br><span class="line">    </span><br><span class="line">p = point(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="comment"># call--&gt;&#123;:key&#125;.format(instance)</span></span><br><span class="line">print(<span class="string">&#x27;the point is &#123;:normal&#125;&#x27;</span>.<span class="built_in">format</span>(p))</span><br><span class="line">print(<span class="string">&#x27;the point is &#123;:point&#125;&#x27;</span>.<span class="built_in">format</span>(p))</span><br><span class="line">print(<span class="string">&#x27;the point is &#123;:prot&#125;&#x27;</span>.<span class="built_in">format</span>(p))</span><br><span class="line">&gt;&gt;</span><br><span class="line">the point <span class="keyword">is</span> x: <span class="number">3</span>, y: <span class="number">4</span></span><br><span class="line">the point <span class="keyword">is</span> (<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">the point <span class="keyword">is</span> &lt;<span class="number">3</span>, <span class="number">4</span>&gt;</span><br></pre></td></tr></table></figure>

<h3 id="–contains–"><a href="#–contains–" class="headerlink" title="–contains–"></a>–contains–</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Class A:</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">		self.item = <span class="number">10</span></span><br><span class="line">       </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__contains__</span>(<span class="params">self, item</span>):</span></span><br><span class="line">		<span class="keyword">if</span> item <span class="keyword">is</span> self.item:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">a = A()</span><br><span class="line">print(a.__contains__(<span class="number">5</span>))</span><br><span class="line">&gt;&gt;</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h2 id="查看信息"><a href="#查看信息" class="headerlink" title="[查看信息]"></a>[查看信息]</h2><h3 id="加密Class属性"><a href="#加密Class属性" class="headerlink" title="加密Class属性"></a>加密Class属性</h3><p><strong>使用__getattribute_</strong>_进行加密</p>
<p>为了避免从实列中使用dir()或者<code>__dict__</code>access属性,可以使用<code>__getattribute__</code>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.__name = <span class="string">&#x27;LIU&#x27;</span></span><br><span class="line">        self.__score = <span class="number">96</span></span><br><span class="line">        self.age = <span class="number">17</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattribute__</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        <span class="comment"># prevent all methods to access attributes</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">temp = Student()</span><br><span class="line">print(temp.age)</span><br><span class="line">print(temp.__name)</span><br><span class="line">print(temp.__dict__)</span><br><span class="line">print(<span class="built_in">dir</span>(temp))</span><br><span class="line">&gt;&gt;</span><br><span class="line"><span class="literal">None</span></span><br><span class="line"><span class="literal">None</span></span><br><span class="line"><span class="literal">None</span></span><br><span class="line">[]</span><br></pre></td></tr></table></figure>

<ul>
<li>使用<code>__getattr__</code>只能对private attribute 和不存在的属性有效，当访问私有属性和不存在的属性时，return <code>__getattr__</code>里的内容</li>
</ul>
<p><strong>使用__getitem_ _</strong>进行单个key加密</p>
<p><code>access attributes use [key&#39;string&#39;]</code></p>
<p>instance[‘attr_1’]</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.__name = <span class="string">&#x27;LIU&#x27;</span></span><br><span class="line">        self.__score = <span class="number">96</span></span><br><span class="line">        self.age = <span class="number">17</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span>(<span class="params">self, key</span>):</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> [<span class="string">&#x27;__name&#x27;</span>, <span class="string">&#x27;__score&#x27;</span>, <span class="string">&#x27;age&#x27;</span>]:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;the class has the attributes.&#x27;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;no access&#x27;</span></span><br><span class="line">        </span><br><span class="line">temp = Student()</span><br><span class="line">print(temp[<span class="string">&#x27;age&#x27;</span>])</span><br><span class="line">print(temp[<span class="string">&#x27;ee&#x27;</span>])</span><br><span class="line">&gt;&gt;</span><br><span class="line">the <span class="class"><span class="keyword">class</span> <span class="title">has</span> <span class="title">the</span> <span class="title">attribute</span>.</span></span><br><span class="line"><span class="class"><span class="title">no</span> <span class="title">access</span></span></span><br></pre></td></tr></table></figure>

<h3 id="访问Class属性"><a href="#访问Class属性" class="headerlink" title="访问Class属性"></a>访问Class属性</h3><p>访问属性的方法常见的有四种</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__getattribute__() <span class="comment"># default 优先级最高</span></span><br><span class="line">instance.attribute</span><br><span class="line">__getattr__()</span><br><span class="line">__getitem__()</span><br><span class="line">.</span><br></pre></td></tr></table></figure>

<h3 id="查看class属性"><a href="#查看class属性" class="headerlink" title="查看class属性"></a>查看class属性</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.__name = <span class="string">&#x27;LIU&#x27;</span> <span class="comment"># private attribute</span></span><br><span class="line">        self.__score = <span class="number">96</span></span><br><span class="line">        self.age = <span class="number">17</span></span><br><span class="line"></span><br><span class="line">temp = Student()</span><br><span class="line">print(temp.age)</span><br><span class="line">print(<span class="built_in">dir</span>(temp))</span><br><span class="line">print(temp.__dict__)</span><br><span class="line">&gt;&gt;</span><br><span class="line"><span class="number">17</span></span><br><span class="line">[<span class="string">&#x27;_Student__name&#x27;</span>, <span class="string">&#x27;_Student__score&#x27;</span>, <span class="string">&#x27;__class__&#x27;</span>, <span class="string">&#x27;__delattr__&#x27;</span>, <span class="string">&#x27;__dict__&#x27;</span>, <span class="string">&#x27;__dir__&#x27;</span>, <span class="string">&#x27;__doc__&#x27;</span>, <span class="string">&#x27;__eq__&#x27;</span>, <span class="string">&#x27;__format__&#x27;</span>, <span class="string">&#x27;__ge__&#x27;</span>, <span class="string">&#x27;__getattribute__&#x27;</span>, <span class="string">&#x27;__gt__&#x27;</span>, <span class="string">&#x27;__hash__&#x27;</span>, <span class="string">&#x27;__init__&#x27;</span>, <span class="string">&#x27;__init_subclass__&#x27;</span>, <span class="string">&#x27;__le__&#x27;</span>, <span class="string">&#x27;__lt__&#x27;</span>, <span class="string">&#x27;__module__&#x27;</span>, <span class="string">&#x27;__ne__&#x27;</span>, <span class="string">&#x27;__new__&#x27;</span>, <span class="string">&#x27;__reduce__&#x27;</span>, <span class="string">&#x27;__reduce_ex__&#x27;</span>, <span class="string">&#x27;__repr__&#x27;</span>, <span class="string">&#x27;__setattr__&#x27;</span>, <span class="string">&#x27;__sizeof__&#x27;</span>, <span class="string">&#x27;__str__&#x27;</span>, <span class="string">&#x27;__subclasshook__&#x27;</span>, <span class="string">&#x27;__weakref__&#x27;</span>, <span class="string">&#x27;age&#x27;</span>]</span><br><span class="line">----------------</span><br><span class="line">&#123;<span class="string">&#x27;_Student__name&#x27;</span>: <span class="string">&#x27;LIU&#x27;</span>, <span class="string">&#x27;_Student__score&#x27;</span>: <span class="number">96</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">17</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="–len–"><a href="#–len–" class="headerlink" title="–len–"></a>–len–</h3><p>Python对象含有的<strong>xxxx__这样定义的属性和方法，都有特殊用途，比如__len</strong>()。</p>
<p> 在Python中，如果你调用<code>len()</code>函数试图获取一个对象的长度，实际上，在<code>len()</code>函数内部，它自动去调用该对象的<code>__len__()</code>方法。</p>
<h3 id="–dict–"><a href="#–dict–" class="headerlink" title="–dict–"></a>–dict–</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">instance.__dict__()</span><br><span class="line">==&gt;list</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">all</span> attributes(contains private attribute)</span><br><span class="line"></span><br><span class="line"><span class="built_in">dir</span>(instance)</span><br><span class="line">==&gt;dictionary</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">all</span> operations <span class="keyword">and</span> attributes</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__dict__ &lt;==difference==&gt; dic()</span><br></pre></td></tr></table></figure>

<p><code>__dict__与dir()</code>的区别：</p>
<ol>
<li>dir()是一个函数，返回的是list；</li>
<li><code>__dict__</code>是一个字典，键为属性名，值为属性值；</li>
<li>dir()用来寻找一个对象的所有属性，包括<code>__dict__</code>中的属性，<code>__dict__</code>是dir()的子集；</li>
<li><strong>并不是所有对象都拥有<code>__dict__</code>属性。</strong>许多内建类型就[没有<code>__dict__</code>属性，如list，此时就需要用dir()来列出对象的所有属性。</li>
</ol>
<p><strong><code>__dict__</code>是用来存储对象属性的一个字典，其键为属性名，值为属性的值。</strong></p>
<p><strong>注意:</strong></p>
<ol>
<li><p>实例的<code>__dict__</code>仅存储与该实例相关的实例属性，</p>
<p>正是因为实例的<code>__dict__</code>属性，每个实例的实例属性才会互不影响。</p>
</li>
<li><p>类的<code>__dict__</code>存储所有实例共享的变量和函数(类属性，方法等)，类的<code>__dict__</code>并不包含其父类的属性。</p>
</li>
</ol>
<p><strong>结论：</strong></p>
<p>dir()函数会自动寻找一个对象的所有属性，包括<code>__dict__</code>中的属性。</p>
<p><code>__dict__</code>是dir()的子集，dir()包含<code>__dict__</code>中的属性。</p>
<p>dir()是Python提供的一个API函数，<strong>dir()函数会自动寻找一个对象的所有属性</strong>(包括从父类中继承的属性)。</p>
<p> 一个实例的<code>__dict__</code>属性仅仅是那个实例的实例属性的集合，并不包含该实例的所有有效属性。所以如果想获取一个对象所有有效属性，应使用dir()。</p>
<hr>
<h3 id="dir"><a href="#dir" class="headerlink" title="dir()"></a>dir()</h3><p><strong>dir()</strong> 函数不带参数时，返回当前范围内的变量、方法和定义的类型列表；带参数时，返回参数的属性、方法列表。如果参数包含方法<strong>dir</strong>()，该方法将被调用。如果参数不包含<strong>dir</strong>()，该方法将最大限度地收集参数信息。</p>
<h3 id="Get与Attr"><a href="#Get与Attr" class="headerlink" title="Get与Attr"></a>Get与Attr</h3><p>如果在类中定义了<strong>getitem</strong>()方法，那么他的实例对象（假设为P）就可以这样P[key]取值。当实例对象做P[key]运算时，就会调用类中的<strong>getitem</strong>()方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__getitem__(self,key):返回键对应的值。</span><br><span class="line"></span><br><span class="line">__setitem__(self,key,value)：设置给定键的值</span><br><span class="line"></span><br><span class="line">__delitem__(self,key):删除给定键对应的元素。</span><br><span class="line"></span><br><span class="line">__len__():返回元素的数量</span><br></pre></td></tr></table></figure>

<p>python的一切数据都是对象，包括函数、基本数据类型、自定义数据类型等等，这其中最复杂的就是对象内部存储的数据结构(引用)，包括类属性、数据描述符、实例属性及非数据描述符，不仅它们的优先级不一样，而且它们的回调函数也存在很大的差异，这也是本文需要阐述的地方。</p>
<p>如果以前有过Javascript的编程经验，初上Python肯定会对“.”运算符与“[]”之间的差异难以理解，它们不仅不能替换，而且完全不相关，如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mem = &#123;<span class="string">&#x27;username&#x27;</span>: <span class="string">&#x27;yiifaa&#x27;</span>&#125;</span><br><span class="line"><span class="comment"># 无法通过.运算符进行计算</span></span><br><span class="line">mem.username</span><br><span class="line"><span class="comment"># 声明String</span></span><br><span class="line">name = <span class="built_in">str</span>(<span class="string">&#x27;yiifaa&#x27;</span>)</span><br><span class="line"><span class="comment"># 无法使用“[]”运算符</span></span><br><span class="line">name[<span class="string">&#x27;upper&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p><strong>1. 为实例添加“[]”运算符支持</strong></p>
<p>这也是“<em>_ getattribute_</em>”与“<em>_ getitem_</em>”的最大差异，示例如下：<br>“<em>_ getattribute_</em>”只适用于所有的“.”运算符；<br>“<em>_ getitem_</em>”只适用于所有的“[]”运算符；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, username, age</span>):</span></span><br><span class="line">        self.username = username</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattribute__</span>(<span class="params">self, attr</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>(Employee, self).__getattribute__(attr)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span>(<span class="params">self, attr</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>(Employee, self).__getattribute__(attr)</span><br><span class="line"></span><br><span class="line">em = Employee(<span class="string">&#x27;yiifaa&#x27;</span>, <span class="number">32</span>)</span><br><span class="line"><span class="built_in">print</span> em.username</span><br><span class="line"><span class="comment">#   现在支持“[]”运算符</span></span><br><span class="line"><span class="built_in">print</span> em[<span class="string">&#x27;username&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>通过实现“<em>_ getitem_</em>”回调接口，现在Employee可以支持“[]”运算符。</p>
<ol start="2">
<li><strong>避免语法错误错误</strong></li>
</ol>
<p>在对象属性的调用中，如果没有调用了不存在的属性，则Python解释器会报错，如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">AttributeError: <span class="string">&#x27;str&#x27;</span> <span class="built_in">object</span> has no attribute <span class="string">&#x27;length&#x27;</span></span><br></pre></td></tr></table></figure>

<p>通过覆盖实现“<em>_ getattr_</em>”回调接口可以解决此问题，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#   直接返回空对象，将此方法添加到类Employee的声明中</span><br><span class="line">def __getattr__(self, attr):</span><br><span class="line">    return None</span><br><span class="line"></span><br><span class="line"># 现在调用不存在的属性也不会报错</span><br><span class="line">print em.company</span><br></pre></td></tr></table></figure>

<p>那“<em>_ getattribute_</em>”与“<em>_ getattr_</em>”的最大差异在于：</p>
<ol>
<li>无论调用对象的什么属性，包括不存在的属性，都会首先调用“<em>_ getattribute_</em>”方法；</li>
<li>只有找不到对象的属性时，才会调用“<em>_ getattr_</em>”方法；</li>
</ol>
<p><strong>3. 将对象作为数据描述符</strong></p>
<p>这就是“<em>_ get_</em>”的作用了，将整个对象都作为数据描述符，但是请记住<strong>，要想_ get_作为数据描述符，那么此对象只能作为类属性</strong>，作为实例属性则无效，如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dept</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">          self.name = name</span><br><span class="line"></span><br><span class="line">      <span class="comment"># target是拥有此属性的对象</span></span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">__get__</span>(<span class="params">self, target, <span class="built_in">type</span>=<span class="literal">None</span></span>):</span></span><br><span class="line">        <span class="comment"># 默认返回self与obj都可以</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Dept&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Company</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="comment">#   一定要作为类属性，作为实例属性无效</span></span><br><span class="line">    dept = Dept(<span class="string">&#x27;organ&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 现在的测试结果</span></span><br><span class="line">x = Company()</span><br><span class="line"><span class="comment">#   返回True</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">type</span>(x.dept) == <span class="built_in">str</span></span><br></pre></td></tr></table></figure>

<p><strong>4. 获取对象属性数据的三种方法</strong></p>
<p>对象的所有属性都存储在“<em>_ dict_</em>”中（启用了“<em>_ slots_</em>”除外），所以访问对象的属性数据有如下三种方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print yiifaa.name</span><br><span class="line">print yiifaa.__dict__[&#39;name&#39;]</span><br><span class="line">print getattr(yiifaa, &#39;name&#39;)</span><br></pre></td></tr></table></figure>

<p><strong>结论</strong></p>
<p>每个以“__ get”为前缀的方法都是获取对象内部数据的钩子，但名称不一样，用途也存在较大的差异，只有在实践中理解它们，才能真正掌握它们的用法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">class Examp(object):</span><br><span class="line">    def __init__(self, username, age):</span><br><span class="line">        self.username &#x3D; username</span><br><span class="line">        self.age &#x3D; age</span><br><span class="line"></span><br><span class="line">    # 1. “_ getattribute_”只适用于所有的“.”运算符；</span><br><span class="line">    def __getattribute__(self, item):</span><br><span class="line">        print(&#39;---getattribute----&#39;)</span><br><span class="line">        return super(Examp, self).__getattribute__(item)</span><br><span class="line"></span><br><span class="line">    # 2. “_ getitem_”只适用于所有的“[]”运算符；</span><br><span class="line">    def __getitem__(self, item):</span><br><span class="line">        print(&#39;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;getitem&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#39;)</span><br><span class="line">        return super(Examp, self).__getattribute__(item)</span><br><span class="line"></span><br><span class="line">    # 3. 解决了访问不存在的属性报错问题, 找不到属性时会被调用：</span><br><span class="line">    def __getattr__(self, item):</span><br><span class="line">        return None</span><br><span class="line"></span><br><span class="line">    # 4. ““__get__””作为数据描述符，那么此对象只能作为类属性，作为实例属性则无效</span><br><span class="line">    def __get__(self, instance, owner):</span><br><span class="line">        # instance 访问此描述符的对象若通过类访问则为None   ower 指所有者的类</span><br><span class="line">        # print(id(instance), id(owner),id(Obj1))</span><br><span class="line">        print(&#39;____get____&#39;)</span><br><span class="line">        return self</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">em &#x3D; Examp(&#39;xiao66&#39;, 32)</span><br><span class="line"># print(em.username) # 输出 ---getattribute----  xiao66</span><br><span class="line"># print(em[&#39;username&#39;]) # 输出 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;getitem&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; xiao66</span><br><span class="line"># print(em.length) # 输出 ---getattribute---- None</span><br><span class="line"></span><br><span class="line"># 获取对象属性的三种方法</span><br><span class="line"># print(em.username)</span><br><span class="line"># print(em.__dict__[&#39;username&#39;])</span><br><span class="line"># print(getattr(em, &#39;username&#39;))</span><br><span class="line"></span><br><span class="line"># __get__ 作用</span><br><span class="line">class Obj1(object):</span><br><span class="line">    #一定要作为类属性，作为实例属性无效</span><br><span class="line">    attr &#x3D; Examp(&#39;xiao66&#39;,12)</span><br><span class="line"></span><br><span class="line">x &#x3D; Obj1()</span><br><span class="line">print(x.attr)</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong><br>“__getattribute__”与“__getattr__”的最大差异在于：<br>1.无论调用对象的什么属性，包括不存在的属性，都会首先调用“__getattribute__”方法；<br>2.只有找不到对象的属性时，才会调用“__getattr__”方法；</p>
<p>仅希望以某种特殊的方式使用少数属性，而其他属性则按照普通属性操作。这些普通属性不会触发任何特殊代码，也不会因为遍历方法代码而浪费时间。在这些情况下，您可以对属性使用描述符<br>每次访问descriptor（即实现了__get__的类），都会先经过__get__函数。</p>
<p>需要注意的是，当使用类访问不存在的变量是，不会经过__getattr__函数。而descriptor不存在此问题，只是把instance标识为none而已</p>
<h2 id="快捷操作"><a href="#快捷操作" class="headerlink" title="[快捷操作]"></a>[快捷操作]</h2><h3 id="map-【映射】"><a href="#map-【映射】" class="headerlink" title="map()【映射】"></a>map()【映射】</h3><h3 id="–【函数，参数值】"><a href="#–【函数，参数值】" class="headerlink" title="–【函数，参数值】"></a>–【函数，参数值】</h3><p>接受迭代函数和迭代对象（list，tuple，dictionary）</p>
<p>返回迭代对象（return 物理地址）</p>
<p>可以根据输入的迭代参数对return的值进行可视化展示譬如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>))</span><br><span class="line">y = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>))</span><br><span class="line"></span><br><span class="line">print(<span class="built_in">map</span>(<span class="keyword">lambda</span> x, y: x * y, x, y), end=<span class="string">&#x27;\n\n&#x27;</span>)</span><br><span class="line">print(<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x, y: x * y, x, y)))</span><br><span class="line"></span><br><span class="line">&gt;&gt;</span><br><span class="line">&lt;<span class="built_in">map</span> <span class="built_in">object</span> at <span class="number">0x00000205E4273F48</span>&gt;</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>, <span class="number">100</span>]</span><br></pre></td></tr></table></figure>

<p>通俗的讲是接受函数和对应的参数（可迭代的），并返回最小参数长度所对应的函数的运算值的物理存储地址</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>(function, iterable, ...)</span><br></pre></td></tr></table></figure>

<p>它需要两个必须的参数：</p>
<ul>
<li><code>function</code> - 针对每一个迭代调用的函数</li>
<li><code>iterable</code> - 支持迭代的一个或者多个对象。在 Python 中大部分内建对象，例如 lists, dictionaries, 和 tuples 都是可迭代的。</li>
</ul>
<p>在 Python 3 中，<code>map()</code>返回一个与传入可迭代对象大小一样的 map 对象。在 Python 2中，这个函数返回一个列表 list。</p>
<p>其中function可以使用lambda关键词替换</p>
<p>你可以将任意多的可迭代对象传递给map()函数。回调函数接受的必填输入参数的数量，必须和可迭代对象的数量一致。</p>
<p>下面的例子显示如何在两个列表上执行元素级别的操作：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multiply</span>(<span class="params">x, y</span>):</span></span><br><span class="line">	<span class="keyword">return</span> x * y</span><br><span class="line"> </span><br><span class="line">a = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>]</span><br><span class="line">b = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line"> </span><br><span class="line">result = <span class="built_in">map</span>(multiply, a, b)</span><br><span class="line"> </span><br><span class="line">print(<span class="built_in">list</span>(result))</span><br><span class="line">&gt;&gt;</span><br><span class="line">[<span class="number">2</span>, <span class="number">12</span>, <span class="number">30</span>]</span><br></pre></td></tr></table></figure>

<p>同样的代码，使用 lambda 函数，会像这样：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>]</span><br><span class="line">b = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line"> </span><br><span class="line">result = <span class="built_in">map</span>(<span class="keyword">lambda</span> x, y: x*y, a, b)</span><br><span class="line"> </span><br><span class="line">print(<span class="built_in">list</span>(result))</span><br></pre></td></tr></table></figure>

<p>当提供多个可迭代对象时，返回对象的数量大小和最短的迭代对象的数量一致。</p>
<p>让我们看看一个例子，当可迭代对象的长度不一致时：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>]</span><br><span class="line">b = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line"> </span><br><span class="line">result = <span class="built_in">map</span>(<span class="keyword">lambda</span> x, y: x*y, a, b)</span><br><span class="line"> </span><br><span class="line">print(<span class="built_in">list</span>(result))</span><br></pre></td></tr></table></figure>

<p>超过的元素 （7 和 8 ）被忽略了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">2</span>, <span class="number">12</span>, <span class="number">30</span>]</span><br></pre></td></tr></table></figure>

<p><strong>三、总结</strong></p>
<p>Python 的 <code>map()</code>函数作用于一个可迭代对象，使用一个函数，并且将函数应用于这个可迭代对象的每一个元素。</p>
<h3 id="lambda【匿名函数】"><a href="#lambda【匿名函数】" class="headerlink" title="lambda【匿名函数】"></a>lambda【匿名函数】</h3><h3 id="–【变量：表达式】"><a href="#–【变量：表达式】" class="headerlink" title="–【变量：表达式】"></a>–【变量：表达式】</h3><p>本质上讲为<strong>匿名函数</strong>，接受变量和表达式</p>
<p>使用语法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lambda</span> argument_list:expersion</span><br></pre></td></tr></table></figure>

<ul>
<li>argument_list：变量列表</li>
<li>expression：表达式</li>
</ul>
<p><strong>lambda 常常和map（）函数结合使用</strong></p>
<h3 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h3><p><strong>字典中的get操作</strong></p>
<p>return: 返回字典中key对应value值，如果没有就return None， 而get函数可以将没有的key进行操作</p>
<p>dict.get(key, default=None)</p>
<ul>
<li>key – 字典中要查找的键。</li>
<li>default – 如果指定键的值不存在时，返回该默认值。</li>
</ul>
<p>返回指定键的值，如果键不在字典中返回默认值 None 或者设置的默认值。</p>
<h3 id="split"><a href="#split" class="headerlink" title="split()"></a>split()</h3><p><strong>return</strong> <strong>list</strong></p>
<p>Python <strong>split()</strong> 通过指定分隔符对字符串进行切片，如果参数 num 有指定值，则分隔 num+1 个子字符串</p>
<p>string.split(sep=’’, maxsplit=num)</p>
<ul>
<li>sep–&gt;分隔符，默认为所有的空字符，包括空格、换行(\n)、制表符(\t)等默认情况下不显示sep，直接输入需要splitstr即可。</li>
<li>maxsplit– &gt;分割次数。默认为 -1, 即分隔所有。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">temp = <span class="built_in">input</span>().split(sep=<span class="string">&#x27;**&#x27;</span>, maxsplit=-<span class="number">1</span>)</span><br><span class="line">print(temp)</span><br><span class="line">&gt;&gt;</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> ** <span class="number">4</span></span><br><span class="line">[<span class="string">&#x27;1 2 3 &#x27;</span>, <span class="string">&#x27; 4&#x27;</span>]</span><br></pre></td></tr></table></figure>



<h3 id="print"><a href="#print" class="headerlink" title="print()"></a>print()</h3><p>print(objectes, sep=’’, end=’\n’, flush=False, file=sys.stdout)</p>
<ul>
<li>objects:需要输出的对象</li>
<li>sep:以什么间隔default:space</li>
<li>end:以什么结尾default:\n</li>
<li>file:是要写入的对象,其中sys.stdout为python的标准输出</li>
<li>flush:输出是否被缓存通常决定于 file，但如果 flush 关键字参数为 True，流会被强制刷新</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line">print(<span class="string">&#x27;Loading&#x27;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="comment"># 以end=&#x27;&#x27;结尾防止Loading后面的&quot;.&quot;换行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>):</span><br><span class="line">    print(<span class="string">&#x27;.&#x27;</span>, end=<span class="string">&#x27;&#x27;</span>, flush=<span class="literal">True</span>)</span><br><span class="line">    time.sleep(<span class="number">0.5</span>)</span><br></pre></td></tr></table></figure>

<p><img src="https://www.runoob.com/wp-content/uploads/2017/04/loading-example.gif" alt="img"></p>
<h3 id="ljust-center"><a href="#ljust-center" class="headerlink" title="ljust/center"></a>ljust/center</h3><p>对于需要填充的字符串一种快捷操作</p>
<ul>
<li><p>ljust(width, char)–&gt;左对齐–&gt;右填充</p>
</li>
<li><p>rjust(width, char)–&gt;右对齐–&gt;左tianchong</p>
</li>
<li><p>center(width, char)–&gt;中间对齐–&gt;两边填充</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&#x27;  123  &#x27;</span></span><br><span class="line">print(<span class="built_in">len</span>(<span class="built_in">str</span>))</span><br><span class="line">print(<span class="built_in">str</span>.ljust(<span class="number">10</span>, <span class="string">&#x27;*&#x27;</span>))</span><br><span class="line">print(<span class="built_in">str</span>.rjust(<span class="number">10</span>, <span class="string">&#x27;*&#x27;</span>))</span><br><span class="line">print(<span class="built_in">str</span>.center(<span class="number">10</span>, <span class="string">&#x27;*&#x27;</span>))</span><br><span class="line">&gt;&gt;</span><br><span class="line"><span class="number">7</span></span><br><span class="line">  <span class="number">123</span>  ***</span><br><span class="line">***  <span class="number">123</span>  </span><br><span class="line">*  <span class="number">123</span>  **</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="‘’-join"><a href="#‘’-join" class="headerlink" title="‘’.join()"></a>‘’.join()</h3><p>将list中的element转化成string,其中”char”中的符号为间隔填充符,但是如果list中只有数字,将不能直接转化,需要遍历列表,将列表中的内容转化成字符串:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">alist = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="comment"># True</span></span><br><span class="line">print(<span class="string">&#x27;&#x27;</span>.join(<span class="string">&#x27;%s&#x27;</span> %i <span class="keyword">for</span> i <span class="keyword">in</span> alist))</span><br><span class="line"></span><br><span class="line"><span class="comment"># False</span></span><br><span class="line">print(<span class="string">&#x27;&#x27;</span>.join(alist))</span><br><span class="line">&gt;&gt;</span><br><span class="line">TypeError: sequence item <span class="number">3</span>: expected <span class="built_in">str</span> instance, <span class="built_in">int</span> found</span><br></pre></td></tr></table></figure>

<h3 id="int"><a href="#int" class="headerlink" title="int()"></a>int()</h3><p>int()可以快速的实现进制的转换</p>
<p>int(num, base)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="built_in">int</span>(num, base=n))</span><br><span class="line"><span class="comment"># 在base进制下的num表示成10j</span></span><br><span class="line"></span><br><span class="line">num=<span class="number">110</span>, base=<span class="number">2</span></span><br><span class="line">&gt;&gt;<span class="number">6</span></span><br></pre></td></tr></table></figure>

<h3 id="eval"><a href="#eval" class="headerlink" title="eval()"></a>eval()</h3><p>eval() 函数用来执行一个字符串表达式，并返回表达式的值。</p>
<p>以下是 eval() 方法的语法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eval(expression[, globals[, locals]])</span><br></pre></td></tr></table></figure>

<p><strong>参数</strong></p>
<ul>
<li>expression – 表达式。</li>
<li>globals – 变量作用域，全局命名空间，如果被提供，则必须是一个字典对象。</li>
<li>locals – 变量作用域，局部命名空间，如果被提供，可以是任何映射对象。</li>
</ul>
<p><strong>返回值</strong></p>
<p>返回表达式计算结果。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;x = <span class="number">7</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">eval</span>( <span class="string">&#x27;3 * x&#x27;</span> )</span><br><span class="line"><span class="number">21</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">eval</span>(<span class="string">&#x27;pow(2,2)&#x27;</span>)</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">eval</span>(<span class="string">&#x27;2 + 2&#x27;</span>)</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>n=<span class="number">81</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">eval</span>(<span class="string">&quot;n + 4&quot;</span>)</span><br><span class="line"><span class="number">85</span></span><br></pre></td></tr></table></figure>

<h3 id="bin"><a href="#bin" class="headerlink" title="bin()"></a>bin()</h3><p><strong>bin()</strong> 返回一个整数 int 或者长整数 long int 的二进制表示。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="built_in">bin</span>(<span class="number">10</span>))</span><br><span class="line">&gt;&gt;</span><br><span class="line"><span class="number">0b1010</span></span><br><span class="line"><span class="comment"># 0b 指二进制标识，在c语言中用0b标识二进制</span></span><br></pre></td></tr></table></figure>

<h3 id="format"><a href="#format" class="headerlink" title=".format()"></a>.format()</h3><p>Python2.6 开始，新增了一种格式化字符串的函数 **str.format()**，它增强了字符串格式化的功能。</p>
<p>基本语法是通过 <strong>{}</strong> 和 <strong>:</strong> 来代替以前的 <strong>%</strong> 。</p>
<p>format 函数可以接受不限个参数，位置可以不按顺序。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="string">&quot;&#123;&#125; &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>)    </span><br><span class="line"><span class="comment"># 不设置指定位置，按默认顺序</span></span><br><span class="line"><span class="string">&#x27;hello world&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;&#123;0&#125; &#123;1&#125;&quot;</span>.<span class="built_in">format</span>(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>)  </span><br><span class="line"><span class="comment"># 设置指定位置</span></span><br><span class="line"><span class="string">&#x27;hello world&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;&#123;1&#125; &#123;0&#125; &#123;1&#125;&quot;</span>.<span class="built_in">format</span>(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>) </span><br><span class="line"><span class="comment"># 设置指定位置</span></span><br><span class="line"><span class="string">&#x27;world hello world&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="sys"><a href="#sys" class="headerlink" title="[sys]"></a>[sys]</h2><h3 id="stdin-readline"><a href="#stdin-readline" class="headerlink" title=".stdin.readline()"></a>.stdin.readline()</h3><h3 id="stdin-read"><a href="#stdin-read" class="headerlink" title=".stdin.read()"></a>.stdin.read()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">line = sys.stdin.readline()     <span class="comment"># 读取一行（包括换行符）</span></span><br><span class="line">char = sys.stdin.read(<span class="number">1</span>)        <span class="comment"># 读取一个字节</span></span><br><span class="line">lines = sys.stdin.read()        <span class="comment"># 读取到文件尾</span></span><br></pre></td></tr></table></figure>

<p>Python中常用到的两种标准化输入方式：分别sys.stdin和input，两者使用方式大致相同，但是总的来说sys.stdin使用方式更加多样化一些，下面就例子说明两者之间的使用差别。</p>
<ul>
<li>python3中使用sys.stdin.readline()可以实现标准输入，其中默认输入的格式是字符串，如果是int，float类型则需要强制转换。</li>
</ul>
<h2 id="特殊方法"><a href="#特殊方法" class="headerlink" title="[特殊方法]"></a>[特殊方法]</h2><h3 id="count"><a href="#count" class="headerlink" title="count()"></a>count()</h3><p>可以统计在list\tuple\string中某个element\string出现的次数</p>
<ul>
<li>list.count(element)</li>
<li>string.count(string, strat, end)</li>
</ul>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><em>value</em></td>
<td align="left">必需。字符串。要检索的字符串。</td>
</tr>
<tr>
<td align="left"><em>start</em></td>
<td align="left">可选。整数。开始检索的位置。默认是 0。</td>
</tr>
<tr>
<td align="left"><em>end</em></td>
<td align="left">可选。整数。结束检索的位置。默认是字符串的结尾。</td>
</tr>
</tbody></table>
<h3 id="strip"><a href="#strip" class="headerlink" title="strip()"></a>strip()</h3><p>Python strip() 方法用于移除字符串头尾指定的字符（默认为空格或换行符）或字符序列。</p>
<p><strong>注意：</strong>该方法只能删除开头或是结尾的字符，不能删除中间部分的字符。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">str1 = <span class="string">&quot;00000003210Runoob01230000000&quot;</span>; </span><br><span class="line">print(str1.strip( <span class="string">&#x27;0&#x27;</span> ))	 <span class="comment"># 去除首尾字符 0</span></span><br><span class="line"> </span><br><span class="line">str2 = <span class="string">&quot;   Runoob      &quot;</span>   <span class="comment"># 去除首尾空格</span></span><br><span class="line">print(str2.strip())</span><br><span class="line">&gt;&gt;</span><br><span class="line">3210Runoob0123</span><br><span class="line">Runoob</span><br></pre></td></tr></table></figure>

<p><strong>一、默认用法：去除空格</strong></p>
<ul>
<li>str.strip()  ： 去除字符串两边的空格</li>
<li>str.lstrip() ： 去除字符串左边的空格</li>
<li>str.rstrip() ： 去除字符串右边的空格</li>
</ul>
<p>注：此处的空格包含’\n’, ‘\r’,  ‘\t’,  ‘ ‘</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="string">&#x27; abc de a  1&#x27;</span></span><br><span class="line">print(a.strip())</span><br><span class="line">print(a.lstrip())</span><br><span class="line">print(a.rstrip())</span><br><span class="line">&gt;&gt;</span><br><span class="line">abc de a  <span class="number">1</span></span><br><span class="line">abc de a  <span class="number">1</span></span><br><span class="line"> abc de a  <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>二、去除指定字符</strong></p>
<ul>
<li>str.strip(‘do’)  ：去除字符串两端指定的字符</li>
<li>str.lstrip(‘do’) ：用于去除左边指定的字符</li>
<li>str.rstrip(‘do’) ：用于去除右边指定的字符</li>
</ul>
<p>三个函数都可以传入一个参数(这里以’do’为例)，指定要去除的首尾字符，编译器会去除两端所有相应的字符，直到没有匹配的字符。</p>
<p><code>指定的字符表示的一种组合，例如&#39;do&#39;表示&#39;dd&#39;,&#39;do&#39;,&#39;od&#39;,&#39;oo&#39;,&#39;ddd&#39;,&#39;ooo&#39;等</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">dodo = <span class="string">&quot;say hello say boy saaayaaas&quot;</span>  </span><br><span class="line"></span><br><span class="line">print(dodo.strip(<span class="string">&#x27;say&#x27;</span>) ) </span><br><span class="line">print(dodo.strip(<span class="string">&#x27;yas&#x27;</span>) )  </span><br><span class="line"><span class="comment">#当传入的参数中加入空格时  </span></span><br><span class="line">print(dodo.strip(<span class="string">&#x27;say &#x27;</span>) )</span><br><span class="line"></span><br><span class="line">print(dodo.lstrip(<span class="string">&#x27;say&#x27;</span>) ) </span><br><span class="line">print(dodo.rstrip(<span class="string">&#x27;say&#x27;</span>) ) </span><br><span class="line"></span><br><span class="line">hello say boy </span><br><span class="line"> hello say boy </span><br><span class="line">hello say bo</span><br><span class="line"> hello say boy saaayaaas</span><br><span class="line">say hello say boy </span><br></pre></td></tr></table></figure>

<h3 id="处理异常"><a href="#处理异常" class="headerlink" title="处理异常"></a>处理异常</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    可能产生异常的代码块</span><br><span class="line"><span class="keyword">except</span> [ (Error1, Error2, ... ) /[<span class="keyword">as</span> e] ]:</span><br><span class="line">    处理异常的代码块<span class="number">1</span></span><br><span class="line"><span class="keyword">except</span> [ (Error3, Error4, ... ) /[<span class="keyword">as</span> e] ]:</span><br><span class="line">    处理异常的代码块<span class="number">2</span></span><br><span class="line"><span class="keyword">except</span>  [Exception]:</span><br><span class="line">    处理其它异常</span><br></pre></td></tr></table></figure>

<p>该格式中，[] 括起来的部分可以使用，也可以省略。其中各部分的含义如下：</p>
<ul>
<li>(Error1, Error2,…) 、(Error3, Error4,…)：其中，Error1、Error2、Error3 和 Error4 都是具体的异常类型。显然，一个 except 块可以同时处理多种异常。</li>
<li>[as e]：作为可选参数，表示给异常类型起一个别名 e，这样做的好处是方便在 except 块中调用异常类型（后续会用到）。</li>
<li>[Exception]：作为可选参数，可以代指程序可能发生的所有异常情况，其通常用在最后一个 except 块。</li>
</ul>
<p>try except 语句的执行流程如下：</p>
<ol>
<li>首先执行 try 中的代码块，如果执行过程中出现异常，系统会自动生成一个异常类型，并将该异常提交给 Python 解释器，此过程称为捕获异常。</li>
<li>当 Python 解释器收到异常对象时，会寻找能处理该异常对象的 except 块，如果找到合适的 except 块，则把该异常对象交给该 except 块处理，这个过程被称为处理异常。如果 Python 解释器找不到处理异常的 except 块，则程序运行终止，Python 解释器也将退出。</li>
</ol>
<p>通过前面的学习，我们已经可以捕获程序中可能发生的异常，并对其进行处理。但是，由于一个 except 可以同时处理多个异常，那么我们如何知道当前处理的到底是哪种异常呢？</p>
<p>其实，每种异常类型都提供了如下几个属性和方法，通过调用它们，就可以获取当前处理异常类型的相关信息：</p>
<ul>
<li>args：返回异常的错误编号和描述字符串；</li>
<li>str(e)：返回异常信息，但不包括异常信息的类型；</li>
<li>repr(e)：返回较全的异常信息，包括异常信息的类型。</li>
</ul>
<p>举个例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">	<span class="number">1</span>/<span class="number">0</span></span><br><span class="line">	<span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="comment"># 访问异常的错误编号和详细信息</span></span><br><span class="line">print(e.args)    </span><br><span class="line">print(<span class="built_in">str</span>(e))    </span><br><span class="line">print(<span class="built_in">repr</span>(e))</span><br><span class="line"></span><br><span class="line">&gt;&gt;</span><br><span class="line">(<span class="string">&#x27;division by zero&#x27;</span>,)</span><br><span class="line">division by zero</span><br><span class="line">ZeroDivisionError(<span class="string">&#x27;division by zero&#x27;</span>,)</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<p>(‘division by zero’,)<br>division by zero<br>ZeroDivisionError(‘division by zero’,)</p>
<h3 id="isdigit"><a href="#isdigit" class="headerlink" title="isdigit()"></a>isdigit()</h3><p>str.isdigit()</p>
<ul>
<li>不需要任何参数</li>
<li>返回True False</li>
<li>检测字符串是否只有数字组成</li>
</ul>
<h3 id="ord-–chr"><a href="#ord-–chr" class="headerlink" title="ord()–chr()"></a>ord()–chr()</h3><p>ord():返回对应的ASCII值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(ord(&#39;A&#39;))</span><br><span class="line">&gt;&gt;65</span><br></pre></td></tr></table></figure>

<p>chr():返回对应的 Unicode 数值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(chr(65))</span><br><span class="line">&gt;&gt;A</span><br></pre></td></tr></table></figure>

<h3 id="slots"><a href="#slots" class="headerlink" title="slots"></a>slots</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__slots__</span><br></pre></td></tr></table></figure>

<ol>
<li>节省memory。在上面的例子里，如果我们看看<code>bar</code>和<code>slotted_bar</code>就看到，<code>slotted_bar</code>并没有<code>__dict__</code>而<code>bar</code>却含有<code>__dict__</code>。<code>__slots__</code>正是通过避免定义动态的数据结构<code>__dict__</code>来实现对memory的节省，大约能节省30%的memory</li>
<li>.access attributes更快。事实上，在CPython的实现里，<code>__slots__</code>是一个静态数据结构（static），里面存的是value references，比<code>__dict__</code>更快</li>
</ol>
<p>此处要注意一点，正因为<code>__slots__</code>是static的，定义了<code>__slots__</code>之后，你将不能创造新的attribute</p>
<p>如果你想获得<code>__slots__</code>的好处并且可以创造新的attribute，你可以将<code>__dict__</code>作为<code>__slots__</code>中的一个element（见下面code）：</p>
<p><strong>什么情况下该使用<code>__slots__</code>?</strong></p>
<p>当你事先知道class的attributes的时候，建议使用slots来节省memory以及获得更快的attribute access。</p>
<p>注意不应当把防止创造<code>__slots__</code>之外的新属性作为使用<code>__slots__</code>的原因，可以使用decorators以及getters，setters来实现attributes control。</p>
<p><strong>使用<code>__slots__</code>的特殊注意事项</strong></p>
<ol>
<li>当inherit from a slotted class，那么子类自动变成slotted并且获得parent class的slots；子类可以定义新的elements加入到inherited slots里。slots里面的每一个element，只能在inheritance里面定义一次（否则就是redundant）</li>
<li>在multiple inheritance（比如mixedins）里，如果两个parents定义了不同的nonempty __slots__，那么python会报错。这个时候，就进一步factor out 母类的slots。</li>
</ol>
<h3 id="if–name–-’–main–’"><a href="#if–name–-’–main–’" class="headerlink" title="if–name–==’–main–’:"></a>if–name–==’–main–’:</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br></pre></td></tr></table></figure>

<p>当你在写 .py 的时候</p>
<p>一般是以两种方式存在的</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> <strong>1、作为脚本直接运行</strong> </li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/20210529144951.png"></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> <strong>2、作为模块给别人导入</strong></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/20210529145101.png"></p>
<p>的代码在被执行的时候，Python 解释器会先去读取你的 Python 代码然后定义一些全局的内置变量，而我们常常写的这个 –name–就是其中的变量之一，如果判断出 –name– 的值是 –main–就说明这里是程序入口，而非被别的 py 文件 import</p>
<p>所以你的 .py 可以作为自己的脚本运行，在 –main– 中做一些测试，或者本身程序的运行，当然你也可以使用你的 .py 作为模块给别人使用，给别人提供一些便利，为了不让别人一导入你的模块就直接运行整个脚本那么使用 **if –name– == ‘–main–’**其中的代码就不会在被 import 时被执行。</p>
<h3 id="yield-lt-gt-send-gt-next"><a href="#yield-lt-gt-send-gt-next" class="headerlink" title="yield&lt;==&gt;send==&gt;next"></a>yield&lt;==&gt;send==&gt;next</h3><p>首先，如果你还没有对yield有个初步分认识，那么你先把yield看做“return”，这个是直观的，它首先是个return，普通的return是什么意思，就是在程序中返回某个值，返回之后程序就不再往下运行了。看做return之后再把它看做一个是生成器（generator）的一部分（带yield的函数才是真正的迭代器），好了，如果你对这些不明白的话，那先把yield看做return,然后直接看下面的程序，你就会明白yield的全部意思了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>():</span></span><br><span class="line">    print(<span class="string">&quot;starting...&quot;</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        res = <span class="keyword">yield</span> <span class="number">4</span></span><br><span class="line">        print(<span class="string">&quot;res:&quot;</span>,res)</span><br><span class="line">g = foo()</span><br><span class="line">print(<span class="built_in">next</span>(g))</span><br><span class="line">print(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line">print(<span class="built_in">next</span>(g))</span><br><span class="line">&gt;&gt;</span><br><span class="line">starting...</span><br><span class="line"><span class="number">4</span></span><br><span class="line">********************</span><br><span class="line">res: <span class="literal">None</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>我直接解释代码运行顺序，相当于代码单步调试：</p>
<ol>
<li><p>程序开始执行以后，因为foo函数中有yield关键字，所以foo函数并不会真的执行，而是先得到一个生成器g(相当于一个对象)</p>
</li>
<li><p>直到调用next方法，foo函数正式开始执行，先执行foo函数中的print方法，然后进入while循环</p>
</li>
<li><p>程序遇到yield关键字，然后把yield想想成return,return了一个4之后，程序停止，并没有执行赋值给res操作，此时next(g)语句执行完成，所以输出的前两行（第一个是while上面的print的结果,第二个是return出的结果）是执行print(next(g))的结果，</p>
</li>
<li><p>程序执行print(“*”<em>20)，输出20个</em></p>
</li>
<li><p>又开始执行下面的print(next(g)),这个时候和上面那个差不多，不过不同的是，这个时候是从刚才那个next程序停止的地方开始执行的，也就是要执行res的赋值操作，这时候要注意，这个时候赋值操作的右边是没有值的（因为刚才那个是return出去了，并没有给赋值操作的左边传参数），所以这个时候res赋值是None,所以接着下面的输出就是res:None,</p>
</li>
<li><p>程序会继续在while里执行，又一次碰到yield,这个时候同样return 出4，然后程序停止，print函数输出的4就是这次return出的4.</p>
</li>
</ol>
<p>到这里你可能就明白yield和return的关系和区别了，带yield的函数是一个生成器，而不是一个函数了，这个生成器有一个函数就是next函数，next就相当于“下一步”生成哪个数，这一次的next开始的地方是接着上一次的next停止的地方执行的，所以调用next的时候，生成器并不会从foo函数的开始执行，只是接着上一步停止的地方开始，然后遇到yield后，return出要生成的数，此步就结束。</p>
<hr>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>():</span></span><br><span class="line">    print(<span class="string">&quot;starting...&quot;</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        res = <span class="keyword">yield</span> <span class="number">4</span></span><br><span class="line">        print(<span class="string">&quot;res:&quot;</span>,res)</span><br><span class="line">        </span><br><span class="line">g = foo()</span><br><span class="line">print(<span class="built_in">next</span>(g))</span><br><span class="line">print(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line">print(g.send(<span class="number">7</span>))</span><br><span class="line">&gt;&gt;</span><br><span class="line">starting...</span><br><span class="line"><span class="number">4</span></span><br><span class="line">********************</span><br><span class="line">res: <span class="number">7</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>先大致说一下send函数的概念：此时你应该注意到上面那个的紫色的字，还有上面那个res的值为什么是None，这个变成了7，到底为什么，这是因为，send是发送一个参数给res的，因为上面讲到，return的时候，并没有把4赋值给res，下次执行的时候只好继续执行赋值操作，只好赋值为None了，而如果用send的话，开始执行的时候，先接着上一次（return 4之后）执行，先把7赋值给了res,然后执行next的作用，遇见下一回的yield，return出结果后结束。</p>
<ol>
<li><p>程序执行g.send(7)，程序会从yield关键字那一行继续向下运行，send会把7这个值赋值给res变量</p>
</li>
<li><p>由于send方法中包含next()方法，所以程序会继续向下运行执行print方法，然后再次进入while循环</p>
</li>
<li><p>程序执行再次遇到yield关键字，yield会返回后面的值后，程序再次暂停，直到再次调用next方法或send方法。</p>
</li>
</ol>
<p><strong>简要理解：yield就是 return 返回一个值，并且记住这个返回的位置，下次迭代就从这个位置后开始。</strong></p>
<h2 id="关键字"><a href="#关键字" class="headerlink" title="[关键字]"></a>[关键字]</h2><h3 id="global"><a href="#global" class="headerlink" title="global"></a>global</h3><p>Python变量的作用域一共有4种，分别是：</p>
<ul>
<li>L （Local） 局部作用域</li>
<li>E （Enclosing） 闭包函数外的函数中</li>
<li>G （Global） 全局作用域</li>
<li>B （Built-in） 内建作用域 以 L –&gt; E –&gt; G –&gt;B 的规则查找，即：在局部找不到，便会去局部外的局部找（例如闭包），再找不到就会去全局找，再者去内建中找。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># instance 1</span></span><br><span class="line">x = <span class="number">5</span> <span class="comment"># global</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun_a</span>():</span></span><br><span class="line">    x = <span class="number">4</span> <span class="comment"># local</span></span><br><span class="line">    print(x)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun_b</span>():</span></span><br><span class="line">    x = <span class="number">3</span></span><br><span class="line">    print(x)</span><br><span class="line">    </span><br><span class="line">print(x)</span><br><span class="line">fun_a()</span><br><span class="line">fun_b()</span><br><span class="line">&gt;&gt;\n</span><br><span class="line"><span class="number">5</span> <span class="number">4</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># instance 2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun_a</span>():</span></span><br><span class="line">    x = <span class="number">5</span> <span class="comment"># enclosing</span></span><br><span class="line">    print(x)</span><br><span class="line">    <span class="keyword">return</span> fun_b</span><br><span class="line"></span><br><span class="line">b = fun_a()</span><br><span class="line">b()</span><br><span class="line">&gt;&gt;</span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># instance 3</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun_a</span>():</span></span><br><span class="line">    x = <span class="number">5</span> <span class="comment"># enclosing</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fun_b</span>():</span></span><br><span class="line">        x = <span class="number">4</span> <span class="comment"># local</span></span><br><span class="line">        print(x)</span><br><span class="line">    <span class="keyword">return</span> fun_b</span><br><span class="line">b = fun_a()</span><br><span class="line">b()</span><br><span class="line">&gt;&gt;</span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># instance 4</span></span><br><span class="line">x = <span class="number">5</span> <span class="comment"># global</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun_a</span>():</span></span><br><span class="line">    print(x)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun_b</span>():</span></span><br><span class="line">    print(x)</span><br><span class="line">fun_a()</span><br><span class="line">fun_b()</span><br><span class="line">&gt;&gt;\n</span><br><span class="line"><span class="number">5</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p><strong>结论：</strong></p>
<p>实例一： 即使变量同名，优先引用的是局部变量。</p>
<p>实例二 &amp; 实例三： 闭包的情况，如果内部函数没有局部变量，则会优先引用闭包的环境变量。</p>
<p>实例四： 引用全局变量。</p>
<hr>
<p>对于全局变量来说，既然能函数体内直接引用，并且程序没有报错，那为什么还要用 global 关键字？</p>
<p>现在在重新声明一个 func_c 函数，并且对这个 x 进行加 1 的操作。你觉得会打印什么结果？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># instance 5</span></span><br><span class="line">x = <span class="number">5</span> <span class="comment"># global --&gt;同名且有修改--&gt;认为def中的变量为局部变量</span></span><br><span class="line"><span class="function"><span class="keyword">def</span>  <span class="title">fun_a</span>():</span></span><br><span class="line">    print(x)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span>  <span class="title">fun_b</span>():</span></span><br><span class="line">    print(x)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span>  <span class="title">fun_c</span>():</span></span><br><span class="line">    x += <span class="number">1</span> <span class="comment"># 由于内部函数有引用外部函数的同名变量或者全局变量，并且对这个变量有修改的时候，此时 Python 会认为它是一个局部变量，而函数中并没有 x 的定义和赋值，所以报错。</span></span><br><span class="line">    print(x)</span><br><span class="line">fun_a()</span><br><span class="line">fun_b()</span><br><span class="line">fun_c()</span><br><span class="line">&gt;&gt;\n</span><br><span class="line"><span class="number">5</span> <span class="number">5</span></span><br><span class="line">UnboundLocalError: local variable <span class="string">&#x27;x&#x27;</span> referenced before assignment</span><br></pre></td></tr></table></figure>

<p>可以看到已经报错了 ，UnboundLocalError，错误代码第 9 行 x = x+1。</p>
<p><strong>在这个例子中设置的 x=5 属于全局变量,而在函数内部中没有对 x 的定义。</strong></p>
<p><strong>根据 Python 访问局部变量和全局变量的规则：当搜索一个变量的时候，Python 先从局部作用域开始搜索，如果在局部作用域没有找到那个变量，那样 Python 就会像上面的案例中介绍的作用域范围逐层寻找。</strong></p>
<p><strong>最终在全局变量中找这个变量，如果找不到则抛出 UnboundLocalError 异常。</strong></p>
<p>但你会想，明明已经在全局变量中找到同名变量了，怎么还是报错？</p>
<p><strong>因为内部函数有引用外部函数的同名变量或者全局变量，并且对这个变量有修改的时候，此时 Python 会认为它是一个局部变量，而函数中并没有 x 的定义和赋值，所以报错。</strong></p>
<hr>
<p>global 关键字为解决此问题而生，在函数 func_c中，显示地告诉解释器 x 为全局变量，然后会在函数外面寻找 x 的定义，执行完 x = x + 1 后，x 依然是全局变量。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># instance 6</span></span><br><span class="line">x = <span class="number">5</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun_a</span>():</span></span><br><span class="line">    print(x)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun_b</span>():</span></span><br><span class="line">    print(x)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun_c</span>():</span></span><br><span class="line">    <span class="keyword">global</span> x <span class="comment"># 定义def中的变量为全局变量,即先Enclosing-&gt;local--&gt;//global//-//-&gt;buinltin</span></span><br><span class="line">    x += <span class="number">1</span></span><br><span class="line">    print(x)</span><br><span class="line"></span><br><span class="line">fun_a()</span><br><span class="line">fun_b()</span><br><span class="line">fun_c()</span><br><span class="line">&gt;&gt;\n</span><br><span class="line"><span class="number">5</span> <span class="number">5</span> <span class="number">6</span></span><br></pre></td></tr></table></figure>

<h3 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h3><p>简要理解：yield就是 return 返回一个值，并且记住这个返回的位置，下次迭代就从这个位置后开始</p>
<ul>
<li>它首先是个<code>return：在程序中返回某个值，返回之后程序就不再往下运行了。</code></li>
<li>之后是生成器（generator）的一部分（带yield的函数才是真正的迭代器）</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>():</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        res = <span class="keyword">yield</span> <span class="number">4</span></span><br><span class="line">        print(<span class="string">&quot;res:&quot;</span>,res)</span><br><span class="line">g = foo()</span><br><span class="line">print(<span class="built_in">next</span>(g))  --|<span class="number">1</span>|</span><br><span class="line">print(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line">print(<span class="built_in">next</span>(g))</span><br><span class="line"></span><br><span class="line">&gt;&gt;</span><br><span class="line"><span class="number">4</span></span><br><span class="line">********************</span><br><span class="line">res: <span class="literal">None</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>1.程序开始执行以后，因为foo函数中有yield关键字，所以foo函数并不会真的执行，而是先得到一个生成器g(相当于一个对象)</p>
<p>2.直到调用next方法，foo函数正式开始执行，进入while循环</p>
<p>3.程序遇到yield关键字，然后把yield想想成return,return了一个4之后，程序停止，<strong>并没有执行赋值给res操作</strong>，此时next(g)语句执行完成，所以输出4（return出的结果）是执行print(next(g))的结果（–|1|）</p>
<p>4.程序执行print(“*”<em>20)，输出20个</em></p>
<p>5.又开始执行下面的print(next(g)),这个时候和上面那个差不多，不过不同的是，<strong>这个时候是从刚才那个next程序停止的地方开始执行的，也就是要执行res的赋值操作</strong>，这时候要注意，<strong>这个时候赋值操作的右边是没有值的（因为刚才那个是return出去了，并没有给赋值操作的左边传参数），所以这个时候res赋值是None,所以接着下面的输出就是res:None</strong></p>
<p>6.程序会继续在while里执行，又一次碰到yield,这个时候同样return 出4，然后程序停止，print函数输出的4就是这次return出的4.</p>
<p><strong>带yield的函数是一个生成器，而不是一个函数了这个生成器有一个函数就是next函数，</strong>next就相当于“下一步”生成哪个数，这一次的next开始的地方是接着上一次的next停止的地方执行的，所以调用next的时候，生成器并不会从foo函数的开始执行，只是接着上一步停止的地方开始，然后遇到yield后，return出要生成的数，此步就结束。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>():</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        res = <span class="keyword">yield</span> <span class="number">4</span></span><br><span class="line">        print(<span class="string">&quot;res:&quot;</span>,res)</span><br><span class="line">g = foo()</span><br><span class="line">print(<span class="built_in">next</span>(g))</span><br><span class="line">print(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line">print(g.send(<span class="number">7</span>))</span><br><span class="line"></span><br><span class="line"><span class="number">4</span></span><br><span class="line">********************</span><br><span class="line">res: <span class="number">7</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="raise"><a href="#raise" class="headerlink" title="raise"></a>raise</h3><p>raise 关键字用于引发异常。</p>
<p>您可以定义要引发的错误类型以及要向用户打印的文本。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="string">&quot;hello&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">type</span>(x) <span class="keyword">is</span> <span class="built_in">int</span>:</span><br><span class="line">  <span class="keyword">raise</span> TypeError(<span class="string">&quot;Only integers are allowed&quot;</span>)</span><br><span class="line">&gt;&gt;</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">    <span class="keyword">raise</span> TypeError(<span class="string">&quot;Only integers are allowed&quot;</span>)</span><br><span class="line">TypeError: Only integers are allowed</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="https://drinkle.top/2021/06/06/Python-BuiltIn/" data-id="ckpl8jl0v00006gf58eoi3lfm" data-title="Python-BuiltIn" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/BuiltIn/" rel="tag">BuiltIn</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2021/06/13/%E6%88%91%E7%9A%84%E4%B8%96%E7%95%8C%E8%A7%82/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">前一篇</strong>
      <div class="article-nav-title">
        
          我的世界观
        
      </div>
    </a>
  
  
    <a href="/2021/05/23/Framework-Thinking/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">后一篇</strong>
      <div class="article-nav-title">Framework-Thinking</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/BuiltIn/" rel="tag">BuiltIn</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/English-Study/" rel="tag">English Study</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GoodNotes/" rel="tag">GoodNotes</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hexo/" rel="tag">Hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LeeCode/" rel="tag">LeeCode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Postgraduate/" rel="tag">Postgraduate</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/" rel="tag">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/consciousness/" rel="tag">consciousness</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%96%E7%95%8C%E8%A7%82/" rel="tag">世界观</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%96%E7%95%8C%E8%A7%82-%E6%96%B9%E6%B3%95%E8%AE%BA/" rel="tag">世界观 方法论</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AE%9E%E8%B7%B5/" rel="tag">实践</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B7%A6%E7%BF%BC%E5%90%8C%E7%9B%9F%E4%BC%9A/" rel="tag">左翼同盟会</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%96%B0%E9%97%BB%E8%81%94%E6%92%AD/" rel="tag">新闻联播</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%87%B4%E4%BD%A0%E7%9A%84%E4%B8%80%E5%B0%81%E4%BF%A1/" rel="tag">致你的一封信</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/BuiltIn/" style="font-size: 10px;">BuiltIn</a> <a href="/tags/English-Study/" style="font-size: 20px;">English Study</a> <a href="/tags/GoodNotes/" style="font-size: 10px;">GoodNotes</a> <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/LeeCode/" style="font-size: 10px;">LeeCode</a> <a href="/tags/Postgraduate/" style="font-size: 10px;">Postgraduate</a> <a href="/tags/Python/" style="font-size: 15px;">Python</a> <a href="/tags/consciousness/" style="font-size: 10px;">consciousness</a> <a href="/tags/%E4%B8%96%E7%95%8C%E8%A7%82/" style="font-size: 15px;">世界观</a> <a href="/tags/%E4%B8%96%E7%95%8C%E8%A7%82-%E6%96%B9%E6%B3%95%E8%AE%BA/" style="font-size: 10px;">世界观 方法论</a> <a href="/tags/%E5%AE%9E%E8%B7%B5/" style="font-size: 10px;">实践</a> <a href="/tags/%E5%B7%A6%E7%BF%BC%E5%90%8C%E7%9B%9F%E4%BC%9A/" style="font-size: 10px;">左翼同盟会</a> <a href="/tags/%E6%96%B0%E9%97%BB%E8%81%94%E6%92%AD/" style="font-size: 10px;">新闻联播</a> <a href="/tags/%E8%87%B4%E4%BD%A0%E7%9A%84%E4%B8%80%E5%B0%81%E4%BF%A1/" style="font-size: 10px;">致你的一封信</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">六月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">五月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">四月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">三月 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/06/14/Postgraduate/">Postgraduate</a>
          </li>
        
          <li>
            <a href="/2021/06/13/LeeCode/">LeeCode</a>
          </li>
        
          <li>
            <a href="/2021/06/13/%E6%89%B9%E8%AF%84%E4%B8%8E%E8%87%AA%E6%88%91%E6%89%B9%E8%AF%84/">批评与自我批评</a>
          </li>
        
          <li>
            <a href="/2021/06/13/%E6%88%91%E7%9A%84%E4%B8%96%E7%95%8C%E8%A7%82/">我的世界观</a>
          </li>
        
          <li>
            <a href="/2021/06/06/Python-BuiltIn/">Python-BuiltIn</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 Drink<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>