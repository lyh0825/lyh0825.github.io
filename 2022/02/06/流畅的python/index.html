<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>流畅的python | Drink`s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="Part0.BulitIn小知识format   数字 格式 输出 描述    3.1415926 {:.2f} 3.14 保留小数点后两位   3.1415926 {:+.2f} +3.14 带符号保留小数点后两位   -1 {:+.2f} -1.00 带符号保留小数点后两位   2.71828 {:.0f} 3 不带小数   5 {:0&gt;2d} 05 数字补零 (填充左边, 宽度为2)">
<meta property="og:type" content="article">
<meta property="og:title" content="流畅的python">
<meta property="og:url" content="https://drinkle.top/2022/02/06/%E6%B5%81%E7%95%85%E7%9A%84python/index.html">
<meta property="og:site_name" content="Drink&#96;s Blog">
<meta property="og:description" content="Part0.BulitIn小知识format   数字 格式 输出 描述    3.1415926 {:.2f} 3.14 保留小数点后两位   3.1415926 {:+.2f} +3.14 带符号保留小数点后两位   -1 {:+.2f} -1.00 带符号保留小数点后两位   2.71828 {:.0f} 3 不带小数   5 {:0&gt;2d} 05 数字补零 (填充左边, 宽度为2)">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/add_mul_operator.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/memoryview">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/20220303231533.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/fluent_python_dict_set">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/dict01.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/dict02">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/dict03.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/dict04">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/338FE41118E025DEC0F08E62E79242FB.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/04AFD0F1F67F70C8B753E15D433EBB86.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/9074D4974B2971BC1FA4BFBE2710A364.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/6D3B0816875580AF04759FD9538975E0.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/56D97AD7F6AB7ADC76CFDFC71D3CF306.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/20220312164711.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/20220313165653.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/20220313200437.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/496D8BAFE68A48610FC47DBC7BB2A83F.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/20220320144303.png">
<meta property="article:published_time" content="2022-02-06T10:02:01.000Z">
<meta property="article:modified_time" content="2022-03-25T15:26:12.797Z">
<meta property="article:author" content="Drink">
<meta property="article:tag" content="Python">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/add_mul_operator.png">
  
    <link rel="alternate" href="/atom.xml" title="Drink`s Blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Drink`s Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://drinkle.top"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-流畅的python" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/02/06/%E6%B5%81%E7%95%85%E7%9A%84python/" class="article-date">
  <time class="dt-published" datetime="2022-02-06T10:02:01.000Z" itemprop="datePublished">2022-02-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      流畅的python
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Part0-BulitIn"><a href="#Part0-BulitIn" class="headerlink" title="Part0.BulitIn"></a>Part0.BulitIn</h1><h2 id="小知识"><a href="#小知识" class="headerlink" title="小知识"></a>小知识</h2><h3 id="format"><a href="#format" class="headerlink" title="format"></a>format</h3><table>
<thead>
<tr>
<th align="left">数字</th>
<th align="left">格式</th>
<th align="center">输出</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">3.1415926</td>
<td align="left">{:.2f}</td>
<td align="center">3.14</td>
<td align="left">保留小数点后两位</td>
</tr>
<tr>
<td align="left">3.1415926</td>
<td align="left">{:+.2f}</td>
<td align="center">+3.14</td>
<td align="left">带符号保留小数点后两位</td>
</tr>
<tr>
<td align="left">-1</td>
<td align="left">{:+.2f}</td>
<td align="center">-1.00</td>
<td align="left">带符号保留小数点后两位</td>
</tr>
<tr>
<td align="left">2.71828</td>
<td align="left">{:.0f}</td>
<td align="center">3</td>
<td align="left">不带小数</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">{:0&gt;2d}</td>
<td align="center">05</td>
<td align="left">数字补零 (填充左边, 宽度为2)</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">{:x&lt;4d}</td>
<td align="center">5xxx</td>
<td align="left">数字补x (填充右边, 宽度为4)</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left">{:x&lt;4d}</td>
<td align="center">10xx</td>
<td align="left">数字补x (填充右边, 宽度为4)</td>
</tr>
<tr>
<td align="left">1000000</td>
<td align="left">{:,}</td>
<td align="center">1,000,000</td>
<td align="left">以逗号分隔的数字格式</td>
</tr>
<tr>
<td align="left">0.25</td>
<td align="left">{:.2%}</td>
<td align="center">25.00%</td>
<td align="left">百分比格式</td>
</tr>
<tr>
<td align="left">1000000000</td>
<td align="left">{:.2e}</td>
<td align="center">1.00e+09</td>
<td align="left">指数记法</td>
</tr>
<tr>
<td align="left">13</td>
<td align="left">{:&gt;10d}</td>
<td align="center">13</td>
<td align="left">右对齐 (默认, 宽度为10)</td>
</tr>
<tr>
<td align="left">13</td>
<td align="left">{:&lt;10d}</td>
<td align="center">13</td>
<td align="left">左对齐 (宽度为10)</td>
</tr>
<tr>
<td align="left">13</td>
<td align="left">{:^10d}</td>
<td align="center">13</td>
<td align="left">中间对齐 (宽度为10)</td>
</tr>
<tr>
<td align="left">11</td>
<td align="left"><code>&#39;&#123;:b&#125;&#39;.format(11) &#39;&#123;:d&#125;&#39;.format(11) &#39;&#123;:o&#125;&#39;.format(11) &#39;&#123;:x&#125;&#39;.format(11) &#39;&#123;:#x&#125;&#39;.format(11) &#39;&#123;:#X&#125;&#39;.format(11)</code></td>
<td align="center"><code>1011 11 13 b 0xb 0XB</code></td>
<td align="left">进制</td>
</tr>
</tbody></table>
<p><strong>^</strong>, <strong>&lt;**, **&gt;</strong> 分别是居中、左对齐、右对齐，后面带宽度， <strong>:</strong> <strong>号后面带填充的字符</strong>，**只能是一个字符[即只能填充一次]**，不指定则默认是用空格填充。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 即长度为多少</span></span><br><span class="line"><span class="built_in">str</span> = <span class="string">&quot;1&#123;:15&#125;&quot;</span>.<span class="built_in">format</span>(<span class="string">&quot;&amp;&quot;</span>)</span><br><span class="line">print(string_1, <span class="built_in">len</span>(<span class="built_in">str</span>))</span><br><span class="line">|<span class="number">1</span>&amp;               |</span><br><span class="line"><span class="number">16</span></span><br></pre></td></tr></table></figure>

<p><strong>+</strong> 表示在正数前显示 **+**，负数前显示 **-**； （空格）表示在正数前加空格</p>
<p>b、d、o、x 分别是二进制、十进制、八进制、十六进制。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># &#123;&#125; format</span></span><br><span class="line"><span class="comment"># &#123;0&#125; format the index</span></span><br><span class="line"><span class="comment"># &#123;0:2d&#125; format the type --&gt; d int 2d: remain two int</span></span><br><span class="line"><span class="comment"># &#123;&lt;2d&#125; 左对齐，宽度为2d，不足补空格</span></span><br><span class="line">ROW_FMT = <span class="string">&quot;&#123;0:2d&#125;  @ &#123;1:2d&#125;   &#123;2&#125; &#123;0:&lt;2d&#125;&quot;</span></span><br><span class="line">print(ROW_FMT.<span class="built_in">format</span>(needle, posotion, offset))</span><br></pre></td></tr></table></figure>

<h2 id="Attention"><a href="#Attention" class="headerlink" title="Attention"></a>Attention</h2><h3 id="函数-方法返回"><a href="#函数-方法返回" class="headerlink" title="函数|方法返回"></a>函数|方法返回</h3><p>python 会对operation返回return None来表示对对象的就地更改, 即不会id(obj)不会变</p>
<ul>
<li>用返回None来表示就地改动有一个弊端, 即调用者无法将其串联起来; 而返回一个新对象的方法(比如说str里的所有方法)则正好相反, 他们可以串联起来调用</li>
</ul>
<h3 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h3><p>sort分为两种， 一种是value sort即根据值进行排序， 另一种是time sort即就算两个元素比不出大小， 但在每次排序的结果里他们的相对位置是固定的</p>
<h3 id="推导式"><a href="#推导式" class="headerlink" title="推导式"></a>推导式</h3><ul>
<li>一般推导式的作用 <code>[]</code> <code>&#123;&#125;</code><ul>
<li>创建新的数据对象</li>
<li>过滤作用</li>
</ul>
</li>
</ul>
<h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><h3 id="1-python中list和array的区别"><a href="#1-python中list和array的区别" class="headerlink" title="1.python中list和array的区别"></a>1.python中list和array的区别</h3><ul>
<li>list是python的内置数据类型</li>
<li>list中的数据类不必相同的</li>
<li>array的中的类型必须全部相同</li>
<li>在list中的数据类型保存的是数据存放的地址，简单的说就是指针，并非数据</li>
<li>这种保存方式增加了存储和CPU的消耗例如list1=[1,2,3,’a’]需要4个指针和四个数据</li>
<li>数组在背后存的并不是float对象，而是数字的机器翻译，也就是字节表述。这一点和c语言中的数组一样</li>
<li>array创建的数组不适用于数字操作（比如矩阵和矢量运算）。另外+=和*=运算符可以用于array的添加。</li>
<li>从python3.4开始，数组（array）类型不再支持诸如list.sort()这种就地排序方法。要给数组排序的话，得用sorted函数新建一个数组：</li>
</ul>
<h2 id="Magic-Method"><a href="#Magic-Method" class="headerlink" title="Magic Method"></a>Magic Method</h2><p><strong>表1:跟运算符无关的 magic method</strong></p>
<table>
<thead>
<tr>
<th align="center">类别</th>
<th align="center">方法名</th>
</tr>
</thead>
<tbody><tr>
<td align="center">字符串/字节序列表示形式</td>
<td align="center">repr str format bytes</td>
</tr>
<tr>
<td align="center">数值转换</td>
<td align="center">abs bool complex int float hash index</td>
</tr>
<tr>
<td align="center">集合模拟</td>
<td align="center">len getitem setitem delitem contains</td>
</tr>
<tr>
<td align="center">迭代枚举</td>
<td align="center">iter reversed next</td>
</tr>
<tr>
<td align="center">可调用模拟</td>
<td align="center">call</td>
</tr>
<tr>
<td align="center">上下文管理</td>
<td align="center">enter exit</td>
</tr>
<tr>
<td align="center">实例创建/销毁</td>
<td align="center">new init del</td>
</tr>
<tr>
<td align="center">属性管理</td>
<td align="center">getattr getattribute setattr delattr dir</td>
</tr>
<tr>
<td align="center">属性描述符</td>
<td align="center">get set delete</td>
</tr>
<tr>
<td align="center">跟类有关的服务</td>
<td align="center">prepare instancecheck subclasscheck</td>
</tr>
</tbody></table>
<p><strong>表2:跟运算符相关的 magic method</strong></p>
<table>
<thead>
<tr>
<th align="center">类别</th>
<th align="center">方法名和对应的运算符</th>
</tr>
</thead>
<tbody><tr>
<td align="center">一元运算符</td>
<td align="center">neg - pos + abs abs()</td>
</tr>
<tr>
<td align="center">众多比较运算符</td>
<td align="center">lt &lt; le &lt;= eq == ne != gt &gt; ge &gt;=</td>
</tr>
<tr>
<td align="center">算术运算符</td>
<td align="center">add + sub - mul * truediv / floordiv // mod % divmod divmod() pow **|pow() round round()</td>
</tr>
<tr>
<td align="center">反向算术运算符</td>
<td align="center">radd rsub rmul rturediv rfloordiv rmod rdivmod  rpow</td>
</tr>
<tr>
<td align="center">增量赋值算术运算符</td>
<td align="center">iadd isub imul itruediv ifloordic imod ipow</td>
</tr>
<tr>
<td align="center">位运算符</td>
<td align="center">invert ~ lshift &lt;&lt; rshift &gt;&gt; and &amp; or | xor ^</td>
</tr>
<tr>
<td align="center">反向位运算符</td>
<td align="center">rlshift rrshift rand rxor ror</td>
</tr>
<tr>
<td align="center">增量赋值位运算符</td>
<td align="center">ilshift irshift iand ixor ior</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注: 以下所有的keyword默认为 self.__xx__():</span><br></pre></td></tr></table></figure>

<h3 id="bool-len"><a href="#bool-len" class="headerlink" title="bool|len"></a>bool|len</h3><p>默认情况下我们定义的类的实例总是被认为<code>True</code>,除非在<code>define class</code>中有实现<code>bool或者len</code></p>
<p><code>bool()</code>的背后其实是调用<code>x.__bool__()</code>的结果;如果<code>x.__bool__()</code>不存在, 则调用<code>len()</code>即<code>x.__len__()</code>,如果为<code>0-False other-True</code></p>
<p>调用优先级为<code>bool &gt; len</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># define a class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">temp</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.value = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    !<span class="function"><span class="keyword">def</span> <span class="title">__bool__</span>(<span class="params">self</span>):</span></span><br><span class="line">    !   <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">&gt;</span><br><span class="line"><span class="built_in">bool</span>(temp) <span class="literal">False</span></span><br><span class="line">? bool(temp) True</span><br></pre></td></tr></table></figure>



<h3 id="and-mul"><a href="#and-mul" class="headerlink" title="and|mul"></a>and|mul</h3><p><code>and --&gt; +  add</code></p>
<p><code>mul --&gt; *  multiple</code></p>
<h3 id="str-repr"><a href="#str-repr" class="headerlink" title="str|repr"></a>str|repr</h3><p>两者的却别在于<code>str will called by str() and print(), repr can only called by print()</code></p>
<p>如果两者特殊方法保留一个<code>repr</code>会是更好的选择, 因为在没有<code>str</code>时, 解释器会调用<code>repr</code></p>
<p>优先级<code>str &gt; repr </code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># define a class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">temp</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.value = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;repr value is <span class="subst">&#123;self.value&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;str value is <span class="subst">&#123;self.value&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">test = temp()</span><br><span class="line">print(test)</span><br><span class="line"></span><br><span class="line">H:\Python\python.exe H:/MY_TXM/test.py</span><br><span class="line"><span class="built_in">str</span> value <span class="keyword">is</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="Moudle"><a href="#Moudle" class="headerlink" title="Moudle"></a>Moudle</h2><h3 id="OS"><a href="#OS" class="headerlink" title="OS"></a>OS</h3><h4 id="listdir"><a href="#listdir" class="headerlink" title="listdir"></a>listdir</h4><blockquote>
<p>列出目录下的所有文件和文件夹不包括<code>.</code> <code>..</code>隐藏目录</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">print(os.listdir(<span class="string">&quot;H:\MY_TXM&quot;</span>))</span><br><span class="line">&gt;&gt;</span><br><span class="line">[<span class="string">&#x27;.git&#x27;</span>, <span class="string">&#x27;.gitignore&#x27;</span>, <span class="string">&#x27;.idea&#x27;</span>, <span class="string">&#x27;static&#x27;</span>, <span class="string">&#x27;venv&#x27;</span>]</span><br></pre></td></tr></table></figure>

<h3 id="locale"><a href="#locale" class="headerlink" title="locale"></a>locale</h3><blockquote>
<p>locale 是根据计算机用户所使用的语言，所在国家或者地区，以及当地的文化传统所定义的一个软件运行时的语言环境。通常情况下它可以按照涉及使用习惯分为12大类:</p>
</blockquote>
<ul>
<li>语言符号及其分类（LC_CTYPE)</li>
<li>数字（LC_NUMBERIC）</li>
<li>比较习惯（LC_COLLATE)</li>
<li>时间显示格式（LC_TIME）</li>
<li>货币单位（LC_MONETARY)</li>
<li>信息主要是提示信息，错误信息，状态信息，标题，标签，按钮和菜单等（LC_MESSAGES）</li>
<li>行么书写方式（LC_NAME）</li>
<li>地址书写方式（LC_ADDRESS）</li>
<li>电话号码书写方式（LC_TELEPHONE）<br>-度量衡表达方式（LC_MEASUREMENT）</li>
<li>默认纸张尺寸大小（LC_PAPER）</li>
<li>对locale 自身包含信息的概述（LC_IDENTIFICATION）</li>
<li>除此之外还有一个LANGUAGE参数，它与LC_MESSAGES相似</li>
</ul>
<h3 id="time"><a href="#time" class="headerlink" title="time"></a>time</h3><h4 id="time-1"><a href="#time-1" class="headerlink" title="time"></a>time</h4><h4 id="process-time"><a href="#process-time" class="headerlink" title="process_time"></a>process_time</h4><h4 id="process-time-ns"><a href="#process-time-ns" class="headerlink" title="process_time_ns"></a>process_time_ns</h4><h4 id="perf-counter"><a href="#perf-counter" class="headerlink" title="perf_counter"></a>perf_counter</h4><h4 id="perf-counter-ns"><a href="#perf-counter-ns" class="headerlink" title="perf_counter_ns"></a>perf_counter_ns</h4><p><code>time()</code>精度上相对没有那么高，而且受系统的影响，适合表示日期时间或者大程序程序的计时。</p>
<p><code>perf_counter()</code>适合小一点的程序测试，会计算<code>sleep()</code>时间。</p>
<p><code>process_counter()</code>适合小一点的程序测试，不会计算<code>sleep()</code>时间。</p>
<p>此外<code>Python3.7</code>开始还提供了以上三个方法精确到<code>纳秒</code>的计时。分别是：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">time.perf_counter_ns()</span><br><span class="line">time.process_time_ns()</span><br><span class="line">time.time_ns()</span><br></pre></td></tr></table></figure>

<h3 id="arrary"><a href="#arrary" class="headerlink" title="arrary"></a>arrary</h3><p>数组所接受的typecode以及其对应的存储数据类型</p>
<table>
<thead>
<tr>
<th align="left">Type code</th>
<th align="left">C Type</th>
<th align="left">Python Type</th>
<th align="left">Minimum size in bytes</th>
<th align="left">Notes</th>
</tr>
</thead>
<tbody><tr>
<td align="left">‘b’</td>
<td align="left">signed char</td>
<td align="left">int</td>
<td align="left">1</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">‘B’</td>
<td align="left">unsigned char</td>
<td align="left">int</td>
<td align="left">1</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">‘u’</td>
<td align="left">Py_UNICODE</td>
<td align="left">Unicode character</td>
<td align="left">2</td>
<td align="left">(1)</td>
</tr>
<tr>
<td align="left">‘h’</td>
<td align="left">signed short</td>
<td align="left">int</td>
<td align="left">2</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">‘H’</td>
<td align="left">unsigned short</td>
<td align="left">int</td>
<td align="left">2</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">‘i’</td>
<td align="left">signed int    int</td>
<td align="left">2</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">‘I’</td>
<td align="left">unsigned int</td>
<td align="left">int</td>
<td align="left">2</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">‘l’</td>
<td align="left">signed long</td>
<td align="left">int</td>
<td align="left">4</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">‘L’</td>
<td align="left">unsigned long</td>
<td align="left">int</td>
<td align="left">4</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">‘q’</td>
<td align="left">signed long long    int</td>
<td align="left">8</td>
<td align="left">(2)</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">‘Q’</td>
<td align="left">unsigned long long</td>
<td align="left">int</td>
<td align="left">8</td>
<td align="left">(2)</td>
</tr>
<tr>
<td align="left">‘f’</td>
<td align="left">float</td>
<td align="left">float</td>
<td align="left">4</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">‘d’</td>
<td align="left">double</td>
<td align="left">float</td>
<td align="left">8</td>
<td align="left"></td>
</tr>
</tbody></table>
<h3 id="bisect"><a href="#bisect" class="headerlink" title="bisect"></a>bisect</h3><p>bisect是一个根据二分算法写的库，其中主要的俩个方法是bisect和insert，根本上根据二分算法算出有序序列的索引，可以当做快速定位index使用</p>
<h4 id="bisect-bisect-left"><a href="#bisect-bisect-left" class="headerlink" title="bisect|bisect_left"></a>bisect|bisect_left</h4><p>接受一个有序序列，一个元素，返回该元素在有序序列的索引，索引以前全≤该元素，<code>bisect(bisect_right)|bisect_left</code>主要区别是如果俩对比元素相等，前者返回index是从右边插入，后者左边</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> bisect</span><br><span class="line">temp_sequence = [<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">index = bisect.bisect(temp_sequence, <span class="number">2</span>)</span><br><span class="line">_index = bisect.bisect_left(temp_sequence, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">print(index)</span><br><span class="line">print(_index)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<h4 id="insort"><a href="#insort" class="headerlink" title="insort"></a>insort</h4><p>根据bisect或者bisect_left返回的index进行插入，接受有序序列，返回有序序列</p>
<h3 id="itertools"><a href="#itertools" class="headerlink" title="itertools"></a>itertools</h3><h4 id="groupby"><a href="#groupby" class="headerlink" title="groupby"></a>groupby</h4><p>和<code>nlargest() nsmallest()</code>一样支持<code>key=</code></p>
<p>【聚合】</p>
<p>有时候我们需要给一个<code>sequence</code>按照某个属性分组，可以借助groupby来实现,groupby常常和<code>lambda map operator.itemgetter</code>一起使用，因为在分组前，大多希望相关的数据聚集在一起， 这样对于groupby来说分组才有意义</p>
<p>语法：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">groupby(seqence, key)</span><br><span class="line">args:</span><br><span class="line">    sequence must iterable</span><br><span class="line">    key sort the sequence 聚合</span><br><span class="line">return iterator contains key, data --&gt; type tuple</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ol>
<li>如果groupby中的key=None，那么group后的key是被group中的element， 如果key=fun那么group后的key是fun(element)</li>
<li>返回的数据<ul>
<li>type(key) type(element) </li>
<li>type(data) iterator</li>
</ul>
</li>
</ol>
<p>实列：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">a = [&#123;<span class="string">&#x27;severity&#x27;</span>: <span class="string">&#x27;严重&#x27;</span>&#125;, &#123;<span class="string">&#x27;severity&#x27;</span>: <span class="string">&#x27;严重&#x27;</span>&#125;, &#123;<span class="string">&#x27;severity&#x27;</span>: <span class="string">&#x27;不严重&#x27;</span>&#125;, &#123;<span class="string">&#x27;severity&#x27;</span>: <span class="string">&#x27;严重&#x27;</span>&#125;]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果不将数据进行排序直接group</span></span><br><span class="line"><span class="keyword">for</span> key, data <span class="keyword">in</span> groupby(a):</span><br><span class="line">    print(key, <span class="built_in">list</span>(data))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将会输出三组key</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&#123;&#x27;severity&#x27;: &#x27;严重&#x27;&#125; [&#123;&#x27;severity&#x27;: &#x27;严重&#x27;&#125;, &#123;&#x27;severity&#x27;: &#x27;严重&#x27;&#125;]</span></span><br><span class="line"><span class="string">&#123;&#x27;severity&#x27;: &#x27;不严重&#x27;&#125; [&#123;&#x27;severity&#x27;: &#x27;不严重&#x27;&#125;]</span></span><br><span class="line"><span class="string">&#123;&#x27;severity&#x27;: &#x27;严重&#x27;&#125; [&#123;&#x27;severity&#x27;: &#x27;严重&#x27;&#125;]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对数据进行聚合(排序)但不对group的key进行筛选</span></span><br><span class="line">a.sort(key=itemgetter(<span class="string">&quot;severity&quot;</span>))</span><br><span class="line"><span class="keyword">for</span> key, data <span class="keyword">in</span> groupby(a):</span><br><span class="line">    print(key, <span class="built_in">list</span>(data))</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 此时的key时a中的单个element</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&#123;&#x27;severity&#x27;: &#x27;不严重&#x27;&#125; [&#123;&#x27;severity&#x27;: &#x27;不严重&#x27;&#125;]</span></span><br><span class="line"><span class="string">&#123;&#x27;severity&#x27;: &#x27;严重&#x27;&#125; [&#123;&#x27;severity&#x27;: &#x27;严重&#x27;&#125;, &#123;&#x27;severity&#x27;: &#x27;严重&#x27;&#125;, &#123;&#x27;severity&#x27;: &#x27;严重&#x27;&#125;]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对数据进行聚合(排序)且对group的key进行筛选</span></span><br><span class="line">a.sort(key=itemgetter(<span class="string">&quot;severity&quot;</span>))</span><br><span class="line"><span class="keyword">for</span> key, data <span class="keyword">in</span> groupby(a, key=itemgetter(<span class="string">&quot;severity&quot;</span>)):</span><br><span class="line">    print(key, <span class="built_in">list</span>(data))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时的group返回的key是经过滤后的key</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">不严重 [&#123;&#x27;severity&#x27;: &#x27;不严重&#x27;&#125;]</span></span><br><span class="line"><span class="string">严重 [&#123;&#x27;severity&#x27;: &#x27;严重&#x27;&#125;, &#123;&#x27;severity&#x27;: &#x27;严重&#x27;&#125;, &#123;&#x27;severity&#x27;: &#x27;严重&#x27;&#125;]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="operator"><a href="#operator" class="headerlink" title="operator"></a>operator</h3><h4 id="itemgetter"><a href="#itemgetter" class="headerlink" title="itemgetter"></a>itemgetter</h4><p>operator模块提供的itemgetter函数主要用于获取某一对象 <strong>特定维度的数据，</strong>其中的参数为特定维度的索引</p>
<p>operator.itemgetter函数获取的并不是某一个数值，而是<strong>某一个函数</strong>常常可以使用<code>lambda </code>函数替换</p>
<p>用法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">itemgetter(var)</span><br><span class="line">args:</span><br><span class="line">    var can accept index <span class="keyword">and</span> key</span><br><span class="line"><span class="keyword">return</span> fun()</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import operator</span><br><span class="line"></span><br><span class="line">a = [&#123;&quot;age&quot;: 10, &quot;socre&quot;: 90&#125;, &#123;&quot;age&quot;: 9, &quot;socre&quot;: 98&#125;, &#123;&quot;age&quot;: 0, &quot;socre&quot;: 50&#125;, &#123;&quot;age&quot;: 15, &quot;socre&quot;: 56&#125;]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 定义一个获取维度数据的函数</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取sequence的index=0&amp;1的数据</span></span><br><span class="line">condition = operator.itemgetter(0, 1)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将sequence传入获取函数中</span></span><br><span class="line">res = condition(a)</span><br><span class="line">print(res, type(a))</span><br><span class="line">(&#123;&#x27;age&#x27;: 10, &#x27;socre&#x27;: 90&#125;, &#123;&#x27;age&#x27;: 9, &#x27;socre&#x27;: 98&#125;) &lt;class &#x27;tuple&#x27;&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 对a的age进行排序</span></span><br><span class="line">a.sort(key=itemgetter(&quot;age&quot;))</span><br><span class="line">a.sort(key=lambda x: x[&quot;socre&quot;], reverse=True)</span><br><span class="line">print(a)</span><br><span class="line">[&#123;&#x27;age&#x27;: 0, &#x27;socre&#x27;: 50&#125;, &#123;&#x27;age&#x27;: 9, &#x27;socre&#x27;: 98&#125;, &#123;&#x27;age&#x27;: 10, &#x27;socre&#x27;: 90&#125;, &#123;&#x27;age&#x27;: 15, &#x27;socre&#x27;: 56&#125;]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 先对age排序在对score排序</span></span><br><span class="line">a.sort(key=itemgetter(&quot;age&quot;, &quot;socre&quot;), reverse=True)</span><br></pre></td></tr></table></figure>

<h3 id="headq"><a href="#headq" class="headerlink" title="headq"></a>headq</h3><h4 id="nlargest"><a href="#nlargest" class="headerlink" title="nlargest"></a>nlargest</h4><h4 id="nsmallest"><a href="#nsmallest" class="headerlink" title="nsmallest"></a>nsmallest</h4><p>和<code>groupby()</code>一样支持<code>key=</code></p>
<p> 介绍：</p>
<p>这两个函数可以帮助我们在某个集合中找出最大或最小的N个元素</p>
<p>语法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nlargest</span>(<span class="params">n, iterable, key=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Find the n largest elements in a dataset.</span></span><br><span class="line"><span class="string">    Equivalent to:  sorted(iterable, key=key, reverse=True)[:n]</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="random"><a href="#random" class="headerlink" title="random"></a>random</h3><ul>
<li>注意如果在random.method之前使用了seed，那么random.method每次都将按照一定规则返回相同的数值</li>
</ul>
<h4 id="shuffle"><a href="#shuffle" class="headerlink" title="shuffle"></a>shuffle</h4><p>语法:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">random.shuffle(iterable)</span><br><span class="line">args:</span><br><span class="line">    iterbale a <span class="built_in">list</span> <span class="keyword">or</span> <span class="built_in">tuple</span> (sequence)</span><br><span class="line"><span class="keyword">return</span>:</span><br><span class="line">	the origin sequence but the position of element is random ==&gt; None</span><br></pre></td></tr></table></figure>

<p>实列:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">print(a, <span class="built_in">id</span>(a))</span><br><span class="line"></span><br><span class="line"><span class="comment"># operation in ori return None</span></span><br><span class="line">random.shuffle(a)</span><br><span class="line"></span><br><span class="line">print(a, <span class="built_in">id</span>(a))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>] <span class="number">2200356865544</span></span><br><span class="line"><span class="literal">None</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>] <span class="number">2200356865544</span></span><br></pre></td></tr></table></figure>

<h4 id="seed"><a href="#seed" class="headerlink" title="seed"></a>seed</h4><p>调用 <code>random.random()|shuffle </code>生成随机数时，每一次生成的数都是随机的。<br>但是，当使用<code> random.seed(x)</code> 设定好种子之后，其中的 <code>x </code>可以是任意数字，这个时候，先调用<code>seed</code>的情况下，使用 <code>random() </code>生成的随机数将会是同一个</p>
<h4 id="randrange"><a href="#randrange" class="headerlink" title="randrange"></a>randrange</h4><p>从指定范围内，按指定基数递增的集合中 获取一个随机数。</p>
<p><code>random.randrange([start], stop[, step])</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 结果相当于从[10, 12, 14, 16, … 96, 98]序列中获取一个随机数。</span></span><br><span class="line">random.randrange(<span class="number">10</span>, <span class="number">100</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<h4 id="sample"><a href="#sample" class="headerlink" title="sample"></a>sample</h4><p><code>random.sample</code>的函数原型为：<code>random.sample(sequence, k)</code>从指定序列中随机获取指定长度的片断。sample函数不会修改原有序列。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">temp = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line">print(temp, <span class="built_in">id</span>(temp))</span><br><span class="line">random_choice = random.sample(temp, <span class="number">3</span>)</span><br><span class="line">print(random_choice, <span class="built_in">id</span>(random_choice))</span><br><span class="line">print(<span class="built_in">id</span>(temp))</span><br><span class="line"></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>] <span class="number">2483596469896</span></span><br><span class="line">[<span class="number">7</span>, <span class="number">8</span>, <span class="number">3</span>] <span class="number">2483594327944</span></span><br><span class="line"><span class="number">2483596469896</span></span><br></pre></td></tr></table></figure>

<h3 id="dis"><a href="#dis" class="headerlink" title="dis"></a>dis</h3><h4 id="dis-dis"><a href="#dis-dis" class="headerlink" title="dis.dis"></a>dis.dis</h4><p>Python代码在执行的时候，会被编译为Python字节码，再由Python虚拟机执行Python字节码。有时候就我们执行python文件的时候会生成一个pyc文件，这个pyc文件即用于存储Python字节码指令，而这些字节码是一种类似于汇编指令的中间语言，但是每个字节码对应的不是机器指令，而是一段C代码。</p>
<p>而dis模块，就是用于查看这些字节码的运行轨迹，因此我们可以用dis模块判断两个函数的内存占用谁会更大，谁会更消耗CPU性能，不仅如此，通过指令，我们还可以知道Python中一些内置函数、变量的取值过程、运行逻辑，对于我们代码性能并优化代码很有帮助。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> dis</span><br><span class="line">dis.dis(<span class="string">&quot;ori_tuple[index] += mutable_sequence&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="number">1</span>           <span class="number">0</span> LOAD_NAME                <span class="number">0</span> (ori_tuple)</span><br><span class="line">              <span class="number">2</span> LOAD_NAME                <span class="number">1</span> (index)</span><br><span class="line">              <span class="number">4</span> DUP_TOP_TWO</span><br><span class="line">              <span class="number">6</span>             <span class="comment"># 实现 TOS = TOS1[TOS] </span></span><br><span class="line">              <span class="number">8</span> LOAD_NAME                <span class="number">2</span> (mutable_sequence)</span><br><span class="line">             <span class="number">10</span> INPLACE_ADD</span><br><span class="line">             <span class="number">12</span> ROT_THREE</span><br><span class="line">             <span class="number">14</span> STORE_SUBSCR</span><br><span class="line">             <span class="number">16</span> LOAD_CONST               <span class="number">0</span> (<span class="literal">None</span>)</span><br><span class="line">             <span class="number">18</span> RETURN_VALUE</span><br></pre></td></tr></table></figure>

<p>字节码操作:</p>
<ul>
<li><p>假设</p>
<ul>
<li>ori_tuple = (1, 2,  [10, 20])</li>
<li>index = 2</li>
<li>mutable_sequence = [30, 40]</li>
</ul>
</li>
<li><p>6 BINARY_SUBSCR 将 <code>ori_tuple[index]</code>的值存入<code>TOS</code>(Top Of Stack)</p>
</li>
<li><p>10 INPLACE_ADD 计算<code>ori_tuple[index] += mutable_sequence</code>, 这一步骤可以完成, 是因为<code>TOS</code>指向的是一个可变对象</p>
</li>
<li><p>14 STORE_SUBSCR 赋值, 这一步骤失败, 是因为tuple属于不可变序列(immutable)</p>
</li>
</ul>
<hr>
<p>我们从这个操作中可以得到三个教训:</p>
<ol>
<li>不要把可变对象放在元组中</li>
<li>增量赋值(+=)不是一个原子操作, 在计算完后的赋值阶段如果抛出异常, 计算仍然会完成</li>
</ol>
<p>譬如:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">b = (1, 2, [10, 20])</span><br><span class="line">b += [30, 40]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;input&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">TypeError: can only concatenate tuple (not &quot;list&quot;) to tuple</span><br><span class="line">print(b)</span><br><span class="line">(1, 2, [10, 20])</span><br></pre></td></tr></table></figure>

<p><strong>在上述实列中, 即使在最后的赋值阶段tuple抛出异常, 但是此时tuple的数据依然发生了改变!</strong></p>
<table>
<thead>
<tr>
<th align="center">Python字节码 name(variable)</th>
<th>执行操作</th>
</tr>
</thead>
<tbody><tr>
<td align="center">LOAD_NAME</td>
<td>将与 <code>co_names[namei]</code> 相关联的值推入栈顶。</td>
</tr>
<tr>
<td align="center">DUP_TOP_TWO</td>
<td>复制堆栈顶部的两个引用，使它们保持相同的顺序。</td>
</tr>
<tr>
<td align="center">BINARY_SUBSCR</td>
<td>实现 <code>TOS = TOS1[TOS]</code> 。</td>
</tr>
<tr>
<td align="center">INPLACE_ADD</td>
<td>就地实现 <code>TOS = TOS1 + TOS</code> 。</td>
</tr>
<tr>
<td align="center">ROT_THREE</td>
<td>将第二个和第三个堆栈项向上提升一个位置，顶项移动到位置三。</td>
</tr>
<tr>
<td align="center">STORE_SUBSCR</td>
<td>实现 <code>TOS1[TOS] = TOS2</code> 。</td>
</tr>
<tr>
<td align="center">LOAD_CONST</td>
<td>将 <code>co_consts[consti]</code> 推入栈顶</td>
</tr>
<tr>
<td align="center">RETURN_VALUE</td>
<td>返回 TOS 到函数的调用者。</td>
</tr>
</tbody></table>
<ul>
<li>引用<a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/dis.html">dis — Python 字节码反汇编器 — Python 3.10.2 文档</a></li>
</ul>
<h3 id="sys"><a href="#sys" class="headerlink" title="sys"></a>sys</h3><h4 id="getsizeof"><a href="#getsizeof" class="headerlink" title="getsizeof"></a>getsizeof</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">getsizeof(object, default) -&gt; int</span><br><span class="line">Return the size of <span class="built_in">object</span> <span class="keyword">in</span> <span class="built_in">bytes</span>.</span><br></pre></td></tr></table></figure>

<p>获取对象所消耗的内存大小</p>
<h4 id="argv"><a href="#argv" class="headerlink" title="argv"></a>argv</h4><p>是一个从程序外部获取参数的桥梁，从外部取得的参数可以是多个，所以获得的是一个列表（list)，也就是说sys.argv其实可以看作是一个列表，所以才能用[]提取其中的元素。其第一个元素是程序本身，随后才依次是外部给予的参数。</p>
<h3 id="memoryview"><a href="#memoryview" class="headerlink" title="memoryview"></a>memoryview</h3><p>memoryview**[内存视图]<strong>是一个内置类, 它能让用户在不复制内容的情况下操作同一个数组的不同切片,其实内存试图时泛化和去数学化的</strong>numpy数组**,它允许你在不复制内容的前提下,在数据结构之间共享内存, 其中数据结构可以是任何形式,这个功能在处理大型数据集合的时候十分重要</p>
<p>memoryview 语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">memoryview(obj)</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li>obj – 对象</li>
</ul>
<p>返回元组列表(物理地址)。</p>
<h4 id="cast"><a href="#cast" class="headerlink" title=".cast"></a>.cast</h4><p><strong>memoryview.cast</strong>的概念和数组模型差不多,能用不同的方式读写同一块内存地址,而且内容字节不会随意移动,和C语言中类型转换的概念相似.cast会把同一块内存里的内容打包成一个全新的memoryview对象给你</p>
<h2 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h2><h3 id="eval"><a href="#eval" class="headerlink" title="eval"></a>eval</h3><p><strong>描述</strong></p>
<p>eval() 函数用来执行一个字符串表达式，并返回表达式的值。</p>
<p><strong>语法</strong></p>
<p>以下是 eval() 方法的语法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eval(expression[, globals[, locals]])</span><br></pre></td></tr></table></figure>

<p><strong>参数</strong></p>
<ul>
<li>expression – 表达式。</li>
<li>globals – 变量作用域，全局命名空间，如果被提供，则必须是一个字典对象。</li>
<li>locals – 变量作用域，局部命名空间，如果被提供，可以是任何映射对象。</li>
</ul>
<p><strong>返回值</strong></p>
<p>返回表达式计算结果。</p>
<h3 id="isatty"><a href="#isatty" class="headerlink" title="isatty"></a>isatty</h3><blockquote>
<p><strong>isatty()</strong> 方法检测文件是否连接到一个终端设备，如果是返回 True，否则返回 False。</p>
</blockquote>
<p><strong>语法</strong></p>
<p>isatty() 方法语法如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fileObject.isatty()</span><br></pre></td></tr></table></figure>

<h3 id="assert"><a href="#assert" class="headerlink" title="assert"></a>assert</h3><blockquote>
<p>python断言和try-except用法相反</p>
</blockquote>
<p>断言函数是对表达式布尔值的判断，要求表达式计算值必须为真。可用于自动调试。</p>
<p>如果表达式为假，触发异常；如果表达式为真，不执行任何操作。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span> condition</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> condition:</span><br><span class="line">    <span class="keyword">raise</span> AssertionError()</span><br></pre></td></tr></table></figure>

<h3 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a>reverse</h3><h3 id="reversed"><a href="#reversed" class="headerlink" title="reversed"></a>reversed</h3><ol>
<li><code>s.reverse()</code>就地排序, <code>id(s)</code>不变</li>
<li><code>reversed(s)</code>返回<code>s</code>的<strong>倒序迭代器</strong></li>
</ol>
<h3 id="id"><a href="#id" class="headerlink" title="id"></a>id</h3><p>返回对象的物理存储地址, 一般用作操作符是或否创建了一个新对象, 比较两个对象的物理地址是否相同使用<code>is</code></p>
<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>提供的函数对指定序列做映射。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>(function, iterable, ...)</span><br></pre></td></tr></table></figure>

<h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p><strong>filter()</strong> 函数用于过滤序列，过滤掉不符合条件的元素，返回由符合条件元素组成的新列表。</p>
<p><em>Python2.7 返回列表，Python3.x 返回迭代器对象</em></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">filter</span>(function, iterable)</span><br><span class="line"><span class="comment"># 通常和map函数一起使用</span></span><br></pre></td></tr></table></figure>

<p>Python2.x 中返回的是过滤后的列表, 而 Python3 中返回到是一个 filter 类。</p>
<p>filter 类实现了 <strong>iter</strong> 和 <strong>next</strong> 方法, 可以看成是一个迭代器, 有惰性运算的特性, 相对 Python2.x 提升了性能, 节约内存。</p>
<h3 id="abs-fabs-math"><a href="#abs-fabs-math" class="headerlink" title="abs|fabs[math]"></a>abs|fabs[math]</h3><p><code>Python</code> 中<code> fabs(x)</code> 方法返回 <code>x</code> 的绝对值。虽然类似于 <code>abs()</code> 函数，但是两个函数之间存在以下差异：</p>
<ul>
<li><p><code>abs()</code> 是一个内置函数，而 <code>fabs()</code> 在 <code>math</code> 模块中定义的。</p>
</li>
<li><p><code>fabs()</code> 函数只适用于 <code>float</code> 和 <code>integer</code> 类型，而 <code>abs()</code> 也适用于复数。</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line">a = -<span class="number">1</span></span><br><span class="line">b = -<span class="number">1.3232</span></span><br><span class="line">c = b</span><br><span class="line">d = <span class="number">1</span> + <span class="number">1.0j</span></span><br><span class="line">e = <span class="number">3</span> + <span class="number">4.0j</span></span><br><span class="line">print(<span class="string">&quot;a的绝对值是:&quot;</span>, <span class="built_in">abs</span>(a))</span><br><span class="line">print(<span class="string">&quot;b的绝对值是:&quot;</span>, <span class="built_in">abs</span>(b))</span><br><span class="line">print(<span class="string">&quot;c的绝对值是:&quot;</span>, math.fabs(c))</span><br><span class="line">print(<span class="string">&quot;d的的绝对值是:&quot;</span>, <span class="built_in">abs</span>(d))</span><br><span class="line">print(<span class="string">&quot;e的绝对值是:&quot;</span>, math.fabs(e))</span><br><span class="line"></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;H:/MY_TXM/test.py&quot;</span>, line <span class="number">80</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    print(<span class="string">&quot;e的绝对值是:&quot;</span>,math.fabs(e))</span><br><span class="line">TypeError: can<span class="string">&#x27;t convert complex to float</span></span><br></pre></td></tr></table></figure>

<h3 id="hypot-math"><a href="#hypot-math" class="headerlink" title="hypot[math]"></a>hypot[math]</h3><p><strong>hypot()</strong> 返回欧几里德范数 <code>sqrt(x*x + y*y)</code></p>
<p><code>hypot()</code>是不能直接访问的，需要导入 <code>math</code> 模块，然后通过 <code>math </code>静态对象调用该方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line">a = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入直角三角形的一条直角边长：&quot;</span>))</span><br><span class="line">b = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入直角三角形的另一条直角边长：&quot;</span>))</span><br><span class="line">print(<span class="string">&quot;该直角三角形的斜边长为: &quot;</span>,  <span class="built_in">int</span>(math.hypot(a, b)))</span><br><span class="line">print(<span class="string">&quot;Done&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="bool"><a href="#bool" class="headerlink" title="bool"></a>bool</h3><p><strong>bool()</strong> 函数用于将给定参数转换为布尔类型，如果没有参数，返回 <code>False</code>用于判断真假</p>
<p><code>bool </code>是 <code>int</code> 的子类。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">issubclass</span>(<span class="built_in">bool</span>, <span class="built_in">int</span>)  <span class="comment"># bool 是 int 子类</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h3 id="issubclass"><a href="#issubclass" class="headerlink" title="issubclass"></a>issubclass</h3><p><code>issubclass(class, classinfo) --&gt; return True|False</code></p>
<p><strong>issubclass()</strong> 方法用于判断参数 <code>class </code>是否是类型参数<code>classinfo</code>的子类</p>
<h1 id="Part1-DataModel"><a href="#Part1-DataModel" class="headerlink" title="Part1.DataModel"></a>Part1.DataModel</h1><h2 id="1-具名元组"><a href="#1-具名元组" class="headerlink" title="1.具名元组"></a>1.具名元组</h2><p>Python元组的升级版本 – namedtuple(具名元组)</p>
<p>因为元组的局限性：不能为元组内部的数据进行命名，所以往往我们并不知道一个元组所要表达的意义，所以在这里引入了 collections.namedtuple 这个工厂函数，来构造一个带字段名的元组。具名元组的实例和普通元组消耗的内存一样多，因为字段名都被存在对应的类里面。这个类跟普通的对象实例比起来也要小一些，因为 Python 不会用 <strong>dict</strong> 来存放这些实例的属性。</p>
<p>namedtuple 对象的定义如以下格式：</p>
<p><code>collections.namedtuple(typename, field_names, verbose=False, rename=False)</code><br>返回一个具名元组子类 typename，其中参数的意义如下：</p>
<ul>
<li>typename：元组名称</li>
<li>field_names: 元组中元素的名称</li>
<li>rename: 如果元素名称中含有 python 的关键字，则必须设置为 rename=True</li>
<li>verbose: 默认就好</li>
</ul>
<p>下面来看看声明一个具名元组及其实例化的方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line">两种方法来给 namedtuple 定义方法名</span><br><span class="line">User = collections.namedtuple(<span class="string">&#x27;User&#x27;</span>, [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;id&#x27;</span>])</span><br><span class="line">User = collections.namedtuple(<span class="string">&#x27;User&#x27;</span>, <span class="string">&#x27;name age id&#x27;</span>)</span><br><span class="line">user = User(<span class="string">&#x27;tester&#x27;</span>, <span class="string">&#x27;22&#x27;</span>, <span class="string">&#x27;464643123&#x27;</span>)</span><br><span class="line"></span><br><span class="line">print(user)</span><br><span class="line">collections.namedtuple(<span class="string">&#x27;User&#x27;</span>, <span class="string">&#x27;name age id&#x27;</span>) 创建一个具名元组，需要两个参数，一个是类名，另一个是类的各个字段名。后者可以是有多个字符串组成的可迭代对象，或者是有空格分隔开的字段名组成的字符串（比如本示例）。具名元组可以通过字段名或者位置来获取一个字段的信息。</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line"></span><br><span class="line">User(name=<span class="string">&#x27;tester&#x27;</span>, age=<span class="string">&#x27;22&#x27;</span>, <span class="built_in">id</span>=<span class="string">&#x27;464643123&#x27;</span>)</span><br><span class="line">具名元组的特有属性:</span><br><span class="line"></span><br><span class="line">类属性 _fields：包含这个类所有字段名的元组 类方法 _make(iterable)：接受一个可迭代对象来生产这个类的实例 实例方法 _asdict()：把具名元组以 collections.OrdereDict 的形式返回，可以利用它来把元组里的信息友好的展示出来</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个namedtuple类型User，并包含name，sex和age属性。</span></span><br><span class="line">User = namedtuple(<span class="string">&#x27;User&#x27;</span>, [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;sex&#x27;</span>, <span class="string">&#x27;age&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个User对象</span></span><br><span class="line">user = User(name=<span class="string">&#x27;Runoob&#x27;</span>, sex=<span class="string">&#x27;male&#x27;</span>, age=<span class="number">12</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取所有字段名</span></span><br><span class="line">print( user._fields )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以通过一个list来创建一个User对象，这里注意需要使用&quot;_make&quot;方法</span></span><br><span class="line">user = User._make([<span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;male&#x27;</span>, <span class="number">12</span>])</span><br><span class="line"></span><br><span class="line">print( user )</span><br><span class="line"><span class="comment"># User(name=&#x27;user1&#x27;, sex=&#x27;male&#x27;, age=12)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取用户的属性</span></span><br><span class="line">print( user.name )</span><br><span class="line">print( user.sex )</span><br><span class="line">print( user.age )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改对象属性，注意要使用&quot;_replace&quot;方法</span></span><br><span class="line">user = user._replace(age=<span class="number">22</span>)</span><br><span class="line">print( user )</span><br><span class="line"><span class="comment"># User(name=&#x27;user1&#x27;, sex=&#x27;male&#x27;, age=21)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将User对象转换成字典，注意要使用&quot;_asdict&quot;</span></span><br><span class="line">print( user._asdict() )</span><br><span class="line"><span class="comment"># OrderedDict([(&#x27;name&#x27;, &#x27;Runoob&#x27;), (&#x27;sex&#x27;, &#x27;male&#x27;), (&#x27;age&#x27;, 22)])</span></span><br><span class="line">以上实例输出结果为：</span><br><span class="line"></span><br><span class="line">(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;sex&#x27;</span>, <span class="string">&#x27;age&#x27;</span>)</span><br><span class="line">User(name=<span class="string">&#x27;Runoob&#x27;</span>, sex=<span class="string">&#x27;male&#x27;</span>, age=<span class="number">12</span>)</span><br><span class="line">Runoob</span><br><span class="line">male</span><br><span class="line"><span class="number">12</span></span><br><span class="line">User(name=<span class="string">&#x27;Runoob&#x27;</span>, sex=<span class="string">&#x27;male&#x27;</span>, age=<span class="number">22</span>)</span><br><span class="line">OrderedDict([(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;Runoob&#x27;</span>), (<span class="string">&#x27;sex&#x27;</span>, <span class="string">&#x27;male&#x27;</span>), (<span class="string">&#x27;age&#x27;</span>, <span class="number">22</span>)])</span><br></pre></td></tr></table></figure>

<h2 id="2-列表表达式"><a href="#2-列表表达式" class="headerlink" title="2.列表表达式"></a>2.列表表达式</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 两者相等</span></span><br><span class="line">print([(i, j) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>) <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">11</span>, <span class="number">20</span>)])</span><br><span class="line">res = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">11</span>, <span class="number">20</span>):</span><br><span class="line">        res.append((i, j))</span><br><span class="line">print(res)</span><br><span class="line"></span><br><span class="line"><span class="comment"># essential</span></span><br><span class="line">fun() <span class="keyword">for</span>-<span class="keyword">in</span>-loop_1 <span class="keyword">for</span>-<span class="keyword">in</span>-loop_2</span><br><span class="line">&lt;==&gt;</span><br><span class="line"><span class="keyword">for</span>-<span class="keyword">in</span>-loop_1:</span><br><span class="line">    <span class="keyword">for</span>-<span class="keyword">in</span>-loop_2:</span><br><span class="line">        fun()</span><br></pre></td></tr></table></figure>

<h2 id="3-random-choice"><a href="#3-random-choice" class="headerlink" title="3.random choice"></a>3.random choice</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> choice</span><br><span class="line">choice(obj) -&gt; obj: can iterable</span><br><span class="line">==&gt; this module can choice a random element from obj</span><br></pre></td></tr></table></figure>

<h2 id="4-Magic-Method"><a href="#4-Magic-Method" class="headerlink" title="4.Magic Method"></a>4.Magic Method</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">obj[key]</span><br><span class="line">本质上调用的是__getitem__</span><br><span class="line"></span><br><span class="line">magic method 又称为 dunder method 及双下滑线魔法方法</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>-<span class="keyword">in</span>-loop</span><br><span class="line">==&gt; __contains__ 迭代通常是隐式的</span><br><span class="line"></span><br><span class="line">obj[key]   --&gt;  self.__getitem__</span><br><span class="line"></span><br><span class="line">迭代通常是隐式的,如果一个集合类型没有实现slef.__contains__,</span><br><span class="line">那么<span class="keyword">in</span>运算符就会按照顺序做一次迭代搜索</span><br><span class="line"></span><br><span class="line">len(obj)   --&gt;   self.__len__</span><br><span class="line">注意如果obj是python内置的类型比如（<span class="built_in">list</span>、<span class="built_in">str</span>、bytearry）等Cpython会抄个近路，__len__实际上会直接返回PyVarObject的self.ob_size这个属性，而不是执行self.__len__这个方法</span><br><span class="line"></span><br><span class="line">for item in x:   --&gt;  self.__iter__</span><br><span class="line">x 必须是可迭代的</span><br></pre></td></tr></table></figure>

<h2 id="5-迭代器与生成器"><a href="#5-迭代器与生成器" class="headerlink" title="5.迭代器与生成器"></a>5.迭代器与生成器</h2><h3 id="5-1迭代器"><a href="#5-1迭代器" class="headerlink" title="5.1迭代器"></a>5.1迭代器</h3><p>迭代是Python最强大的功能之一，是访问集合元素的一种方式。</p>
<p>迭代器是一个可以记住遍历的位置的对象。</p>
<p>迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。</p>
<p>迭代器有两个基本的方法：<strong>iter()</strong> 和 **next()**。</p>
<p>字符串，列表或元组对象都可用于创建迭代器：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">it = <span class="built_in">iter</span>(<span class="built_in">list</span>)    <span class="comment"># 创建迭代器对象</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">next</span>(it))   <span class="comment"># 输出迭代器的下一个元素</span></span><br><span class="line">&gt;<span class="number">1</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">next</span>(it))</span><br><span class="line">&gt;<span class="number">2</span></span><br></pre></td></tr></table></figure>

<p><strong>迭代器对象可以使用常规for语句进行遍历</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">list</span>=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">it = <span class="built_in">iter</span>(<span class="built_in">list</span>)    <span class="comment"># 创建迭代器对象</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> it:</span><br><span class="line">    <span class="built_in">print</span> (x, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">    </span><br><span class="line">&gt; <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p><strong>也可以使用 next() 函数：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> sys         <span class="comment"># 引入 sys 模块</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">list</span>=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">it = <span class="built_in">iter</span>(<span class="built_in">list</span>)    <span class="comment"># 创建迭代器对象</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">print</span> (<span class="built_in">next</span>(it))</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        sys.exit()</span><br></pre></td></tr></table></figure>

<h3 id="5-2创建一个迭代器"><a href="#5-2创建一个迭代器" class="headerlink" title="5.2创建一个迭代器"></a>5.2创建一个迭代器</h3><p>把一个类作为一个迭代器使用需要在类中实现两个方法 <strong>iter</strong>() 与 <strong>next</strong>() </p>
<p>在定义类的时候都有一个构造函数，Python 的构造函数为 <strong>init</strong>(), 它会在对象初始化的时候执行。</p>
<p><strong>iter</strong>() 方法返回一个特殊的<strong>迭代器对象</strong>， 这个迭代器对象实现了 <strong>next</strong>() 方法并通过 <strong>StopIteration</strong> 异常标识迭代的完成。</p>
<p><strong>next</strong>() 方法（Python 2 里是 next()）会返回下一个迭代器对象。</p>
<p>创建一个返回数字的迭代器，初始值为 1，逐步递增 1：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Numbers</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    抽象一个迭代器对象，初始属性【value=0每次next自增1，并通过【value&gt;20】来rais StopInteration</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.value = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 注意这里返回的不是属性self.value而是self这个抽象对象</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.value &lt;= <span class="number">20</span>:</span><br><span class="line">	        self.value += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 这里我们需要输出值,print进行查看</span></span><br><span class="line">            <span class="keyword">return</span> self.value</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line">            </span><br><span class="line"><span class="comment"># ------</span></span><br><span class="line"></span><br><span class="line">temp = Numbers()</span><br><span class="line">temp_iter = <span class="built_in">iter</span>(temp)  <span class="comment"># 这一步骤可以省略，因为temp在实例化的时候已经是一个迭代器了（contains magic method） iterm | next</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以直接for-in-loop temp</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> temp_iter:</span><br><span class="line">    print(item)</span><br><span class="line">&gt; <span class="number">1</span> <span class="number">2</span> ... <span class="number">21</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将俩者的信息进行打印如下:</span></span><br><span class="line">print(<span class="string">f&quot;the obj is <span class="subst">&#123;temp&#125;</span> , type is <span class="subst">&#123;<span class="built_in">type</span>(temp)&#125;</span>&quot;</span>)</span><br><span class="line">print(<span class="string">f&quot;the iter is <span class="subst">&#123;temp_iter&#125;</span> , type is <span class="subst">&#123;<span class="built_in">type</span>(temp)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">&gt;&gt;</span><br><span class="line">the obj <span class="keyword">is</span> &lt;__main__.Numbers <span class="built_in">object</span> at <span class="number">0x0000016FFBD51088</span>&gt; , <span class="built_in">type</span> <span class="keyword">is</span> &lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">__main__</span>.<span class="title">Numbers</span>&#x27;&gt;</span></span><br><span class="line">the iter is &lt;__main__.Numbers object at 0x0000016FFBD51088&gt; , type is &lt;class &#x27;__main__.Numbers&#x27;&gt;</span><br><span class="line"><span class="comment"># 可以看到两者的物理地址相同，因此iter(OBJ)和OBJ一样都是属于迭代器</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="5-3生成器"><a href="#5-3生成器" class="headerlink" title="5.3生成器"></a>5.3生成器</h3><p>在 Python 中，使用了 yield 的函数被称为生成器（generator）。</p>
<p>跟普通函数不同的是，生成器是一个返回迭代器的函数，只能用于迭代操作，更简单点理解生成器就是一个迭代器。</p>
<p>在调用生成器运行的过程中，每次遇到 yield 时函数会暂停并保存当前所有的运行信息，返回 yield 的值, 并在下一次执行 next() 方法时从当前位置继续运行。</p>
<p>调用一个生成器函数，返回的是一个迭代器对象。</p>
<p>以下实例使用 yield 实现斐波那契数列：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibonacci</span>(<span class="params">n</span>):</span>  <span class="comment"># 生成器函数 - 斐波那契</span></span><br><span class="line">    a, b, counter = <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> (counter &gt; n): </span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">yield</span> a</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        counter += <span class="number">1</span></span><br><span class="line">f = fibonacci(<span class="number">10</span>)  <span class="comment"># f 是一个迭代器，由生成器返回生成</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">print</span> (<span class="built_in">next</span>(f), end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        sys.exit()</span><br><span class="line"><span class="comment">#  每次next（generator）所生成的迭代器对象公用和一个物理地址</span></span><br></pre></td></tr></table></figure>

<h3 id="5-4迭代器和生成器对比"><a href="#5-4迭代器和生成器对比" class="headerlink" title="5.4迭代器和生成器对比"></a>5.4迭代器和生成器对比</h3><ul>
<li><p>迭代器（iterator）是一个特殊的类，其中必有iterm和next方法，本质上是一个类|对象 </p>
<ul>
<li>除了使用class来定义一个迭代器外， 还可以使用iterm(obj)来快速生成一个迭代器对象</li>
<li>可以使用rais StopIteration来抛出exception阻止迭代器进入<strong>死循环</strong></li>
<li>是一个可以记住遍历的位置的对象（本质上含有iterm和next）</li>
</ul>
</li>
<li><p>生成器是一个含有yield的函数（generator），生成器是一个返回迭代器的函数，只能用于迭代操作，其实生成器也可以理解成一种特殊的迭代器</p>
<ul>
<li>生成器是一个返回迭代器的函数</li>
<li>在调用生成器运行的过程中，每次遇到 yield 时函数会暂停并保存当前所有的运行信息，返回 yield 的值, 并在下一次执行 next() 方法时从当前位置继续运行。</li>
<li>调用一个生成器函数，返回的是一个迭代器对象</li>
</ul>
</li>
</ul>
<h2 id="6-len为什么不是普通方法"><a href="#6-len为什么不是普通方法" class="headerlink" title="6.len为什么不是普通方法"></a>6.len为什么不是普通方法</h2><p>如果x是一个python内置类型的实例， 那么len(x)中Cpython会直接调用这个类的属性，解释器将不走<code>__len__()</code>这个方法</p>
<h2 id="杂谈"><a href="#杂谈" class="headerlink" title="杂谈"></a>杂谈</h2><ol>
<li><p>数据模型|对象模型</p>
<ul>
<li>python文档中大多使用数据模型, 而大多数喜欢使用对象模型</li>
<li>对象模型:计算机编程语言中对象的属性&lt;==&gt;数据模型</li>
</ul>
</li>
<li><p>魔法方法</p>
<ul>
<li>python用这个方法来提供更多的元对象协议,目的是让语言的使用者和开发者拥有并使用同样的工具</li>
</ul>
</li>
<li><p>元对象</p>
<p><code>the art of the MetaObject Protocal | AMOP</code></p>
<ul>
<li>元对象协议:那些对构建语言本身来讲很重要的对象, 以此为前提, 协议也可以看成是接口, 即是说, 元对象协议是对象模型(数据模型)的同义词, 他们的本质都是构建核心语言的API</li>
</ul>
</li>
</ol>
<h1 id="Part2-DataStructure"><a href="#Part2-DataStructure" class="headerlink" title="Part2.DataStructure"></a>Part2.DataStructure</h1><h2 id="2-0前言"><a href="#2-0前言" class="headerlink" title="2.0前言"></a>2.0前言</h2><p>在创建<code>poython</code>之前<code>Guido</code>曾为<code>ABC</code>语言贡献过代码, <code>ABC</code>语言是一个致力于为初学者设计变成环境的长达10的研究项目, 其中很多点子在现在看来任然具有python的特性如:</p>
<ol>
<li>序列的泛型操作</li>
<li>内置的元组</li>
<li>映射类型</li>
<li>用缩进来构建源码</li>
<li>无需变量声明的强类型</li>
</ol>
<p>python也从ABC继承了用统一风格处理<code>序列数据</code>这一特点, 无论是中数据结构(string|list|bytes|tuple|array|xml|element|database query)他们都公用一套操作:</p>
<ol>
<li>迭代</li>
<li>切片</li>
<li>排序</li>
<li>拼接</li>
</ol>
<h2 id="2-1内置序列类型"><a href="#2-1内置序列类型" class="headerlink" title="2.1内置序列类型"></a>2.1内置序列类型</h2><p>python使用C实现了两大类序列类型：<strong>容器序列 扁平序列</strong></p>
<blockquote>
<p>两者的却别前者支持存储不同类型的数据; 后者仅支持一种类型的数据</p>
</blockquote>
<p><strong>容器序列</strong>: <code>list tuple collection.deque</code></p>
<ul>
<li>存放的是任意类型的对象的引用</li>
<li>支持存储不同数据类型</li>
<li>非连续内存存储</li>
</ul>
<p><strong>扁平序列</strong>: <code>str bytes bytearray memoryvivew arrary.arrary</code></p>
<ul>
<li>存放的是值而不是引用</li>
<li>只能存储一种数据类型[字符 字节 数值]</li>
<li>连续存储</li>
</ul>
<p>根据是否可以被修改可以分为:<strong>可变序列</strong> <strong>不可变序列</strong></p>
<p>从UML图中可以看出两者之间的部分继承关系，但是<strong>内置的序列</strong>类型不是直接<code>sequence</code>和<code>mutale sequence</code>这两个抽象基类继承来的<code>Abstarct Base Class | ABC</code></p>
<table>
<thead>
<tr>
<th></th>
<th>immutable sequence</th>
<th>mutable sequence</th>
</tr>
</thead>
<tbody><tr>
<td>*getitem</td>
<td>y</td>
<td></td>
</tr>
<tr>
<td>*setitem</td>
<td></td>
<td>y</td>
</tr>
<tr>
<td>*delitem</td>
<td></td>
<td>y</td>
</tr>
<tr>
<td>*contains</td>
<td>y</td>
<td></td>
</tr>
<tr>
<td>*iter</td>
<td>y</td>
<td></td>
</tr>
<tr>
<td>*reversed</td>
<td>y</td>
<td></td>
</tr>
<tr>
<td>*iadd</td>
<td></td>
<td>y</td>
</tr>
<tr>
<td>index</td>
<td>y</td>
<td></td>
</tr>
<tr>
<td>insert</td>
<td></td>
<td>y</td>
</tr>
<tr>
<td>append</td>
<td></td>
<td>y</td>
</tr>
<tr>
<td>reverse</td>
<td></td>
<td>y</td>
</tr>
<tr>
<td>extend</td>
<td></td>
<td>y</td>
</tr>
<tr>
<td>pop</td>
<td></td>
<td>y</td>
</tr>
<tr>
<td>remove</td>
<td></td>
<td>y</td>
</tr>
<tr>
<td>count</td>
<td>y</td>
<td></td>
</tr>
</tbody></table>
<h2 id="2-2-列表推导和生成器表达"><a href="#2-2-列表推导和生成器表达" class="headerlink" title="2.2 列表推导和生成器表达"></a>2.2 列表推导和生成器表达</h2><blockquote>
<p>list comprehension and generator expression</p>
</blockquote>
<p><code>[]: 列表推导式</code></p>
<p><code>(): 生成器表达式</code></p>
<p><strong>列表推导式: 快速构建list</strong></p>
<p>使用原则:</p>
<ol start="0">
<li><p><strong>列表推导式的作用只有一个:生成列表</strong></p>
</li>
<li><p>创建新列表</p>
</li>
<li><p>尽量保持简短</p>
</li>
<li><p>在<code>py3.x</code>中修复了列表推导是中的变量泄露问题(通过局部作用域修复)</p>
</li>
<li><p>使用<code>filter + map</code>也可以达到相同效果</p>
</li>
<li><p>注意: <code>filter</code>返回的是一个迭代器</p>
</li>
<li><p>两者的效率根据不同情况表现不一样</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">temp = <span class="string">&#x27;!@#$%&#x27;</span></span><br><span class="line"></span><br><span class="line">m1 = [<span class="built_in">ord</span>(s) <span class="keyword">for</span> s <span class="keyword">in</span> temp <span class="keyword">if</span> <span class="built_in">ord</span>(s) &gt; <span class="number">35</span>]</span><br><span class="line">print(m1)</span><br><span class="line"></span><br><span class="line">m2 = <span class="built_in">list</span>(<span class="built_in">filter</span>(<span class="keyword">lambda</span> x: x &gt; <span class="number">35</span>, <span class="built_in">map</span>(<span class="built_in">ord</span>, temp)))</span><br><span class="line">print(m2)</span><br></pre></td></tr></table></figure>

<h3 id="2-2-1-笛卡尔积"><a href="#2-2-1-笛卡尔积" class="headerlink" title="2.2.1 笛卡尔积"></a>2.2.1 笛卡尔积</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">col_1 = [<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;c&quot;</span>]</span><br><span class="line">col_2 = [<span class="string">&quot;!&quot;</span>, <span class="string">&quot;@&quot;</span>, <span class="string">&quot;#&quot;</span>]</span><br><span class="line"></span><br><span class="line">col_3 = [(i, j) <span class="keyword">for</span> i <span class="keyword">in</span> col_1 <span class="keyword">for</span> j <span class="keyword">in</span> col_2]</span><br><span class="line">print(col_3)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> col_1:</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> col_2:</span><br><span class="line">        print(i, j)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>列表推导式和双层<code>for</code>循环俩者执行顺序一样</p>
</blockquote>
<h3 id="2-2-2生成器表达式"><a href="#2-2-2生成器表达式" class="headerlink" title="2.2.2生成器表达式"></a>2.2.2生成器表达式</h3><p>使用列表推导也可以初始化元组|数组|其他序列,但是生成器表达式是一个更好的选择, 因为背后支持迭代器协议,可以逐个产出元素而非先建立一个完整的<code>list</code>,可以更好的节省内存</p>
<p>生成器表达式和列表推导式的区别是:</p>
<ul>
<li><code>[]</code> <code>()</code></li>
<li>生成一个完整的<code>list</code>; 迭代器</li>
</ul>
<h2 id="2-3-元组"><a href="#2-3-元组" class="headerlink" title="2.3 元组"></a>2.3 元组</h2><blockquote>
<p>元组: 是一个不可变的list; 记录一定的维度[位置]的数据信息</p>
</blockquote>
<p>元组的拆包</p>
<p>本质上是将元组中的数据提取</p>
<ol start="0">
<li><p>元组的拆包方式在任意可迭代对象中都是通用的</p>
</li>
<li><p><code>for-loop</code></p>
</li>
<li><p><code>*</code></p>
<ul>
<li><code>*</code>拆包返回的是<code>list</code></li>
</ul>
</li>
<li><p>平行赋值</p>
</li>
<li><p><code>a, b = b, a </code>本质上也是拆包</p>
</li>
<li><p>可以使用<code>_</code>占位符来过滤掉不需要的数据</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.for-loop</span></span><br><span class="line">a = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> a:</span><br><span class="line">    print(i)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 2.*</span></span><br><span class="line"><span class="comment"># 提取元素</span></span><br><span class="line">i, *j = a</span><br><span class="line"><span class="comment"># 将可迭代对象拆开作为函数的参数</span></span><br><span class="line">b = (<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="built_in">divmod</span>(*b)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 平行赋值</span></span><br><span class="line">i, j, m = a</span><br></pre></td></tr></table></figure>

<h4 id="2-3-1-具名元组"><a href="#2-3-1-具名元组" class="headerlink" title="2.3.1 具名元组"></a>2.3.1 具名元组</h4><p><code>collections.namedtuple</code>构建的类的实例所消耗的内存和元组一样, 因为字段名都存在了相应的类里</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># namedtuple</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"></span><br><span class="line"><span class="comment"># define a class</span></span><br><span class="line"><span class="comment"># namedtuple(str, iterator)</span></span><br><span class="line"><span class="comment">#   &gt;&gt;&gt; str: the name of class</span></span><br><span class="line"><span class="comment">#   &gt;&gt;&gt; iterator: define the attributes of class</span></span><br><span class="line"><span class="comment">#   &gt;&gt;&gt; iterator(if accept str): &quot;name age score&quot; split whith &#x27; &#x27;</span></span><br><span class="line">student = namedtuple(<span class="string">&#x27;student&#x27;</span>, [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;score&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># create some instances</span></span><br><span class="line">drink = student(<span class="string">&#x27;Drink&#x27;</span>, <span class="string">&#x27;21&#x27;</span>, <span class="string">&#x27;90&#x27;</span>)</span><br><span class="line">starfire = student(<span class="string">&#x27;starfire&#x27;</span>, <span class="string">&#x27;23&#x27;</span>, <span class="string">&#x27;92&#x27;</span>)</span><br><span class="line">spark = student(<span class="string">&#x27;spark&#x27;</span>, <span class="string">&#x27;24&#x27;</span>, <span class="string">&#x27;95&#x27;</span>)</span><br><span class="line"></span><br><span class="line">print(drink)</span><br><span class="line">print(starfire)</span><br><span class="line">print(spark)</span><br><span class="line"></span><br><span class="line">student(name=<span class="string">&#x27;Drink&#x27;</span>, age=<span class="string">&#x27;21&#x27;</span>, score=<span class="string">&#x27;90&#x27;</span>)</span><br><span class="line">student(name=<span class="string">&#x27;starfire&#x27;</span>, age=<span class="string">&#x27;23&#x27;</span>, score=<span class="string">&#x27;92&#x27;</span>)</span><br><span class="line">student(name=<span class="string">&#x27;spark&#x27;</span>, age=<span class="string">&#x27;24&#x27;</span>, score=<span class="string">&#x27;95&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># we can get the specify value by [] or .attr</span></span><br><span class="line">print(drink[<span class="number">0</span>])</span><br><span class="line">print(drink.name)</span><br><span class="line"></span><br><span class="line">Drink</span><br><span class="line">Drink</span><br></pre></td></tr></table></figure>

<p>除了从普通元组继承的属性之外, 具名元组还有独特的属性:<code>_fields类属性|类方法|_make(iterable)和实列方法_asdict() </code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment"># get all attrs of drink</span></span><br><span class="line">print(drink._fields)</span><br><span class="line"></span><br><span class="line">(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;score&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># exchange drink into dict</span></span><br><span class="line">drink_dict = drink._asdict()</span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> drink_dict.items():</span><br><span class="line">    print(key, <span class="string">&quot;:&quot;</span>, value)</span><br><span class="line">    </span><br><span class="line">name : Drink</span><br><span class="line">age : <span class="number">21</span></span><br><span class="line">score : <span class="number">90</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># accept date generate an instance</span></span><br><span class="line">data = (<span class="string">&quot;star&quot;</span>, <span class="string">&quot;20&quot;</span>, <span class="string">&quot;60&quot;</span>)</span><br><span class="line">star = student._make(data)</span><br><span class="line">print(star)</span><br><span class="line"></span><br><span class="line">student(name=<span class="string">&#x27;star&#x27;</span>, age=<span class="string">&#x27;20&#x27;</span>, score=<span class="string">&#x27;60&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="2-3-2-不可变列表-元组"><a href="#2-3-2-不可变列表-元组" class="headerlink" title="2.3.2 不可变列表[元组]"></a>2.3.2 不可变列表[元组]</h4><blockquote>
<p>元组支持列表的大多数操作除了增删改元素之外</p>
</blockquote>
<h2 id="2-4切片"><a href="#2-4切片" class="headerlink" title="2.4切片"></a>2.4切片</h2><ol>
<li>切片支持大多数<code>可变序列</code></li>
<li>切片的数学表达式为<code>[&lt;= &lt;)</code></li>
<li>区间运算<code>start default=0</code></li>
<li><code>s[a:b:c] start end step</code>其中<code>step</code>可以为负即反向取值</li>
</ol>
<p>本质上在使用slice取值时, python会调用<code>seq.__getitem__(slice(start, end, step))</code></p>
<p>或者说<code>slice()</code>是一个切片对象, 可以改切片命名就像<code>excel--sheet</code>一样</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">name_slice = <span class="built_in">slice</span>(<span class="number">0</span>, <span class="number">5</span>)</span><br><span class="line">a = <span class="string">&quot;drink 21 98&quot;</span></span><br><span class="line">print(a[name_slice])</span><br><span class="line"></span><br><span class="line">drink</span><br></pre></td></tr></table></figure>

<h3 id="2-4-1-多维切片-省略"><a href="#2-4-1-多维切片-省略" class="headerlink" title="2.4.1 多维切片|省略"></a>2.4.1 多维切片|省略</h3><blockquote>
<p>多维切片所支持的数据序列也是多维度,而python内置的数据序列都是一维的</p>
</blockquote>
<p>本质上多维切片<code>seq[i, j]| seq[m:n, i:j]</code>调用的是<code>seq.__getitem__((i, j))</code>或者<code>seq.__setitem((i, j))</code></p>
<p>省略<code>...</code>在python解释器中是一个符号,其实本质上<code>Ellipsis</code>对象的别称</p>
<p>如果<code>x</code>是四维数组,那么<code>x[i:...]</code>就是<code>x[i:::]</code>的缩写</p>
<h3 id="2-4-2-切片赋值"><a href="#2-4-2-切片赋值" class="headerlink" title="2.4.2 切片赋值"></a>2.4.2 切片赋值</h3><ul>
<li>通过切片赋值右边必须是<strong>可迭代对象</strong></li>
</ul>
<h2 id="2-5-对序列使用-和"><a href="#2-5-对序列使用-和" class="headerlink" title="2.5 对序列使用+和*"></a>2.5 对序列使用+和*</h2><ul>
<li><p><code>+</code>和<code>*</code>都遵守一条规律即<strong>不修改原有的操作对象</strong>而是创建一个全新的序列</p>
</li>
<li><p><code>+</code>通常是相同类型的数据</p>
</li>
<li><p>在操作中python会创建一个包含相同类型数据的序列作为拼接的结果</p>
</li>
<li><p>注意在使用<code>seq * n</code>操作时, 如果<code>seq</code>里的元素是对其他可变对象的引用的话, 虽然<code>* n</code>拼接了, 但本质上还是对<code>seq</code>的引用, 对其进行操作时很可能会出现”多重操作”</p>
</li>
</ul>
<p>示例:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">a = [[<span class="string">&quot;_&quot;</span>] * <span class="number">3</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)]</span><br><span class="line"></span><br><span class="line">b = [[<span class="string">&quot;_&quot;</span>] * <span class="number">3</span>] * <span class="number">3</span></span><br><span class="line"></span><br><span class="line">a[<span class="number">1</span>][<span class="number">2</span>] = <span class="string">&quot;X&quot;</span></span><br><span class="line">b[<span class="number">1</span>][<span class="number">2</span>] = <span class="string">&quot;O&quot;</span></span><br><span class="line"></span><br><span class="line">print(a)</span><br><span class="line">print(b)</span><br><span class="line"></span><br><span class="line">[[<span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>],</span><br><span class="line"> [<span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;X&#x27;</span>],</span><br><span class="line"> [<span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>]]</span><br><span class="line"></span><br><span class="line">[[<span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;O&#x27;</span>],</span><br><span class="line"> [<span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;O&#x27;</span>], </span><br><span class="line"> [<span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;O&#x27;</span>]]</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/add_mul_operator.png"></p>
<p>其中<code>b</code>时三个指向同一对象的引用</p>
<p><code>b</code>所犯的错误和下面的错误一样</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># list中追加的是对同一对象的三次引用</span></span><br><span class="line">row = [<span class="string">&quot;_&quot;</span>] * <span class="number">3</span></span><br><span class="line">board = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    board.append(row)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># should optimize to this </span></span><br><span class="line">board = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    row = [<span class="string">&quot;_&quot;</span>] * <span class="number">3</span></span><br><span class="line">    board.append(row)</span><br></pre></td></tr></table></figure>

<h2 id="2-6-序列的增量赋值"><a href="#2-6-序列的增量赋值" class="headerlink" title="2.6 序列的增量赋值"></a>2.6 序列的增量赋值</h2><blockquote>
<p>即就地增量 += *= (仅针对可变序列), 不可变序列增量拼接的话实现的是 + * 每次都会创建一个新对象,效率会很低(str除外, 因为对于str的拼接操作过于频繁, CPython对其进行优化)</p>
</blockquote>
<p>在调用这些运算符中, python优先调用<code>__iadd__|__imul__</code>如果没有会次级调用<code>__add__|__mul__</code></p>
<p>需要注意的是:</p>
<p>如果<code>a</code>实现了<code>__iadd__</code>那么<code>+=</code>会实现就地增量赋值,像<code>a.extend(iterator)</code> 否则会调用<code>__add__</code>, 此时不是就地增加,而是首先计算<code>a + b</code>得到一个新的对象, 然后再将对象赋值给<code>a</code>,即是否实现<code>就地</code>完全取决于这个类型有没有实现<code>__iadd__</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">aa = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">print(<span class="built_in">id</span>(aa))</span><br><span class="line">aa += [<span class="number">1</span>, <span class="number">23</span>]</span><br><span class="line">print(<span class="built_in">id</span>(aa))</span><br><span class="line"></span><br><span class="line">ss = <span class="string">&quot;123&quot;</span></span><br><span class="line">print(<span class="built_in">id</span>(ss))</span><br><span class="line">ss += <span class="string">&quot;qwer&quot;</span></span><br><span class="line">print(<span class="built_in">id</span>(ss))</span><br><span class="line"></span><br><span class="line"><span class="number">1168530238600</span></span><br><span class="line"><span class="number">1168530238600</span></span><br><span class="line"><span class="number">1168257348464</span></span><br><span class="line"><span class="number">1168257157616</span></span><br></pre></td></tr></table></figure>

<p>对不可变序列进行重复拼接操作:</p>
<ol>
<li>创建一个新对象</li>
<li>将原来对象的元素复制到新对象中</li>
<li>追加寻元素</li>
</ol>
<p><code>str有优化:在为str初始化内存的时候,程序会为他流出额外的可扩展空间,因此进行增量操作的时候,并不会涉及复制原有字符串到新位置的这一操作</code></p>
<h3 id="2-6-1-元组的增量赋值"><a href="#2-6-1-元组的增量赋值" class="headerlink" title="2.6.1 元组的增量赋值"></a>2.6.1 元组的增量赋值</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">t = (<span class="number">1</span>, <span class="number">2</span>, [<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">t[<span class="number">2</span>] += [<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;input&gt;&quot;</span>, line <span class="number">2</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: <span class="string">&#x27;tuple&#x27;</span> <span class="built_in">object</span> does <span class="keyword">not</span> support item assignment</span><br><span class="line">print(t)</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br></pre></td></tr></table></figure>

<ol>
<li>元组中的元素被成功拼接</li>
<li>解释器抛出异常</li>
</ol>
<blockquote>
<p>其实写成t[2].extend([3, 4])就不会抛出异常了</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用dis.dis展示操作的python字节码</span></span><br><span class="line">dis.dis(<span class="string">&#x27;tuple[i] += iter&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="number">1</span>           <span class="number">0</span> LOAD_NAME                <span class="number">0</span> (<span class="built_in">tuple</span>)</span><br><span class="line">              <span class="number">2</span> LOAD_NAME                <span class="number">1</span> (i)</span><br><span class="line">              <span class="number">4</span> DUP_TOP_TWO</span><br><span class="line">              <span class="number">6</span> BINARY_SUBSCR</span><br><span class="line">              <span class="number">8</span> LOAD_NAME                <span class="number">2</span> (<span class="built_in">iter</span>)</span><br><span class="line">             <span class="number">10</span> INPLACE_ADD</span><br><span class="line">             <span class="number">12</span> ROT_THREE</span><br><span class="line">             <span class="number">14</span> STORE_SUBSCR</span><br><span class="line">             <span class="number">16</span> LOAD_CONST               <span class="number">0</span> (<span class="literal">None</span>)</span><br><span class="line">             <span class="number">18</span> RETURN_VALUE</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>BINARY_SUBSCR: 将值存入stack (DONE)</li>
<li>INPLACE_ADD 完成 += (DONE)</li>
<li>STORE_SUBSCR 赋值 (ERROR)</li>
</ul>
<p>可以得出:</p>
<ol>
<li>不要把可变对象放在元组里</li>
<li>增量赋值不是一个原子操作<ul>
<li>先计算</li>
<li>后赋值</li>
</ul>
</li>
</ol>
<h2 id="2-7-排序-sort和sorted"><a href="#2-7-排序-sort和sorted" class="headerlink" title="2.7 排序.sort和sorted()"></a>2.7 排序.sort和sorted()</h2><blockquote>
<p>两者都是排序, 且内部算法使用的是<code>Timsort</code>,它是一种自适应算法,会根据原始数据的顺序特点交替使用插入排序和并归排序,而且<code>Timsort</code>算法是稳定的(相等元素的相对位置保持不变)</p>
</blockquote>
<ul>
<li><p>seq.sort: 就地排序, 在原始数据的基础上排序, id不会改变, 这个方法返回<code>None</code> </p>
<ul>
<li>python operation返回<code>None</code>表示就地修改, 不会创建新对象</li>
<li>如果函数或者方法对对象进行就地修改,那么就应该让他返回<code>None</code>,通知调用者传入的参数发生改变,但并未创建新对象</li>
<li><code>random.shuffle(iterator)</code>|<code>id(iterator)</code>不会修改</li>
<li>返回<code>None</code>表示就地改动又个弊端, 就是调用者无法串联接口,即始终使用的是一个对象引用</li>
</ul>
</li>
<li><p>sort(obj) 会返回一个新建的<code>list</code></p>
<ul>
<li>可以接收任何形式的可迭代对象作为参数,包括不可变序列和生成器</li>
<li>最后返回的是一个<code>list</code></li>
</ul>
</li>
<li><p>两者都接受两个参数</p>
<ol>
<li><code>reverse=False</code>: 是否反向排序</li>
<li><code>key=identity function:接收一个排序</code>fun<code>通常使用</code>lambda函数<ul>
<li>恒等函数<code>(identity funtion)</code>默认用元素自己的值进行排序</li>
<li><code>key=str.lower</code>:忽略大小写排序</li>
<li><code>key=len</code>: 基于长度排序</li>
</ul>
</li>
</ol>
</li>
<li><p>接收<code>key</code>参数:</p>
<ol>
<li><code>min|max</code></li>
<li><code>sort|.sort</code></li>
<li><code>itertools.groupby()</code></li>
<li><code>heapq.nlargest()|heapq.nsmller()</code></li>
</ol>
</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> groupby</span><br><span class="line"><span class="keyword">from</span> operator <span class="keyword">import</span> itemgetter</span><br><span class="line"><span class="keyword">from</span> heapq <span class="keyword">import</span> nlargest, nsmallest</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">random.seed(<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line">a = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 就地随机打乱seq</span></span><br><span class="line">random.shuffle(a)</span><br><span class="line"></span><br><span class="line">print(a)</span><br><span class="line">a.sort()</span><br><span class="line">print(a)</span><br><span class="line">print(nlargest(<span class="number">3</span>, a))</span><br><span class="line">print(nsmallest(<span class="number">3</span>, a))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">temp_data = [</span><br><span class="line">    &#123;<span class="string">&quot;name&quot;</span>: <span class="number">1</span>, <span class="string">&quot;age&quot;</span>: <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;name&quot;</span>: <span class="number">2</span>, <span class="string">&quot;age&quot;</span>: <span class="number">32</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;name&quot;</span>: <span class="number">1</span>, <span class="string">&quot;age&quot;</span>: <span class="number">45</span>&#125;,</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据list中每个ele中的name进行排序</span></span><br><span class="line">temp_data.sort(key=itemgetter(<span class="string">&quot;name&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 过滤key=name</span></span><br><span class="line"><span class="keyword">for</span> name, data <span class="keyword">in</span> groupby(temp_data, key=itemgetter(<span class="string">&quot;name&quot;</span>)):</span><br><span class="line">    print(<span class="string">f&quot;name---[<span class="subst">&#123;name&#125;</span>]-----&gt; [<span class="subst">&#123;<span class="built_in">list</span>(data)&#125;</span>]&quot;</span>)</span><br><span class="line">    </span><br><span class="line">[<span class="number">4</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">[<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>]</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">name---[1]-----&gt; [[&#123;&#x27;name&#x27;: 1, &#x27;age&#x27;: 1&#125;, &#123;&#x27;name&#x27;: 1, &#x27;age&#x27;: 45&#125;]]</span><br><span class="line">name---[2]-----&gt; [[&#123;&#x27;name&#x27;: 2, &#x27;age&#x27;: 32&#125;]]</span><br></pre></td></tr></table></figure>

<h2 id="2-8-bisect管理有序序列"><a href="#2-8-bisect管理有序序列" class="headerlink" title="2.8 bisect管理有序序列"></a>2.8 bisect管理有序序列</h2><blockquote>
<p><code>bisect</code>模块包含两个主要的函数<code>bisect</code>和<code>insort</code>, 两者都是通过二分法获取<code>index</code>并进行操作</p>
</blockquote>
<p><code>bisect(haystack, needle)</code>, 在<code>haystack</code>中搜索<code>needle</code>其中:</p>
<ol>
<li><code>haystack</code>必须是有序的</li>
<li><code>return index</code></li>
</ol>
<p><code>bisect</code>可以建立一个用数字作为索引的查询表格, 比如把表格和成绩对应起来</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> bisect</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">grade</span>(<span class="params">socre, grades=<span class="literal">None</span>, breakpoints=<span class="string">&quot;FDCBA&quot;</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> grades <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        grades = [<span class="number">50</span>, <span class="number">60</span>, <span class="number">70</span>, <span class="number">80</span>, <span class="number">90</span>]</span><br><span class="line">    socre_index = bisect.bisect(grades, score)</span><br><span class="line">    <span class="keyword">return</span> breakpoints[socre_index]</span><br></pre></td></tr></table></figure>

<p><code>bisect.insort(seq, item)</code> 把变量<code>item</code>插入到有序序列<code>seq</code>中<code>[本质上是通过二分法获取index后插入]</code></p>
<ul>
<li>如果只是处理数字列表的话, <code>array</code>是一个更好的选择</li>
</ul>
<h2 id="2-9-当list不是首选时"><a href="#2-9-当list不是首选时" class="headerlink" title="2.9 当list不是首选时"></a>2.9 当list不是首选时</h2><p><code>list</code>可以处理多个数据类型,但当面对大量的数字类型时, <code>array</code>是一个更好的选择</p>
<ol>
<li>数组存储的不是<code>num</code>对象,而是数字的机器翻译(字节表述)</li>
<li>和C语言的数组一样, 如果需要频繁的对序列进行进出操作, <code>deque</code>的速度会更快</li>
<li>在处理<code>包含</code>操作时,<code>set</code>是个更好的选择,python对此进行过优化,需要注意的是,<code>set</code>不是序列,他是无序的</li>
</ol>
<h3 id="2-9-1-数组"><a href="#2-9-1-数组" class="headerlink" title="2.9.1 数组"></a>2.9.1 数组</h3><p><code>array.array</code>在存储数字方面效率胜于<code>list</code>且支持<code>list</code>的基本操作,此外数组还提供从文件读取<code>(.frombytes)</code>和存入文件<code>(.tofile)</code>的快速方法</p>
<blockquote>
<p>python中的数组和C一样, 在创建数组时都需要一个类型码,以表明要存储的数据类型</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> array <span class="keyword">import</span> array</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="comment"># init a array</span></span><br><span class="line">floats = array(<span class="string">&quot;d&quot;</span>, [random() <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span> ** <span class="number">7</span>)])</span><br><span class="line"><span class="comment"># get ele by index</span></span><br><span class="line">print(floats[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># init the path</span></span><br><span class="line">file_path = <span class="string">&quot;./floats.bin&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># open the file with &quot;wb&quot;</span></span><br><span class="line">fp = <span class="built_in">open</span>(file_path, <span class="string">&quot;wb&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># write the data to the specify file</span></span><br><span class="line"><span class="comment"># by binaryIO</span></span><br><span class="line">floats.tofile(fp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># close the file</span></span><br><span class="line">fp.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># init an empty array</span></span><br><span class="line">floats2 = array(<span class="string">&quot;d&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># open the file with &quot;rb</span></span><br><span class="line">op = <span class="built_in">open</span>(file_path, <span class="string">&quot;rb&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># open the file 10 ** 7 from file</span></span><br><span class="line"><span class="comment"># by binaryIO</span></span><br><span class="line">floats2.fromfile(op, <span class="number">10</span>**<span class="number">7</span>)</span><br><span class="line">print(floats2[<span class="number">1</span>])</span><br></pre></td></tr></table></figure>

<p>method区别:</p>
<ol>
<li>数组不支持浅拷贝|但支持<code>__deepcopy__</code></li>
<li>数组支持<code>seq.reverse()</code>但不支持<code>seq.__reversed__()</code></li>
<li>数组不支持就地排序<code>seq.sort()</code></li>
</ol>
<blockquote>
<p>从python3.4开始数组不再支持就地排序seq.sort(), 如果需要排序得用sorted函数重新建立一个数组</p>
</blockquote>
<p><code>a = array.array(a.typecode, sorted(a))</code></p>
<h3 id="2-9-2-内存视图"><a href="#2-9-2-内存视图" class="headerlink" title="2.9.2 内存视图"></a>2.9.2 内存视图</h3><p><code>memoryview</code>是一个内置类, 可以让用户在不复制内容的情况下操作同一数组的不同切片</p>
<ul>
<li>本质上是泛化和去数学化的<code>Numpy</code>数组</li>
<li>可以在不需要复制内容的前提下,在任何数据结构之间共享内存 </li>
<li>处理大数据很实用 –&gt; 节省了数据copy内存和时间</li>
<li>需要注意是对原数据直接进行操作</li>
</ul>
<p><code>memoryview.cast</code><strong>能用不同的方式读写同一块内存数据</strong>,并且内容字节不会随意移动,会把同一块内存里的内容打包成一个全新的<code>memoryview.cast</code>对象给你    </p>
<p> <strong>不同方式</strong>:可以用不同的读写方式操作数据</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># init array 类型码“h”</span></span><br><span class="line">temp_array = array(<span class="string">&#x27;h&#x27;</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用数组创一个memoryview实例</span></span><br><span class="line">view = <span class="built_in">memoryview</span>(temp_array)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个memoryview实例,其中把这块内存内容用“B”类型存储[无符号字符]</span></span><br><span class="line">cast = view.cast(<span class="string">&quot;B&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># .tolist()以列表的形式查看|return --&gt; list</span></span><br><span class="line">temp = cast.tolist()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把位于1的字节赋值为6, 因为把占2个字节的整数高位字节改成了6</span></span><br><span class="line"><span class="comment"># 那么之歌有符号整数的值就变为了 1537</span></span><br><span class="line">cast[<span class="number">1</span>] = <span class="number">6</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/memoryview"></p>
<p><img src="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/20220303231533.png"></p>
<h3 id="2-9-3-NumPy-SciPy"><a href="#2-9-3-NumPy-SciPy" class="headerlink" title="2.9.3 NumPy|SciPy"></a>2.9.3 NumPy|SciPy</h3><blockquote>
<p>NumPy和SciPy提供了高阶数组和矩阵操作, python内置数据类型都是一维数据</p>
</blockquote>
<p>维度: row</p>
<p>每个维度所含元素: col</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy</span><br><span class="line"></span><br><span class="line">a = numpy.arange(<span class="number">12</span>)</span><br><span class="line">print(a.shape)</span><br><span class="line"><span class="comment"># 表述1维row 12元素</span></span><br><span class="line">(<span class="number">12</span>,) </span><br><span class="line"></span><br><span class="line"><span class="comment"># using unpacking tuple </span></span><br><span class="line"><span class="comment"># 将1维12元素转化成4维3元素</span></span><br><span class="line">a.shape = <span class="number">4</span>, <span class="number">3</span></span><br><span class="line">[[ <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>]</span><br><span class="line"> [ <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>]</span><br><span class="line"> [ <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>]</span><br><span class="line"> [ <span class="number">9</span> <span class="number">10</span> <span class="number">11</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># get index_row = 1 index_col = 2</span></span><br><span class="line">a[<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># get all index_row index_col = 1</span></span><br><span class="line">a[:, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># transpose() matrix</span></span><br><span class="line"><span class="comment"># return new view</span></span><br><span class="line">a.transpose()</span><br></pre></td></tr></table></figure>

<h3 id="2-9-4-双向队列"><a href="#2-9-4-双向队列" class="headerlink" title="2.9.4 双向队列"></a>2.9.4 双向队列</h3><blockquote>
<p>用列表和append pop(0)可以实现队列 先进先出, 但是删除list中的第一个或者在第一元素前添加一个元素都是十分耗时的, 因为这涉及到所有元素的移动</p>
</blockquote>
<p><code>collection.deque</code>双端队列实现了队列两端元素操作的优化, 但是涉及到中间元素的操作依然会耗时, 并且是一个<code>thread safe</code>类</p>
<ul>
<li>快速从两端对元素进行操作</li>
<li>存储最近使用的几个元素</li>
<li><code>collection.deque</code>可以实现简单的过期机制&lt;通过设置maxlen&gt;</li>
<li><code>append(item)|popleft(index)</code>都是原子操作, 因此<code>deque</code>可以在多线程程序中安全地当作<code>先进先出</code>的<code>栈</code>使用, 而且使用者不需要担心<code>资源锁</code>问题</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="comment"># create dequeue maxlen=10 eles=range(10)</span></span><br><span class="line">dq = deque(<span class="built_in">range</span>(<span class="number">10</span>), maxlen=<span class="number">10</span>)</span><br><span class="line"><span class="comment"># [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># append one ele - right</span></span><br><span class="line">dq.append(<span class="number">10</span>)</span><br><span class="line"><span class="comment"># [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># append one ele - left</span></span><br><span class="line">dq.appendleft(<span class="number">0</span>)</span><br><span class="line"><span class="comment"># [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># rotate num ele default=right | negative=left</span></span><br><span class="line"><span class="comment"># return None ==&gt; will change ori data</span></span><br><span class="line">dq.rotate(<span class="number">3</span>)</span><br><span class="line"><span class="comment"># [7, 8, 9, 0, 1, 2, 3, 4, 5, 6]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># extend iterator ele default=right</span></span><br><span class="line">dq.extend([<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>])</span><br><span class="line"><span class="comment"># [0, 1, 2, 3, 4, 5, 6, 10, 11, 12]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># extendleft iterator ele</span></span><br><span class="line"><span class="comment"># attention the order!</span></span><br><span class="line">dq.extendleft([-<span class="number">1</span>, -<span class="number">2</span>, -<span class="number">3</span>])</span><br><span class="line"><span class="comment"># [-3, -2, -1, 0, 1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure>

<h2 id="2-10-线程安全"><a href="#2-10-线程安全" class="headerlink" title="2.10 线程安全"></a>2.10 线程安全</h2><blockquote>
<p>除了<code>collections.deque</code>外还有其他<code>python</code>标准库也有对队列的实现</p>
</blockquote>
<p><strong>queue</strong></p>
<p>提供了同步<code>线程安全</code>类<code>Queue|LifoQueue|PriorityQueue</code>,不同的<strong>线程</strong>可以利用这些数据类型来交换信息</p>
<ul>
<li>线程通信</li>
<li>三个类构造时都有一个可选参数<code>maxsize</code>用来限制队列大小</li>
<li>在满员时这些类并<strong>不会丢掉旧的元素腾出位置</strong></li>
<li>而是会锁住资源, 直到另外的线程移除了某个元素</li>
<li>适合<strong>控制活跃线程的数量</strong></li>
</ul>
<hr>
<p><strong>multiprocessing</strong></p>
<p>这个包实现了自己的<code>Queue</code>和<code>queue.Queue</code>类似, 是设计给<strong>进程</strong>通信用的还有一个<code>multiprocessiong.JoinableQueue</code></p>
<ul>
<li>进程通信</li>
<li>任务管理</li>
</ul>
<hr>
<p><strong>asyncio</strong></p>
<p><code>python3.4</code>及以上提供, 里面有<code>Queue</code> <code>LifoQueue PriorityQueue</code>和<code>JoinableQueue</code>这些类受到<code>queue</code>和<code>multiprocessing</code>的影响,用于异步变成任务管理</p>
<ul>
<li>异步编程</li>
</ul>
<hr>
<p><strong>heapq</strong></p>
<p>和上面三个模块不同, <code>heapq</code>没有队列类,而是提供了<code>heappush</code>和<code>heappop</code>方法, 可以让用户把<code>可变序列</code>当作堆队列或者优先队列使用</p>
<h2 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h2><p>可变序列 不可变序列</p>
<p>容器序列: 存储引用 非连续存储</p>
<p>扁平序列: 存储值 连续存储 原子性数据</p>
<p>列表: 列表中数据最好是具有相同特性的数据</p>
<p>拆包: 获取元组内数据最安全可靠的方法,<code>*</code>拆包的利器</p>
<p>具名元组: 将元组与数据关联</p>
<ul>
<li><code>namedtuple()._asdict</code>将具名元组转化成<code>ordereddoct</code></li>
<li><code>dict(zip(iter_key, iter_value))</code>普通元组转化<code>dict</code></li>
</ul>
<p>序列切片是python中最受欢迎的语言特性之一</p>
<p><strong>对切片赋值是一个修改可变序列的捷径</strong></p>
<p>重复拼接<code>n*seq</code>要在正确的前提下使用!!!!!</p>
<ul>
<li>初始化含有不可变元素的序列</li>
</ul>
<p>增量赋值<code>+= 和 *=</code>的操作行为和序列本身有关(可变序列|不可变序列) </p>
<p>PS: string类型有优化不会重复复制原数据</p>
<ul>
<li><p>可变序列: 就地修改</p>
</li>
<li><p>不可变序列: 生成新的序列</p>
<p><code>sort</code>和<code>sorted()</code>与<code>key</code>的用法</p>
</li>
<li><p>背后的逻辑是<code>timsort</code>算法, 它是一种自适应算法, 会根据原始数据的特点交替使用插入排序和并归排序</p>
</li>
</ul>
<hr>
<p>元组的鼻祖是ABC语言中的compounds, tuple更准确的说是<code>frozenlist</code></p>
<p><strong>key参数</strong></p>
<p>再使用默认函数key进行排序时<code>Python</code>总会比较两个键, 但是这一计算阶段发生在<code>C</code>语言层, 这也是比调用用户自定义比较函数快的原因</p>
<ul>
<li>当<code>ele</code>是<code>int</code> 或者<code>str</code>时, <code>key</code>支持<code>int</code>或者<code>str</code><ul>
<li><code>int</code>: 比较整个数值</li>
<li><code>str</code>: 只比较第一位数值</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">temp_1 = [<span class="number">3</span>, <span class="number">45</span>, <span class="number">2</span>, <span class="string">&quot;10&quot;</span>, <span class="string">&quot;34&quot;</span>]</span><br><span class="line">print(<span class="built_in">sorted</span>(temp_1, key=<span class="built_in">int</span>))</span><br><span class="line">print(<span class="built_in">sorted</span>(temp_1, key=<span class="built_in">str</span>))</span><br><span class="line"></span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="string">&#x27;10&#x27;</span>, <span class="string">&#x27;34&#x27;</span>, <span class="number">45</span>]</span><br><span class="line">[<span class="string">&#x27;10&#x27;</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">&#x27;34&#x27;</span>, <span class="number">45</span>]</span><br></pre></td></tr></table></figure>

<h1 id="Part3-Dict-Set"><a href="#Part3-Dict-Set" class="headerlink" title="Part3.Dict|Set"></a>Part3.Dict|Set</h1><blockquote>
<p><code>dict</code>的内置函数<code>_builtins_.dict_</code>, Python对字典实现了高度优化 –&gt; <code>hashtable</code></p>
</blockquote>
<h2 id="3-1-泛映射类型"><a href="#3-1-泛映射类型" class="headerlink" title="3.1 泛映射类型"></a>3.1 泛映射类型</h2><p><code>collections.abc</code>中含有<code>Mapping</code>和<code>MutableMapping</code>这俩个抽象类,为<code>dict</code>和其他类似的类型定义形式接口</p>
<p><img src="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/fluent_python_dict_set"></p>
<p>非抽象类一般不会直接继承这些抽象基类, 而是直接对<code>dict</code>或者<code>collections.User.Dict</code>进行扩展,这些抽象基类的主要作用是作为形式化的文档, 定义构建一个映射类型所需要的最基本接口.而且还可以与<code>isinstance</code>一起使用来判断某个数据是否是广义上的<code>mapping</code>类型</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">my_dict = &#123;&#125;</span><br><span class="line"><span class="built_in">isinstance</span>(my_dict, abc.mapping)</span><br></pre></td></tr></table></figure>

<ul>
<li>使用<code>isinstance</code>而不是<code>type</code></li>
<li>可以判断除<code>dict</code>外的广义映射类型</li>
</ul>
<blockquote>
<p>标准库的所有映射类型都是通过dict来实现的,他们有个共同的限制, 即key必须是可散列的</p>
</blockquote>
<p><strong>可散列数据</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">An <span class="built_in">object</span> <span class="keyword">is</span> hashable <span class="keyword">if</span> it has a <span class="built_in">hash</span> value which never changes during its lifetime (it needs a __hash__() method), <span class="keyword">and</span> can be compared to other objects (it needs an __eq__() method). Hashable objects which compare equal must have the same <span class="built_in">hash</span> value. </span><br></pre></td></tr></table></figure>

<ul>
<li>含有<code>__hash__</code> 散列</li>
<li>含有<code>__eq__ </code>比较key</li>
<li>哈希值在整个声明周期不会变化</li>
<li>散列对象相等==&gt;散列值一定相等</li>
</ul>
<p>可散列的数据类型:</p>
<ul>
<li>str</li>
<li>bytes</li>
<li>数值类型</li>
<li>frozenset</li>
<li>tuple(所含的元素全为可散列)</li>
</ul>
<hr>
<p>一般用户自定义的类型的对象都是可散列的, 其中散列值就是<code>id(obj)</code>, 所以所有这些对象在比较时都是不相等的. 如果一个对象实现了<code>__eq__</code>方法, 并且在方法中用到了这个对象的内部状态的话, 那么只有当所有这些内部状态都是不可变的情况下, 这个对象才是可散列的</p>
<hr>
<p><strong>构造字典方法</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;</span><br><span class="line"><span class="built_in">dict</span>(name=<span class="string">&quot;Drink&quot;</span>, age=<span class="string">&quot;23&quot;</span>, score=<span class="string">&quot;98&quot;</span>)</span><br><span class="line"></span><br><span class="line">&gt;&gt;</span><br><span class="line">&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Drink&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="string">&quot;23&quot;</span>, <span class="string">&quot;score&quot;</span>: <span class="string">&quot;98&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;</span><br><span class="line"><span class="built_in">dict</span>(<span class="built_in">zip</span>([<span class="string">&quot;name&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="string">&quot;score&quot;</span>], [<span class="string">&quot;Drink&quot;</span>, <span class="string">&quot;23&quot;</span>, <span class="string">&quot;98&quot;</span>]))</span><br><span class="line"></span><br><span class="line">&gt;&gt;</span><br><span class="line"><span class="built_in">dict</span>([(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Drink&quot;</span>), (<span class="string">&quot;age&quot;</span>, <span class="string">&quot;23&quot;</span>), (<span class="string">&quot;score&quot;</span>, <span class="string">&quot;98&quot;</span>)])</span><br><span class="line"></span><br><span class="line">&gt;&gt;</span><br><span class="line"><span class="built_in">dict</span>(&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Drink&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="string">&quot;23&quot;</span>, <span class="string">&quot;score&quot;</span>: <span class="string">&quot;98&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line">&gt;&gt;</span><br><span class="line">&#123;key, value <span class="keyword">for</span> key, value <span class="keyword">in</span> iterator(key-value-pair)&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-2-字典推导"><a href="#3-2-字典推导" class="headerlink" title="3.2 字典推导"></a>3.2 字典推导</h2><blockquote>
<p>推导式的作用: </p>
<p>创建新的数据对象</p>
<p>过滤作用</p>
</blockquote>
<h2 id="3-3-常见的映射方法"><a href="#3-3-常见的映射方法" class="headerlink" title="3.3 常见的映射方法"></a>3.3 常见的映射方法</h2><p>映射类型的方法很丰富, <code>dict</code> <code>defalutdict</code> 和<code>OrderedDict</code>的常见方法, 后面两个数据类型是<code>dict</code>的变种,位于<code>collections</code>模块内</p>
<p><img src="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/dict01.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/dict02"></p>
<p><img src="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/dict03.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/dict04"></p>
<p><code>default_factory</code>不是一个方法而是一个可调用对象, 他的值在<code>defaultdict</code>初始化中由用户设置</p>
<p><code>OrderedDict.popitem()</code>会移除最先插入的元素**(先进先出)<strong>, 如果<code>.popitem(last=True)</code>则会移除最后插入的元素</strong>(后进先出)**</p>
<p><code>d.update(m, [**kargs])</code>, 在处理<code>m</code>时, 函数首先检验<code>m</code>是否有<code>keys</code>方法,</p>
<ul>
<li>有–&gt;<code>update</code>会把它当作映射对象处理</li>
<li>无–&gt;<code>update</code>会把它当作含有<code>(key-vaule)</code>键值对元素的迭代器</li>
<li><code>python</code>大多数映射类型的构建都采用了相似的逻辑</li>
</ul>
<p><strong>可调用对象</strong></p>
<blockquote>
<p>将类当作函数调用instance()</p>
</blockquote>
<ul>
<li>类中实现<code>__call__</code></li>
<li>快速调用带有某一实例化属性的类的函数</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">eval_some</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">slef, g</span>):</span></span><br><span class="line">        self.g = g</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self, t</span>):</span></span><br><span class="line">        <span class="keyword">return</span> (self.g * <span class="number">2</span>) / t</span><br><span class="line"></span><br><span class="line">earth = eval_some(<span class="number">9.8</span>)</span><br><span class="line">print(earth(<span class="number">10</span>))</span><br></pre></td></tr></table></figure>

<h3 id="3-3-1-更新字典kV"><a href="#3-3-1-更新字典kV" class="headerlink" title="3.3.1 更新字典kV"></a>3.3.1 更新字典kV</h3><p><strong>用setdefault处理找不到的键</strong></p>
<p><code>d[k] --&gt; getitem</code>找不到键时, 会有异常抛出<code>KeyError</code></p>
<ul>
<li>符合python的快速失败哲学</li>
<li>可以使用<code>d.get(k, default)</code>代替异常</li>
<li><strong>当在更新某个键对应的值的时候, 以上俩个方式效率都很低</strong></li>
</ul>
<p>如果要更新字典的一个键值对(包括不存在)使用<code>setdefault(key, default) [operate]</code>这样只会<code>query 1</code>,如果使用<code>if else []</code>则会查询<code>2~3</code>次</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Drink&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里只会查询一次key并更新或初始化</span></span><br><span class="line"><span class="comment"># 如果key存在则对key-value更新</span></span><br><span class="line"><span class="comment"># 不存在将key-default放进映射中</span></span><br><span class="line">a.setdefault(<span class="string">&quot;things&quot;</span>, []).append(<span class="string">&quot;reading&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当存在key时查询2次, 不存在会查询3次</span></span><br><span class="line"><span class="keyword">if</span> <span class="string">&quot;things&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> a:</span><br><span class="line">    a[<span class="string">&quot;things&quot;</span>] = []</span><br><span class="line">a[<span class="string">&quot;things&quot;</span>].append(<span class="string">&quot;reading&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="3-4-映射的弹性键查询"><a href="#3-4-映射的弹性键查询" class="headerlink" title="3.4 映射的弹性键查询"></a>3.4 映射的弹性键查询</h2><blockquote>
<p>在映射中查找不存的key时, 我们希望可以返回一个default value而不是error, 以下俩途径可以实现弹性键查询</p>
</blockquote>
<ol>
<li>通过<code>defaultdict</code>这个类而不是普通的<code>dict</code></li>
<li>自己定义一个<code>dict</code>子类, 并在在子类中实现<code>__missing__</code>方法</li>
</ol>
<h3 id="3-4-1-defaultdict处理不存在的key"><a href="#3-4-1-defaultdict处理不存在的key" class="headerlink" title="3.4.1 defaultdict处理不存在的key"></a>3.4.1 defaultdict处理不存在的key</h3><blockquote>
<p><code>defaultdict</code>是<code>collections</code>中的一个类, 在实例化它时,可以接受一个<code>defaultfoctory</code>不接受参数(一定是可调用的且不接受参数的方法类|函数)</p>
</blockquote>
<ol>
<li><p>在调用<code>d[key]</code>中如果<code>__getitem__</code>找不到对应的<code>key</code>会调用<code>__missing__</code>查看是否定义了<code>defaultfactory</code></p>
</li>
<li><p>将<code>defaultfactory</code>返回的值赋值给<code>d[key]</code></p>
</li>
<li><p>更新<code>dict</code></p>
</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line">temp = defaultdict(<span class="built_in">list</span>)</span><br><span class="line"></span><br><span class="line">temp[<span class="string">&quot;name&quot;</span>]</span><br><span class="line">print(temp)</span><br><span class="line">&gt;&gt; </span><br><span class="line">defaultdict(&lt;class &#x27;list&#x27;&gt;, &#123;&quot;name&quot;: []&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>如果<code>defaultfactory=None</code>在没有找到对应的<code>key</code>时会抛出<code>KeyError</code></p>
</li>
<li><p><code>defaultfactory</code>只会在<code>__getitem__</code>中调用, 比如<code>dict[key]</code>才会被调用, 其中连接两者桥梁的时<code>__missing__</code></p>
</li>
</ul>
<h3 id="3-4-2-特殊方法missing"><a href="#3-4-2-特殊方法missing" class="headerlink" title="3.4.2 特殊方法missing"></a>3.4.2 特殊方法missing</h3><blockquote>
<p>所有的映射类型在找不到key的时候都会牵扯到missing, python基类虽然直到这个方法,但并没有定义这个方法, 不过, 如果一个class继承了dict并且这个类提供了missing方法,那么在<code>getitem</code>找不到值的时候不会抛出<code>异常</code></p>
</blockquote>
<p>特点:</p>
<ol>
<li><code>missing</code>方法只会被<code>getitem</code>调用</li>
<li>不会对<code>.get()</code> <code>__contains__</code>方法产生影响</li>
</ol>
<p><code>dict[key] -- __getitem__ -- __missing__</code></p>
<p><code>dict.get() -- get -- try except</code></p>
<hr>
<p>如果要自定义一个映射类型, 更合适的策略是继承<code>collections.UserDict</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># define the new mapping class by user based on dict</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrKeyDict</span>(<span class="params"><span class="built_in">dict</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__missing__</span>(<span class="params">self, key</span>):</span></span><br><span class="line">        <span class="comment"># 如果键不存在且本身是str则抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(key, <span class="built_in">str</span>):</span><br><span class="line">            <span class="keyword">raise</span> KeyError(key)</span><br><span class="line">        <span class="comment"># 如果键不存在且本身不是str则调用getitem</span></span><br><span class="line">        <span class="keyword">return</span> self[<span class="built_in">str</span>(key)]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># get方法吧查找工作用self[key]的形式委托给getitem,这样</span></span><br><span class="line">    <span class="comment"># 在宣布查找失败之前还missing再给某个键一个机会</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, key, default=<span class="literal">None</span></span>):</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> self[key]</span><br><span class="line">        <span class="keyword">except</span> KeyError:</span><br><span class="line">            <span class="comment"># 如果cast异常则missing也失败了,返回default</span></span><br><span class="line">            <span class="keyword">return</span> default</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__contains__</span>(<span class="params">self, key</span>):</span></span><br><span class="line">        <span class="comment"># 按照传入键的原本值来查找,如果没找到则转化成str再次查找</span></span><br><span class="line">        <span class="keyword">return</span> key <span class="keyword">in</span> self.keys() <span class="keyword">or</span> <span class="built_in">str</span>(key) <span class="keyword">in</span> self.keys()</span><br></pre></td></tr></table></figure>

<blockquote>
<p> 像<code>k in dict.keys()</code>操作在<code>python3</code>中是十分快速的, 即使映射类型对象很庞大, 因为:</p>
</blockquote>
<ul>
<li><code>dict.keys()</code>返回的值是一个视图, 就像集合, 在里面查找一个元素是十分快的</li>
<li><code>key in dict</code>扫描的是一个list, 处理大数据效率低<code>dict.keys()</code></li>
</ul>
<h2 id="3-5-字典的变种"><a href="#3-5-字典的变种" class="headerlink" title="3.5 字典的变种"></a>3.5 字典的变种</h2><p>都是基于<code>collections</code>库</p>
<blockquote>
<p>除了bultin中定义的dict外, 其余字典的变种都是<code>collections</code>库中的</p>
</blockquote>
<h3 id="UserDict"><a href="#UserDict" class="headerlink" title="UserDict"></a>UserDict</h3><blockquote>
<p>比较特殊的一种dict, 这个类其实是把builtin中的dict用纯Pyhton又实现了一遍</p>
</blockquote>
<p>一般用于用户自定义子类的继承</p>
<h3 id="OrderedDict"><a href="#OrderedDict" class="headerlink" title="OrderedDict"></a>OrderedDict</h3><blockquote>
<p>这个类型会在添加键的时候保持顺序, 因此键的每次迭代次序总是一致的</p>
</blockquote>
<p><code>OrderedDict</code>的<code>popitem</code>方法默认删除并返回的时字典里的最后一个元素(先进后出), 如果<code>popitem(last=False)</code>则会删除并返回第一个元素(先进先出)</p>
<h3 id="ChainMap"><a href="#ChainMap" class="headerlink" title="ChainMap"></a>ChainMap</h3><p><a target="_blank" rel="noopener" href="https://zditect.com/main-advanced/python/python-chainmap.html">什么是chainmap?为什么要搞chainmap</a></p>
<blockquote>
<p>该类型可以容纳数个不同的映射对象,然后在进行键查找操作时, 这些对象会被当作一个整体逐个进行查找,直到键被找到</p>
</blockquote>
<p>在给有嵌套功能作用域的语言做解释器的时候很有用, 可以用一个映射对象来代表一个作用域的上下文</p>
<p><code>ChainMap</code>可以将多个字典合并为一个独有的字典，这样的操作 并不是对源数据的拷贝，而是指向源数据，假如原字典数据修改，<code>ChainMap</code>映射也会改变；如果对<code>ChainMap</code>的结果修改，那么原数据一样也会被修改</p>
<p><strong>使用update进行合并字典,是对源数据的拷贝</strong></p>
<ol>
<li><p><code>ChainMap</code> 可接受多个映射然后在逻辑上使它们表现为一个单独的映射结构；它只是维护了一个记录底层映射关系的列表，然后去重定义常用的字典操作</p>
</li>
<li><p>如果有重复的键，会采用第一个映射中键对应的值</p>
</li>
<li><p>修改 <code>ChainMap </code>映射结构，会同时作用在自己和原始字典结构上</p>
</li>
<li><p>可以使用字典的 <code>update() </code>方法，来替代上面的合并方案；但是这就需要创建一个新的字典对象(或者修改原字典，破坏了原始数据)，并且原始字典做了修改，并不会反映到新建的字典上</p>
</li>
<li><p><code>ChainMap </code>使用的就是原始字典，因此原字典变，它也会改变。</p>
</li>
<li><p><strong>如果在使用 ChainMap 合并多个字典时，字典中有重复的 key 值，默认取第一个字典中 key 对应的 value</strong> ，从原理上面讲，ChainMap 实际上是把放入的字典存储在一个队列中，当进行字典的增加删除等操作只会在第一个字典上进行，当进行查找的时候会依次查找<code>(以查找的第一个key-value返回)</code></p>
</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">m1 = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Drink&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">23</span>&#125;</span><br><span class="line">m2 = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Drinkle&quot;</span>, <span class="string">&quot;score&quot;</span>: <span class="number">93</span>&#125;</span><br><span class="line">m3 = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Spark&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">23</span>, <span class="string">&quot;score&quot;</span>: <span class="number">98</span>, <span class="string">&quot;sex&quot;</span>: <span class="string">&quot;man&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">cm = collections.ChainMap(m1, m2, m3)</span><br><span class="line">print(cm)</span><br><span class="line">print(cm[<span class="string">&quot;name&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> cm.items():</span><br><span class="line">    print(key, <span class="string">&quot; &lt;--&gt; &quot;</span>, value)</span><br><span class="line"></span><br><span class="line">ChainMap(&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Drink&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">23</span>&#125;, &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Drinkle&#x27;</span>, <span class="string">&#x27;score&#x27;</span>: <span class="number">93</span>&#125;, &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Spark&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">23</span>, <span class="string">&#x27;score&#x27;</span>: <span class="number">98</span>, <span class="string">&#x27;sex&#x27;</span>: <span class="string">&#x27;man&#x27;</span>&#125;)</span><br><span class="line">Drink</span><br><span class="line">name  &lt;--&gt;  Drink</span><br><span class="line">age  &lt;--&gt;  23</span><br><span class="line">score  &lt;--&gt;  93</span><br><span class="line">sex  &lt;--&gt;  man</span><br></pre></td></tr></table></figure>

<h3 id="Counter"><a href="#Counter" class="headerlink" title="Counter"></a>Counter</h3><blockquote>
<p>这个类型会给键准备一个整数计数器, 每次更新一个键的时候都会增加这个计数器.因此这个类型可以用来给可散列对象计数(str bytes frozenset 数值型)或者当成多重集来用–&gt;多重集合就是集合里的元素可以出现不止一次, Counter实现了+ - 运算符来和并记录</p>
</blockquote>
<p>还有像<code>most_common(num)</code>这类方法, 会按照次序返回映射里最常见的num个键和他们的计数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">counter = collections.Counter(<span class="string">&quot;asdxzcsdfwerewrfewzsqawd&quot;</span>)</span><br><span class="line"></span><br><span class="line">print(counter)</span><br><span class="line"></span><br><span class="line">counter.update(<span class="string">&quot;asdsassd&quot;</span>)</span><br><span class="line"></span><br><span class="line">print(counter.most_common())</span><br><span class="line"></span><br><span class="line">Counter(&#123;<span class="string">&#x27;w&#x27;</span>: <span class="number">4</span>, <span class="string">&#x27;s&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;d&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;e&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;a&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;z&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;f&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;r&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;x&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;q&#x27;</span>: <span class="number">1</span>&#125;)</span><br><span class="line"></span><br><span class="line">[(<span class="string">&#x27;s&#x27;</span>, <span class="number">7</span>), (<span class="string">&#x27;d&#x27;</span>, <span class="number">5</span>)]</span><br></pre></td></tr></table></figure>

<h2 id="3-6-子类化UserDict"><a href="#3-6-子类化UserDict" class="headerlink" title="3.6 子类化UserDict"></a>3.6 子类化UserDict</h2><blockquote>
<p>自定义mapping类型,以<code>UserDict</code>为基类更加方便,因为<code>UserDict</code>是原生的方法, 而<code>dict</code>可能会走写捷径,导致我们不得不在子类中重写这些方法, 而<code>UserDict</code>则不会出现这个问题</p>
</blockquote>
<p>需要注意的是, <code>UserDict</code>并不是<code>Dict</code>的子类,但在<code>data</code>属性是基于<code>Dict</code>的实例实现的, 这个属性实际上是<code>UserDict</code>最终存储数据的地方</p>
<ul>
<li><code>UserDict</code>的子类在实现<code>__setitem__</code>避免了不必要的递归</li>
<li>可以让<code>__contains__</code>的代码更加简洁</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrKeyDict</span>(<span class="params">collections.UserDict</span>):</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__missing__</span>(<span class="params">self, key</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(key, <span class="built_in">str</span>):</span><br><span class="line">            <span class="keyword">raise</span> KeyError (key)</span><br><span class="line">        <span class="keyword">return</span> self[<span class="built_in">str</span>(key)]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__contains__</span>(<span class="params">self, key</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">str</span>(key) <span class="keyword">in</span> self.data</span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span>(<span class="params">self, key, value</span>):</span></span><br><span class="line">        self.data[<span class="built_in">str</span>(key)] = value</span><br></pre></td></tr></table></figure>

<p><code>UserDict</code>继承的是<code>MutableMapping</code>,所以<code>StrKeyDict</code>里剩下的映射类型方法都是从<code>UserDict</code> <code>MutableMapping</code> 和 <code>Mapping</code>这些超类中继承的</p>
<p><code>Mapping</code>类虽然是一个抽象基类<code>ABC</code>,但它提供了许多实用方法</p>
<p><strong>1.MutableMapping.update</strong></p>
<ul>
<li>可以直接使用<code>dict.update(obj)</code></li>
<li>定义在<code>__init__</code>中, 实列化时可以接受多个不同类型的参数构造<code>dict</code></li>
<li>本质上调用的是<code>__setitem__</code> –&gt; <code>self[key]=value</code></li>
</ul>
<p><strong>2.Mapping.get</strong></p>
<ul>
<li><code>.get()</code> –&gt; <code>def get()</code> –&gt; <code>try except</code></li>
</ul>
<h2 id="3-7-不可变映射类型"><a href="#3-7-不可变映射类型" class="headerlink" title="3.7 不可变映射类型"></a>3.7 不可变映射类型</h2><blockquote>
<p>接受一个mapping类型, 返还一个动态只读视图, 在原数据上更改可以反映到视图上,但不能对视图进行写操作, 只能读取 <code>types.MappingProxyType</code></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> types <span class="keyword">import</span> MappingProxyType</span><br><span class="line"></span><br><span class="line">temp = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Drink&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">proxy_dict = MappingProxyType(temp)</span><br><span class="line"></span><br><span class="line">&gt;&gt;</span><br><span class="line">proxy_dict[<span class="string">&quot;name&quot;</span>] </span><br><span class="line">proxy_dict[<span class="string">&quot;age&quot;</span>]</span><br><span class="line">proxy_dict[<span class="string">&quot;score&quot;</span>] = <span class="number">90</span></span><br><span class="line">temp[<span class="string">&quot;age&quot;</span>] = <span class="number">23</span></span><br><span class="line">proxy_dict</span><br><span class="line">&gt;&gt;</span><br><span class="line">&lt;Dirnk&gt;</span><br><span class="line">&lt;KeyError: <span class="string">&#x27;age&#x27;</span>&gt;</span><br><span class="line">&lt;TypeError: <span class="string">&#x27;mappingproxy&#x27;</span> <span class="built_in">object</span> does <span class="keyword">not</span> support item assignment&gt;</span><br><span class="line">&lt;SUCCESS&gt;</span><br><span class="line">&lt;&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Drink&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">23</span>&#125;&gt;</span><br></pre></td></tr></table></figure>

<h2 id="3-8-集合论"><a href="#3-8-集合论" class="headerlink" title="3.8 集合论"></a>3.8 集合论</h2><blockquote>
<p>集合从2.3以module出现, 到2.6才成为built-in type, 包括<code>set</code> <code>frozenset</code></p>
<p>集合的本质是许多唯一对象的聚集(去重)</p>
<p>拥有极快的查找速度 ==&gt; 散列表</p>
</blockquote>
<p>空集 –&gt; <code>set()</code></p>
<p><code>&#123;&#125;</code> –&gt; <code>dict 本质上是一个空字典</code></p>
<p>集合内元素必须是<code>can hash</code>即可散列的</p>
<ul>
<li>str</li>
<li>bytes</li>
<li>数值类型</li>
<li>frozenset</li>
</ul>
<p>集合的操作</p>
<p><code>|</code> –&gt; <code>∪</code></p>
<p><code>&amp;</code> –&gt; <code>∩</code> –&gt; <code>set.intersection(set)</code></p>
<p><code>-</code> –&gt; 差集</p>
<h3 id="3-8-1-集合字面量「仅set」"><a href="#3-8-1-集合字面量「仅set」" class="headerlink" title="3.8.1 集合字面量「仅set」"></a>3.8.1 集合字面量「仅set」</h3><blockquote>
<p>除了空集合<code>set()</code>外, 集合的字面量如同<code>&#123;1&#125; &#123;1, 2&#125;</code></p>
</blockquote>
<p>字面量语句构造集合的方法比<code>set([1, 2, &quot;3&quot;])</code>更快, 后者<code>python</code>需要新建一个列表, 最后吧这个列表传入到构造方法中, 如果是<code>&#123;1, 2, &quot;3&quot;&#125;</code>的字面量构造, <code>python</code>会利用一个<code>BUILD_SET</code>的字节码创建集合</p>
<p>使用反汇编函数查看字节码:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> dis <span class="keyword">import</span> dis</span><br><span class="line"></span><br><span class="line">dis(<span class="string">&quot;&#123;1&#125;&quot;</span>)</span><br><span class="line">dis(<span class="string">&quot;set([1])&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">0</span> LOAD_CONST    <span class="number">0</span> (<span class="number">1</span>)</span><br><span class="line"><span class="number">2</span> BUILD_SET     <span class="number">1</span></span><br><span class="line"><span class="number">4</span> RETURN_VALUE</span><br><span class="line">            </span><br><span class="line"><span class="number">0</span> LOAD_NAME      <span class="number">0</span> (<span class="built_in">set</span>)</span><br><span class="line"><span class="number">2</span> LOAD_CONST     <span class="number">0</span> (<span class="number">1</span>)</span><br><span class="line"><span class="number">4</span> BUILD_LIST     <span class="number">1</span>  --</span><br><span class="line"><span class="number">6</span> CALL_FUNCTION  <span class="number">1</span>  --</span><br><span class="line"><span class="number">8</span> RETURN_VALUE</span><br></pre></td></tr></table></figure>

<p><code>python</code>对于<code>frozenset</code>没有特殊字面量句法, 只能采用构造的方式</p>
<h3 id="3-8-2-集合推导"><a href="#3-8-2-集合推导" class="headerlink" title="3.8.2 集合推导"></a>3.8.2 集合推导</h3><blockquote>
<p>同列表推导字典推导一样</p>
</blockquote>
<ol>
<li>创建一个新的序列</li>
<li>起到过滤条件的作用</li>
</ol>
<h3 id="3-8-3-集合的操作"><a href="#3-8-3-集合的操作" class="headerlink" title="3.8.3 集合的操作"></a>3.8.3 集合的操作</h3><p><img src="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/338FE41118E025DEC0F08E62E79242FB.png"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># KeyError</span></span><br><span class="line">a.remove(<span class="number">4</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment"># pop the first one ele</span></span><br><span class="line">a.pop()  </span><br><span class="line"></span><br><span class="line"><span class="comment"># if number not in set do nothing</span></span><br><span class="line">a.discard(<span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<p>下表中, 缀运算符需要两侧的对象都是集合类型, 但是其他的方法则只要求所传入的参数是可迭代对象</p>
<p><img src="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/04AFD0F1F67F70C8B753E15D433EBB86.png"></p>
<p><strong>集合的比较运算符, 返回布尔值</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/9074D4974B2971BC1FA4BFBE2710A364.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/6D3B0816875580AF04759FD9538975E0.png"></p>
<p><strong>集合的其他操作方法</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/56D97AD7F6AB7ADC76CFDFC71D3CF306.png"></p>
<h2 id="3-9-dict和set的原理"><a href="#3-9-dict和set的原理" class="headerlink" title="3.9 dict和set的原理"></a>3.9 dict和set的原理</h2><blockquote>
<p><code>principles of dict and set</code>, 了解<code>python</code>里的字典和集合类型,他们背后所涉及的<code>hash table</code>是必不可少的</p>
<p>这节将会回答以下几个问题</p>
</blockquote>
<ol>
<li><code>python</code>中的<code>dict</code>和<code>set</code>效率有多高?</li>
<li>为什么他是无序且不稳定的?</li>
<li>为什么并不是所有的<code>python</code>对象都可以当作<code>dict</code>的<code>key</code>或<code>set</code>里的<code>number</code>?</li>
<li>为什么<code>dict</code>的<code>key</code>和<code>set</code>的<code>number</code>的顺序是根据它们被添加的次序而定的,以及为什么在映射对象的生命周期中,这个顺序并不是一成不变的?</li>
<li>为什么不应该迭代循环<code>dict</code>或<code>set</code>的同时往里面添加元素?</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">temp_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">a = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Drink&quot;</span>&#125;.fromkeys(temp_list, <span class="string">&quot;&quot;</span>)</span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line"><span class="built_in">dict</span>.fromkeys(iterator, values)</span><br><span class="line"><span class="comment"># Create a new dictionary with keys from iterable</span></span><br><span class="line"><span class="comment"># and values set to value.</span></span><br><span class="line">&#123;<span class="number">1</span>: <span class="string">&#x27;&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;&#x27;</span>, <span class="number">3</span>: <span class="string">&#x27;&#x27;</span>, <span class="number">4</span>: <span class="string">&#x27;&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-9-1-效率实验"><a href="#3-9-1-效率实验" class="headerlink" title="3.9.1 效率实验"></a>3.9.1 效率实验</h3><p>使用<code>in set(&amp;)</code>  操作符,分别在<code>set dict list</code>查询是否含有某个元素</p>
<p>其中结果如下:</p>
<p>最快的是<code>&amp;</code></p>
<p>最慢的是<code>list in</code></p>
<p>由于列表背后没有散列表来支持<code>in</code>运算符, 每次搜索都会扫描一次完成的列表 [说明了, <code>dict</code>和<code>set</code>在使用散列表存储的时候使用了类似排序的功能]</p>
<h3 id="3-9-2-dict中的散列表"><a href="#3-9-2-dict中的散列表" class="headerlink" title="3.9.2 dict中的散列表"></a>3.9.2 dict中的散列表</h3><blockquote>
<p>这一节只是笼统的描述python如何使用hashtable来实现dict, 其中Cpython对dict有过优化</p>
</blockquote>
<p><strong>散列表</strong> </p>
<ul>
<li><p>本质上是一个稀疏数组(总是有空白元素的数组称为稀疏数组)</p>
</li>
<li><p>散列表中的单元叫做表元(bucket)</p>
</li>
<li><p>在dict的散列表中, 每个键值对占用一个表元,一个表元有俩部分, 分别是对值的引用和对键的引用</p>
</li>
<li><p>表元大小一致, 可以通过偏移量读取特定的表元</p>
</li>
<li><p>python会保证散列表中大约三分之一的表元是空的,如果达到阈值, <strong>原有的散列表会被复制</strong>到一个更大的空间中</p>
</li>
<li><p>把对象放入散列表, 首先使用<code>hash()</code>计算这个元素键的散列值</p>
</li>
</ul>
<p><strong>有关散列表的概念</strong>:</p>
<p><strong>1.散列值和相等性</strong></p>
<blockquote>
<p><code>hash()</code> <code>  ==</code></p>
</blockquote>
<ul>
<li><code>hash()</code>可以用于任何内置类型对象, 自定义对象调用自定义实现的<code>__hash__</code></li>
<li>如果俩对象在比较时是相等的, 则它们的散列值一定相等(但对象的类型和存储结构不一定相等)</li>
<li>为了让散列值可以当作散列表的索引, 越是相似但不相等的对象,他们散列值的差别就越大</li>
</ul>
<p>从python3.3开始 str bytes datetime对象的散列值计算过程中多了随机<code>加盐</code> 所加盐值是python进程内的一个常量每次启动python解释器都会生成一个不同的盐值,目的是为了防止<code>DOS</code>攻击而采取的安全措施</p>
<p><strong>2.散列表算法</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/20220312164711.png"></p>
<p>以<code>dict[key]</code>为例:</p>
<ul>
<li>python首先会调用<code>hash(key)</code>计算key的散列值</li>
<li>把计算的散列值最低的几位数字当作偏移量, 在散列表中查找表元<code>bucket</code><ul>
<li>具体取几位要看散列表的大小</li>
<li>若对应的表元为空 –&gt;  <code>KeyError</code></li>
<li>若非空 –&gt; 表元里会有<code>key-value-pairs</code></li>
</ul>
</li>
<li>python会校验<code>key-value-pairs</code>中的<code>key</code>与输入的<code>key</code>是否相等<code>==</code><ul>
<li>相等 –&gt; 返回对应的<code>value</code></li>
<li>不等 –&gt; 散列冲突</li>
</ul>
</li>
<li>散列冲突: 因为散列表所做的是把随机的元素映射到只有几位的数字上,而散列表本身的索引又依赖于这个数字的一部分<ul>
<li>为了解决冲突,算法会在散列值中另外再取几位数字用特殊方法处理后把新的数字当作索引寻找表元,并重复之前的操作</li>
</ul>
</li>
</ul>
<hr>
<p><strong>添加新元素:</strong></p>
<p>发现表元为空时会放入一个新元素</p>
<p><strong>更新元素</strong>:</p>
<p>找到表元后会更新元素</p>
<p><strong>需要注意的是,python会按照散列表的拥挤程度来决定是否要重新分配内存为它扩容,如果增加散列表的大小,那散列值所占的位数和用作索引的位数会增加,减少了散列冲突</strong></p>
<hr>
<p>**注意:**Cpython中规定如果有一个整型对象,而且他能存进入一个机器字中,那么他的散列值就是它本身</p>
<h3 id="3-9-3-dict的实现和限制"><a href="#3-9-3-dict的实现和限制" class="headerlink" title="3.9.3 dict的实现和限制"></a>3.9.3 dict的实现和限制</h3><blockquote>
<p>主要讨论hashtable给dict带来的优势和限制</p>
</blockquote>
<p><strong>1.键必须是可散列的</strong></p>
<p>包括: str bytes frozenset 数值类型</p>
<p>一个可散列的对象必须包括</p>
<ul>
<li>支持<code>hash()</code>函数并且通过<code>__hash__</code>所得到的散列值不变(在他的生命周期中)</li>
<li>支持通过<code>__eq__</code>方法检测相等性</li>
<li>若<code>a==b</code>那么<code>hash(a)==hash(b)</code></li>
<li>所有由用户自定义的对象默认都是可散列的,因为他们的散列值都是<code>id()</code>来获取的,而且他们不相等</li>
</ul>
<p>**注意:**如果自定义的类实现了<code>_eq_</code>,并且希望他是可散列的, 那么必须定义一个恰当的<code>_hash_</code>保证<code>a==b</code>时<code>hash(a)==hash(b)</code>另一方面,如果一个含有自定义<code>_eq_</code>依赖的类处于可变状态, 那么就不要在这个类中实现<code>_hash_</code>,因为他的实例是不可散列的</p>
<hr>
<p><strong>2.字典在内存中开销大</strong></p>
<ul>
<li>字典使用散列表实现</li>
<li>散列表是稀疏的</li>
<li>在自定义类中<code>_slots_</code>属性可以改变实例属性的存储方式, 由<code>dict--&gt;tuple</code></li>
<li><code>optimization</code>优化往往和可维护相对立<code>maintain</code></li>
</ul>
<hr>
<p><strong>3.键查询很快</strong></p>
<ul>
<li>空间换时间</li>
<li><code>hash table</code>实现了无视数据量大小的快速访问<code>(在数据能放入内存的前提下)</code></li>
</ul>
<p><strong>4.键的次序取决于添加次序</strong></p>
<ul>
<li>在添加新键时, 可能会由哈希冲突, 此时新键会被安排到另一个表元(bucket)中</li>
<li>但是和俩个值相同的键添加顺序有关</li>
<li>虽然逻辑和面向用户表现形式上如此,在判断俩上依旧是相等的</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Drink&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">23</span>&#125;</span><br><span class="line">b = &#123;<span class="string">&quot;age&quot;</span>: <span class="number">23</span>, <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Drink&quot;</span>&#125;</span><br><span class="line"><span class="keyword">if</span> a == b:</span><br><span class="line">    print(<span class="string">&quot;you are right&quot;</span>)</span><br><span class="line">&gt;&gt;</span><br><span class="line">right</span><br></pre></td></tr></table></figure>

<p><strong>5.添加新键会改变已有键的顺序</strong></p>
<blockquote>
<p>尽量不要边遍历边添加新键</p>
</blockquote>
<ul>
<li>添加新键</li>
<li>python解释器为字典扩容</li>
<li>新键散列表并把已有元素添加到新表中</li>
<li>这个过程可能会发生散列冲突,导致新散列表中键的次序变化</li>
<li>如果在迭代一个字典的所有键的过程中同时对字典进行修改,那么这个循环可能会跳过一些键甚至是字典中已有的键</li>
</ul>
<p>因此:不要对字典同时进行迭代和修改,如果扫描并修改一个字典,最好分成俩步 :</p>
<p>​        [迭代–得出要添加的内容–并把内容放到新字典]  </p>
<p>​        [对原有字典进行更新]</p>
<p>不过在<code>python3</code>中对此进行了优化,<code>.keys()</code> <code>.items()</code> <code>.values()</code>方法返回的都是字典视图, 换句话说这些方法返回的更像<code>set</code>而不是<code>list</code>,此外视图还可以动态的反馈字典的变化</p>
<h3 id="3-9-4-set的实现和限制"><a href="#3-9-4-set的实现和限制" class="headerlink" title="3.9.4 set的实现和限制"></a>3.9.4 set的实现和限制</h3><blockquote>
<p>set 和 frozenset的实现也依赖于散列表</p>
</blockquote>
<ul>
<li>在散列表中只存放元素的引用(类似只存放key的引用)</li>
<li>集合中的元素必须是可散列的</li>
<li>集合很消耗内存</li>
<li>可以很高效的判断元素是否在集合中</li>
<li>元素的次序取决于被添加到集合中的顺序</li>
<li>在集合里添加元素会改变集合里已有元素的次序</li>
</ul>
<h2 id="本章小结-1"><a href="#本章小结-1" class="headerlink" title="本章小结"></a>本章小结</h2><p><code>dict</code>是<code>python</code>的基石, 除了<code>dict</code>外<code>builtin</code>里还提供了特殊映射比如<code>collections</code>里的<code>defaultdict</code> <code>OrderDict</code> <code>ChainMap</code> <code>Counter</code> <code>UserDict</code>以及<code>types</code>里的<code>MappingProxyTypes</code></p>
<p><strong>映射类型的重要方法</strong></p>
<p><strong>1.setdefault</strong></p>
<ul>
<li>更新字典里存档的可变值(比如列表)</li>
<li>避免重复搜索键</li>
</ul>
<p><strong>2.update</strong></p>
<ul>
<li>让批量更新字典成为可能</li>
</ul>
<p><strong>3.missing</strong></p>
<ul>
<li>可以自定当找不到对应的<code>key</code>时, 对象如何处理</li>
</ul>
<p><code>collections.abc</code>模块提供了<code>Mapping</code>和<code>MutableMapping</code>俩大抽象基类,利用它可以进行类型查询或者引用,此外还有<code>Set</code>和<code>MutableSet</code>俩大抽象基类</p>
<h1 id="Part4-TextAndBytes"><a href="#Part4-TextAndBytes" class="headerlink" title="Part4.TextAndBytes"></a>Part4.TextAndBytes</h1><blockquote>
<p>human use text and computer use bytes.</p>
</blockquote>
<p>本章节主要讨论:</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 字符 码位 字节表述</li>
<li><input checked="" disabled="" type="checkbox"> <code>bytes</code> <code>bytearray</code> 和 <code>memoryview</code>等二进制序列的独特性</li>
<li><input checked="" disabled="" type="checkbox"> 全部<code>unicode</code>和陈旧字符集的编解码器</li>
<li><input checked="" disabled="" type="checkbox"> 避免和处理编码错误</li>
<li><input checked="" disabled="" type="checkbox"> 处理文本文件的最佳实践</li>
<li><input checked="" disabled="" type="checkbox"> 默认编码的陷阱和标准<code>I/O</code>问题</li>
<li><input checked="" disabled="" type="checkbox"> 规范化 <code>Unicode</code>文本 进行安全比较</li>
<li><input checked="" disabled="" type="checkbox"> 规范化 大小写折叠和暴力移除音调符号的实用函数</li>
<li><input checked="" disabled="" type="checkbox"> 使用<code>locale</code>模块和<code>PyUCA</code>库正确地排序<code>Unicode</code>文本</li>
<li><input checked="" disabled="" type="checkbox"> <code>Unicode</code>数据库中的字符元数据</li>
<li><input checked="" disabled="" type="checkbox"> 能处理字符串和字节序列的双模式<code>API</code></li>
</ul>
<h2 id="4-1-字符问题"><a href="#4-1-字符问题" class="headerlink" title="4.1 字符问题"></a>4.1 字符问题</h2><blockquote>
<p>字符串:一个字符序列, 本质上是一个序列; 问题是什么是字符?</p>
<p>2015年字符的定义为Unicode字符(面向人)</p>
</blockquote>
<p>Unicode标准把字符的标识-和具体的字节表述进行了区分:</p>
<ul>
<li><strong>字符的标识即码位</strong>:是0<del>1114111的数字(10进制)在<code>unicode</code>标准中以4</del>6个十六进制数字标识,并且加前缀<code>U+</code></li>
<li><strong>字符的具体表述取决于所用的编码</strong>:编码是在码位和字节序列之间转换时使用的算法</li>
</ul>
<p><strong>把码位转化成字节序列的过程时编码,反之是解码</strong></p>
<p>简单的理解: </p>
<p><strong>码位</strong>是数字映射后的准备编码的<strong>字符标识</strong>;</p>
<p><strong>字节序列</strong>是通过一定编码规则(算法)编码后的用于计算机存储和传播的<strong>字节序列</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/20220313165653.png"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># init string</span></span><br><span class="line">a = <span class="string">&#x27;advdv我&#x27;</span>  </span><br><span class="line"></span><br><span class="line"><span class="comment"># advdv我字符串有四个Unicode字符</span></span><br><span class="line">print(<span class="built_in">len</span>(a))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用UTF-8把str对象编码成bytes对象</span></span><br><span class="line">b = a.encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># check b and len of b</span></span><br><span class="line"><span class="comment"># \xe6 --&gt; one 16-base</span></span><br><span class="line"><span class="comment"># 我 -encode-&gt; three bytes</span></span><br><span class="line"><span class="comment"># -&gt; \xe6\x88\x91</span></span><br><span class="line">print(b, <span class="built_in">len</span>(b))</span><br><span class="line"></span><br><span class="line"><span class="comment"># decode b with utf-8</span></span><br><span class="line"><span class="comment"># 使用UTF-8把bytes对象解码成str对象</span></span><br><span class="line">print(b.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line">&gt;&gt;</span><br><span class="line"><span class="number">6</span> </span><br><span class="line"><span class="comment"># bytes对象字面量以b开头</span></span><br><span class="line"><span class="comment"># 字节序列b有8个字节 我被编码成了三个字节</span></span><br><span class="line"><span class="string">b&#x27;advdv\xe6\x88\x91&#x27;</span> <span class="number">8</span></span><br><span class="line">advdv我</span><br></pre></td></tr></table></figure>

<p><code>python3</code>的<code>str</code>类型基本相当于<code>python2</code>的<code>unicode</code>类型, 但是前者的<code>bytes</code>类型却不是把<code>str</code>类型换个名字那么简单</p>
<h2 id="4-2-字节概要"><a href="#4-2-字节概要" class="headerlink" title="4.2 字节概要"></a>4.2 字节概要</h2><p><code>python</code>内置了两个基本的二进制序列类型其中有<code>py3</code>引入的不可变<code>bytes</code>类型和<code>py2.6</code>添加的可变<code>bytesarray</code>类型</p>
<p><code>bytes</code>和<code>bytearray</code>对象的各个元素是介于<code>0~255(含)</code>之间的整数而不是<code>py2</code>的<code>str</code>对象那样的单个字符.</p>
<p>需要注意的是二进制序列的切片始终是同一类型的二进制序列</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># bytes对象可以从str对象加给定的编码方法构建</span></span><br><span class="line">cafe = <span class="built_in">bytes</span>(<span class="string">&quot;cafの&quot;</span>, encoding=<span class="string">&quot;utf_8&quot;</span>)</span><br><span class="line">print(cafe)</span><br><span class="line"></span><br><span class="line"><span class="comment"># bytes对象中的各个元素是range(256)的整数</span></span><br><span class="line">print(cafe[<span class="number">0</span>])</span><br><span class="line"><span class="comment"># bytes对象的切片依然是bytes</span></span><br><span class="line">print(cafe[:<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># bytesarray对象没有字面量语句而是以bytearray()</span></span><br><span class="line"><span class="comment"># 和字节序列字面量参数的形式显示</span></span><br><span class="line">cafe_arr = <span class="built_in">bytearray</span>(cafe)</span><br><span class="line">print(cafe_arr)</span><br><span class="line"><span class="comment"># bytearray对象的切片还是bytearray对象</span></span><br><span class="line">print(cafe_arr[-<span class="number">1</span>:])</span><br><span class="line"></span><br><span class="line">&gt;&gt;</span><br><span class="line"><span class="string">b&#x27;caf\xe3\x81\xae&#x27;</span></span><br><span class="line"><span class="number">99</span></span><br><span class="line"><span class="string">b&#x27;c&#x27;</span></span><br><span class="line"><span class="built_in">bytearray</span>(<span class="string">b&#x27;caf\xe3\x81\xae&#x27;</span>)</span><br><span class="line"><span class="built_in">bytearray</span>(<span class="string">b&#x27;\xae&#x27;</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>二进制序列本质上整数序列,但是他们的字面量表示含有ASCII文本,因此各个字节的值会有以下三种不同的方式显示 –&gt; 例如<code>b&#39;xxxxx\xx\xx\t&#39;</code></p>
</blockquote>
<ul>
<li>可打印的ASCII范围内的字节(从空格到~)使用ASCII字符本身</li>
<li>制表符 换行符 回车符和\ 使用转义序列 <code>\t</code> <code>\n</code>  <code>\r</code> <code>\\</code></li>
<li>其他字节的值,使用十六进制转义序列(<code>\x00</code>空字节)</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/20220313200437.png"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="built_in">bytes</span>.fromhex(<span class="string">&#x27;31 4b ce a9&#x27;</span>)</span><br><span class="line">print(a)</span><br><span class="line"><span class="string">b&#x27;1K\xce\xa9&#x27;</span></span><br><span class="line">31(16进制) --&gt; 49(10进制) --&gt; ASCII(1K)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">在ASCII中K代表10进制</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="4-2-1-str方法"><a href="#4-2-1-str方法" class="headerlink" title="4.2.1 str方法"></a>4.2.1 str方法</h3><p><strong>1.casefold</strong></p>
<p><code>lower()</code> 只对 ASCII 也就是 <code>&#39;A-Z&#39;</code>有效，但是其它一些语言里面存在小写的情况就没办法了。文档里面举得例子是德语中<code>&#39;ß&#39;</code>的小写是<code>&#39;ss&#39;</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&#x27;ß&#x27;</span></span><br><span class="line">s.lower() <span class="comment">#  &#x27;ß&#x27;</span></span><br><span class="line">s.casefold() <span class="comment"># &#x27;ss&#x27;</span></span><br></pre></td></tr></table></figure>

<p>汉语 &amp; 英语环境下面，继续用 <code>lower()</code>没问题；要处理其它语言且存在大小写情况的时候再用<code>casefold()</code></p>
<p><strong>2.isdecimal</strong></p>
<p>判断<code>string</code>是否是十进制, 返回<code>bool</code>空字符为<code>False</code></p>
<p><strong>3.isidentifier</strong></p>
<blockquote>
<p>Python 对各种变量、方法、函数等命名时使用的字符序列称为标识符</p>
</blockquote>
<p>检查<code>string</code>是否是<code>python</code>标识符</p>
<p>标准为:</p>
<ul>
<li><p>由 26 个英文字母大小写，0-9 ，_ 组成，不能以数字开头，且严格区分大小写</p>
</li>
<li><p>不能包含空格、@、% 以及 $ 等特殊字符，不能以系统保留关键字作为标识符一共有25 个</p>
</li>
<li><p>以下划线开头的标识符有特殊含义</p>
</li>
</ul>
<p>对应<code>keyword.iskeyword(str)</code>检查是否是<code>python</code>保留的关键字</p>
<p><strong>4.isnumeric</strong></p>
<p><code>isnumeric()</code> 方法检测字符串是否只由数字组成，数字可以是<code>Unicode</code>数字，全角数字（双字节） 罗马数字 汉字数字。指数类似 <strong>²</strong> 与分数类似 <strong>½</strong> 也属于数字。返回<code>bool</code></p>
<p><strong>5.isprintable</strong></p>
<p>判断是否是可打印字符,不可打印的有:</p>
<ul>
<li>换行符制表符等<code>\t \n</code></li>
</ul>
<p><strong>6.translate</strong></p>
<p><code>s.transelate(table)</code></p>
<p><code>table</code>用<code>str.maketrans(in-str, out-str)</code>生成<strong>用于创建字符映射的转换表</strong></p>
<p>转换表本质上整数映射</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(transtable)</span><br><span class="line"></span><br><span class="line">&#123;<span class="number">115</span>: <span class="number">109</span>, <span class="number">111</span>: <span class="number">97</span>, <span class="number">109</span>: <span class="number">110</span>, <span class="number">101</span>: <span class="number">121</span>&#125;</span><br></pre></td></tr></table></figure>

<p>以<code>table</code>作为基础替换<code>s</code>中所有命中的字符</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">&quot;i like something relaxing!&quot;</span></span><br><span class="line">in_str = <span class="string">&quot;some&quot;</span></span><br><span class="line">out_str = <span class="string">&quot;many&quot;</span></span><br><span class="line">transtable = <span class="built_in">str</span>.maketrans(in_str, out_str)</span><br><span class="line"></span><br><span class="line">print(a.translate(transtable))</span><br><span class="line">&gt;&gt;</span><br><span class="line">i liky manything rylaxing!</span><br></pre></td></tr></table></figure>

<hr>
<p><code>str</code>类型的其他方法都支持<code>bytes</code>和<code>bytearray</code>类型</p>
<p><strong>二进制序列并不是指字节序列全是二进制编码,而是指用于计算机存储和传播的二进制字节序列即字节序列,其本质上还是整数序列</strong></p>
<ul>
<li>在<code>ASCII</code>中<code>K</code>表示十进制</li>
<li><code>1k</code>表示十进制<code>1</code></li>
</ul>
<hr>
<p>构建<code>bytes</code>或<code>bytearray</code>实例还可以调用各自的构造方法,传参如下:</p>
<ul>
<li>一个<code>str</code>对象(码位)和<code>encoding</code>关键字参数(编码规则)</li>
<li>一个可迭代对象, 提供<code>0~255</code>数值</li>
<li>一个实现缓冲协议的对象<code>(bytes bytearray memoryview array.array)</code> 此时把源对象中的字节序列复制到新建的二进制序列中</li>
</ul>
<p>注意使用缓冲类对象构建二进制序列是一个底层操作,可能涉及类型转换</p>
<p><strong>下面是将<code>array.array</code>转化成字节序列表示</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> array</span><br><span class="line"><span class="comment"># 创建一个短整数16位数组</span></span><br><span class="line">numbers = array.array(<span class="string">&#x27;h&#x27;</span>, [-<span class="number">2</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line"><span class="comment"># 保存组成的numbers的字节序列副本</span></span><br><span class="line">to_bytes = <span class="built_in">bytes</span>(numbers)</span><br><span class="line"><span class="comment"># 表示5个短整数的10个字节</span></span><br><span class="line">print(to_bytes)</span><br><span class="line">&gt;&gt;</span><br><span class="line"><span class="string">b&#x27;\xfe\xff\xff\xff\x00\x00\x01\x00\x02\x00&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个空array接收bytes</span></span><br><span class="line"><span class="comment"># 并输出结构化的bytes</span></span><br><span class="line">temp_array = array.array(<span class="string">&#x27;h&#x27;</span>)</span><br><span class="line">print(temp_array.frombytes(to_bytes))</span><br><span class="line">print(temp_array)</span><br><span class="line">&gt;&gt;</span><br><span class="line"><span class="literal">None</span></span><br><span class="line">array(<span class="string">&#x27;h&#x27;</span>, [-<span class="number">2</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>])</span><br></pre></td></tr></table></figure>

<p><strong>需要注意</strong></p>
<ul>
<li><p><strong>使用缓冲类对象<code>(bytes bytearray array.array memoryview)</code>创建<code>bytes</code> <code>bytearray</code>对象时, 始终复制的是源对象中的字节序列</strong></p>
</li>
<li><p>不过<code>memoryview</code>对象允许在二进制数据结构之间共享内存</p>
</li>
<li><p>从二进制序列提取结构化信息需要<code>struct</code>模块</p>
</li>
</ul>
<h3 id="4-2-2-结构体和内存视图"><a href="#4-2-2-结构体和内存视图" class="headerlink" title="4.2.2 结构体和内存视图"></a>4.2.2 结构体和内存视图</h3><p><code>struct</code>模块提供了一些函数, 把打包的字节序列转换成不同类型字段组成的元组,还有一些函数用于执行反向转换,把元组转化成打包的字节序列.可以处理<code>bytes</code> <code>bytearray</code> <code>memoryview</code>对象</p>
<p><strong>注意</strong>:</p>
<p><code>memoryview</code>类不是用于创建或存储字节序列的, 而是共享内存,让你访问其他二进制序列 打包的数组和缓冲中的数据切片,而无需复制字节序列</p>
<p><strong>memoryview 对象的切片是一个新 memoryview 对象，而且不会复制字节序列</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="comment"># 结构体格式: &lt; 小字节序列</span></span><br><span class="line"><span class="comment">#		  3s3s 俩个3字节序列</span></span><br><span class="line"><span class="comment">#         HH   俩个16位二进制整数</span></span><br><span class="line">fmt = <span class="string">&quot;&lt;3s3sHH&quot;</span></span><br><span class="line">whith <span class="built_in">open</span>(<span class="string">&quot;filter.gif&quot;</span>, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">    <span class="comment"># 使用内存中的文件内容创建一个memoryview对象</span></span><br><span class="line">    img = <span class="built_in">memoryview</span>(fp.read())</span><br><span class="line"><span class="comment"># 使用他的切片再创建一个mv对象(这里不会复制字节序列)</span></span><br><span class="line">header = img[:<span class="number">10</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转化成字节序列(10字节)</span></span><br><span class="line"><span class="built_in">bytes</span>(header)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拆包mv对象获得一个元组包括类型 版本 宽度 高度</span></span><br><span class="line">struct.unpack(fmt, header)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除引用 释放mv实列占用的内存</span></span><br><span class="line"><span class="keyword">del</span> header</span><br><span class="line"><span class="keyword">del</span> img</span><br></pre></td></tr></table></figure>

<p>如果经常处理二进制数据推荐阅读:</p>
<p><strong><a target="_blank" rel="noopener" href="https://docs.python.org/3/library/stdtypes.html#memory-views">memoryview</a></strong></p>
<p><a target="_blank" rel="noopener" href="https://docs.python.org/3/library/struct.html"><strong>struct interpret bytes as packed binary data</strong></a></p>
<h2 id="4-3-基本的编解码器"><a href="#4-3-基本的编解码器" class="headerlink" title="4.3 基本的编解码器"></a>4.3 基本的编解码器</h2><blockquote>
<p>python自带了超过100种编解码器(编码算法)用于在文本和字节之间相互转换</p>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/496D8BAFE68A48610FC47DBC7BB2A83F.png" style="zoom:150%;" />

<p>其中后三者是可变长度的多字节编码, 其余都是单字节编码</p>
<p>图中星号表示某些编码(<code>ASCII</code>和多字节编码<code>GB2312</code>)不能表示所有的<code>Unicode</code>字符, <code>UTF</code>编码的设计目的是处理每一个<code>Unicode</code>码位</p>
<h2 id="4-4-编解码问题"><a href="#4-4-编解码问题" class="headerlink" title="4.4 编解码问题"></a>4.4 编解码问题</h2><blockquote>
<p>编解码涉及到<code>unicode</code>或者<code>string</code>或称<code>码位</code>与<code>byte</code>的编解码转换</p>
</blockquote>
<p>编解码异常有三种:</p>
<p><strong>1.UnicodeEncodeError</strong></p>
<p><code>str</code>转<code>byte</code>异常</p>
<p><strong>2.UnicodeDecodeError</strong></p>
<p><code>byte</code>转<code>str</code>异常</p>
<p><strong>3.SynatxError</strong></p>
<p>如果在编解码中,源码的编码与预期不符, 在加载模块时会抛出语法异常</p>
<h3 id="4-4-1-UnicodeEncodeError"><a href="#4-4-1-UnicodeEncodeError" class="headerlink" title="4.4.1 UnicodeEncodeError"></a>4.4.1 UnicodeEncodeError</h3><h3 id="4-4-2-UnicodeDecodeError"><a href="#4-4-2-UnicodeDecodeError" class="headerlink" title="4.4.2 UnicodeDecodeError"></a>4.4.2 UnicodeDecodeError</h3><h3 id="4-4-3-SyntaxError"><a href="#4-4-3-SyntaxError" class="headerlink" title="4.4.3 SyntaxError"></a>4.4.3 SyntaxError</h3><blockquote>
<p>多数非<code>UTF</code>编解码器只能处理<code>Unicode</code>字符的一小部分子集, 把文本转化成字节序列时, 如果目标编码中没有定义某个字符就会抛该异常, 处理方式是把<code>errors</code>参数传给编码方法或函数,对错误进行特殊处理</p>
</blockquote>
<blockquote>
<p>不是每个字节都包含有效的ASCII字符,也不是每个字符序列都是有效<code>UTF-8</code> 或<code>UTF-16</code> 因此,在把二进制序列转化成文本时, 如果假设是这俩个编码中的一个, 遇到无法转换的字节序列时会抛出UnicodeDecodeError</p>
</blockquote>
<p><strong>str.en|decode(encoding=””, errors=””)</strong></p>
<p><code>errors</code>接收四个参数</p>
<ul>
<li><p>strict: 遇到无法编码的字符raise error</p>
</li>
<li><p>ignore: 忽略不能编码的字符</p>
</li>
<li><p>replace: 使用<code>?</code>代替不能编码的字符</p>
</li>
<li><p>xmlcharrefreplace: 把无法编码的字符替换成XML实体</p>
</li>
</ul>
<p>需要注意的是errors接受的参数是可以扩展的, 你可以位errors参数注册额外的字符串方法<code>codecs.register_error</code>函数</p>
<ul>
<li>python3允许在源码中使用非ASCII标识符</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">β = <span class="number">1</span></span><br><span class="line">print(β)</span><br></pre></td></tr></table></figure>

<h3 id="4-4-4-找出字节序列编码"><a href="#4-4-4-找出字节序列编码" class="headerlink" title="4.4.4 找出字节序列编码"></a>4.4.4 找出字节序列编码</h3><blockquote>
<p>简单的说一般找不出字节序列的编码, 有些通讯协议和文件格式, 比如 HTTP和XML包含<strong>明确指明内容编码的首部</strong>. 可以肯定的是, 某些字节流不是ASCII, 因为其中包含大于127的字节值, 而且制定UTF-8和UTF-16的方式也限制了可用的字节序列.即使如此我们也无法根据特定的位模式来确定二进制文件的编码时ASCII或UTF-8</p>
</blockquote>
<p>  统一字符编码侦测包<code>Chartdetect</code>,可以识别30中编码</p>
<p>二进制序列编码通常不会指明自己的编码, 但是<code>UTF</code>格式可以在文本内容的开头添加一个字节序列标记</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> chardet</span><br><span class="line">a = chardet.detect(<span class="string">b&quot;sddssfsd&quot;</span>)</span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line">&#123;<span class="string">&#x27;encoding&#x27;</span>: <span class="string">&#x27;ascii&#x27;</span>, <span class="string">&#x27;confidence&#x27;</span>: <span class="number">1.0</span>, <span class="string">&#x27;language&#x27;</span>: <span class="string">&#x27;&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-4-5-BOM有用的鬼符"><a href="#4-4-5-BOM有用的鬼符" class="headerlink" title="4.4.5 BOM有用的鬼符"></a>4.4.5 BOM有用的鬼符</h3><blockquote>
<p>BOM (bytes-Order-Mark)字节序列标记, 指明编码时使用的是IntelGPU的小子节序</p>
</blockquote>
<ul>
<li><code>utf-16</code>有俩种编码格式<code>UTF-16LE</code>小子节序<code>UTF-6BE</code>大字节序</li>
<li>小子节序各个码位的最低有效字节在前面, 大字节序相反(Unicode码位)</li>
<li>因此在<code>utf-16</code>编码中使用开头的BOM<code>b&#39;\xff\xfe&#39;</code>十进制(255 254)表示小子节编码</li>
<li><code>utf-8</code>无论设备使用哪种字节序,生成的字节序列始终一致, 因此不需要BOM</li>
</ul>
<h2 id="4-5-处理文本文件"><a href="#4-5-处理文本文件" class="headerlink" title="4.5 处理文本文件"></a>4.5 处理文本文件</h2><p><img src="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/20220320144303.png"></p>
<p>处理文本文件最好的方式是三明治处理法, 首先将输入的字节序列转码成字符串, 在对字符串进行处理, 最后把处理好的字符串编码成字节序列进行输出</p>
<p><code>Python3</code>中的<code>Open</code>函数会在读取文本进行必要的解码, 在以文本模式写入文件时也会进行必要的编码, 所以<code>my_file.read()</code>方法得到的以及传递给<code>my_file.write(text)</code>方法的都是字符串对象</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用utf-8编码打开(创建)txt文件, 模式位写</span></span><br><span class="line"><span class="comment"># 此时使用open函数创建一个TextIowrapper对象</span></span><br><span class="line">fp = <span class="built_in">open</span>(<span class="string">&quot;text.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">print(fp)</span><br><span class="line">&lt;_io.TextIOWrapper name=<span class="string">&#x27;text.txt&#x27;</span> mode=<span class="string">&#x27;w&#x27;</span> encoding=<span class="string">&#x27;utf-8&#x27;</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将字符串对象写入TextIo对象中</span></span><br><span class="line">fp.write(<span class="string">&quot;Drink&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭TextIo对象</span></span><br><span class="line">fp.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="comment"># 调用系统stat,查看路径文件的字节大小</span></span><br><span class="line">print(os.stat(<span class="string">&quot;text.txt&quot;</span>).st_size)</span><br><span class="line"><span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开文本文件, 返回一个TextIoWrapper对象</span></span><br><span class="line"><span class="comment"># 编码是区域设置中的默认值</span></span><br><span class="line">fp2 = <span class="built_in">open</span>(<span class="string">&quot;text.txt&quot;</span>)</span><br><span class="line"><span class="comment"># TextIO对象有encoding属性, 查看所使用的编码</span></span><br><span class="line">print(fp2.encoding)</span><br><span class="line">cp936</span><br><span class="line">fp2.read()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以特定的编码方式打开文本文件流</span></span><br><span class="line">fp3 = <span class="built_in">open</span>(<span class="string">&quot;text.txt&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">fp3.read()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用open函数创建一个BytesIoWrapper对象</span></span><br><span class="line">fp4 = <span class="built_in">open</span>(<span class="string">&quot;text.txt&quot;</span>, <span class="string">&quot;rb&quot;</span>)</span><br><span class="line"><span class="comment"># 在二进制模式即字节流中返回的是BufferedReader对象</span></span><br><span class="line"><span class="comment"># 其满足buffer-protocol协议</span></span><br><span class="line">print(fp4)</span><br><span class="line">&lt;_io.BufferedReader name=<span class="string">&#x27;text.txt&#x27;</span>&gt;</span><br><span class="line">fp4.read()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>除非想要判断编码否则不要使用二进制模式打开文本文件, 即便想要查看编码类型也不要重复发明轮子, 可以使用chardet</p>
</blockquote>
<p><strong>通常不建议使用默认编码方式取处理二进制或文本流</strong></p>
<h3 id="编码默认值"><a href="#编码默认值" class="headerlink" title="编码默认值"></a>编码默认值</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> locale</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">expressions = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    locale.getpreferredencoding()</span></span><br><span class="line"><span class="string">    type(my_file)</span></span><br><span class="line"><span class="string">    sys.stdout.isatty()</span></span><br><span class="line"><span class="string">    sys.stdout.encoding</span></span><br><span class="line"><span class="string">    sys.stdin.isatty()</span></span><br><span class="line"><span class="string">    sys.stdin.encoding</span></span><br><span class="line"><span class="string">    sys.stderr.isatty()</span></span><br><span class="line"><span class="string">    sys.stderr.encoding</span></span><br><span class="line"><span class="string">    sys.getdefaultencoding()</span></span><br><span class="line"><span class="string">    sys.getfilesystemencoding()</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">my_file = <span class="built_in">open</span>(<span class="string">&#x27;dummy&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> expression <span class="keyword">in</span> expressions.split():</span><br><span class="line">    value = <span class="built_in">eval</span>(expression)</span><br><span class="line">    print(expression.rjust(<span class="number">30</span>), <span class="string">&quot;--&gt;&quot;</span>, <span class="built_in">repr</span>(value))</span><br><span class="line"></span><br><span class="line">sys.stdin.isatty()</span><br><span class="line">sys.stderr.isatty()</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">locale.getpreferredencoding() --&gt; &#x27;cp936&#x27;</span><br><span class="line">                type(my_file) --&gt; &lt;class &#x27;_io.TextIOWrapper&#x27;&gt;</span><br><span class="line">          sys.stdout.isatty() --&gt; False</span><br><span class="line">          sys.stdout.encoding --&gt; &#x27;UTF-8&#x27;</span><br><span class="line">           sys.stdin.isatty() --&gt; False</span><br><span class="line">           sys.stdin.encoding --&gt; &#x27;UTF-8&#x27;</span><br><span class="line">          sys.stderr.isatty() --&gt; False</span><br><span class="line">          sys.stderr.encoding --&gt; &#x27;UTF-8&#x27;</span><br><span class="line">     sys.getdefaultencoding() --&gt; &#x27;utf-8&#x27;</span><br><span class="line">  sys.getfilesystemencoding() --&gt; &#x27;utf-8&#x27;</span><br></pre></td></tr></table></figure>

<p><code>sys.getfilesystemencoding()</code>用于编解码文件名而非文件内容, 把字符串参数作为文件名传给<code>open()</code>函数会使用它, 如果是字节序列则直接传给<code>OS API</code></p>
<blockquote>
<p><code>locale.getprefferedencoding()</code>返回的编码即是打开文件的默认编码,同时也是重定向文件的<code>sys.stdout/stdin/stderr</code></p>
</blockquote>
<blockquote>
<p>不要依赖默认编码尤其是windows用户</p>
</blockquote>
<h2 id="4-6-规范化Unicode字符"><a href="#4-6-规范化Unicode字符" class="headerlink" title="4.6 规范化Unicode字符"></a>4.6 规范化Unicode字符</h2><blockquote>
<p>因为Unicode有组合字符(变音字符和附加到前一个字符上的记号, 打印时作为一个整体)所以字符串比较起来比较复杂</p>
</blockquote>
<p>比如<code>é</code>这个词, 是<code>e</code>后加<code>U+0301</code>得来的, 在<code>unicode</code>中称为标准等价物, 但是<code>python</code>看到的是不同的码位序列, 因此判断两者不相等, 这时就需要一个统一的标准, 来规范化<code>Unicode</code>就像规范两种方言一样</p>
<p>使用<code>unicodedata.normalize</code>函数</p>
<p>第一个参数:</p>
<ul>
<li><strong>NFC (Normalization Form C)</strong></li>
</ul>
<p>使用最少的码位构成等价的字符串</p>
<ul>
<li><strong>NFD</strong></li>
</ul>
<p>把组合字符分解成 [基字符] 和 [单独的组合字符]</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">s1 = <span class="string">&quot;café&quot;</span></span><br><span class="line">s2 = <span class="string">&quot;cafe\u3001&quot;</span></span><br><span class="line"></span><br><span class="line">print(unicodedata.normalize(<span class="string">&quot;NFC&quot;</span>, s1))</span><br><span class="line">print(unicodedata.normalize(<span class="string">&quot;NFC&quot;</span>, s2))</span><br><span class="line"></span><br><span class="line">print(unicodedata.normalize(<span class="string">&quot;NFD&quot;</span>, s1))</span><br><span class="line">print(unicodedata.normalize(<span class="string">&quot;NFD&quot;</span>, s2))</span><br><span class="line"></span><br><span class="line">café</span><br><span class="line">cafe、</span><br><span class="line">café</span><br><span class="line">cafe、</span><br></pre></td></tr></table></figure>

<blockquote>
<p>用户输入的文本默认是NFC格式, 在保存文本前, 最好使用normalization(“NFC”, text)清洗字符串</p>
<p>需要注意的是, 在使用NFC清洗字符串时, 有些单字符会被规范成另一个单字符, 比如电阻的单位Ω会被规范成欧米茄, 在视觉上是一样的, 但在比较时并不相等</p>
</blockquote>
<ul>
<li><p>NFKC</p>
</li>
<li><p>NFKD</p>
</li>
</ul>
<p><strong>这俩个规范化方法是兼容性规范化, 这些规范化更适合用在用户搜索或索引上, 需要注意的是, 经过NFKC或者NFKD兼容性规范化后的字符可能会丧失原本的意义, 尽量不要用于数据的持久化</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s3 = <span class="string">&quot;¼&quot;</span></span><br><span class="line">print(unicodedata.normalize(<span class="string">&quot;NFKC&quot;</span>, s3))</span><br><span class="line">&gt;&gt; <span class="number">1</span>/<span class="number">4</span></span><br></pre></td></tr></table></figure>

<h3 id="4-6-1-大小写折叠"><a href="#4-6-1-大小写折叠" class="headerlink" title="4.6.1 大小写折叠"></a>4.6.1 大小写折叠</h3><blockquote>
<p>即将所有的字符转化成小写, 相比于lower()只支持Unicode, casefold()支持更多的大小写转化, 尽管如此, 两者不同的字符仅有116个码位, 占比0.11%</p>
</blockquote>
<h3 id="4-6-2-规范化文本匹配实用函数"><a href="#4-6-2-规范化文本匹配实用函数" class="headerlink" title="4.6.2 规范化文本匹配实用函数"></a>4.6.2 规范化文本匹配实用函数</h3><blockquote>
<p>NFC和NFD可以很合理的比较Unicode字符串, 并且NFC是最好的规范化形式, 不区分大小写应该使用casefold()</p>
</blockquote>
<p><strong>1.去掉变音字符号</strong></p>
<blockquote>
<p>unicodedata.combining (unichr) <strong>将分配给Unicode字符 unichr 的规范组合类 返回 为整数</strong>。 如果未定义组合类，则返回 0 。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> unicodedata <span class="keyword">import</span> normalize</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shave_marks</span>(<span class="params">txt</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    去掉所有的变音符号</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 把所有的字符拆成基字符和组合记号</span></span><br><span class="line">    norm_txt = unicodedata.normalize(<span class="string">&quot;NFD&quot;</span>, txt)</span><br><span class="line">    <span class="comment"># 过滤掉所有组合记号</span></span><br><span class="line">    shaved = <span class="string">&quot;&quot;</span>.join(c <span class="keyword">for</span> c <span class="keyword">in</span> norm_txt <span class="keyword">if</span> <span class="keyword">not</span> unicodedata.combining(c))</span><br><span class="line">    <span class="comment"># 重组所有字符</span></span><br><span class="line">    <span class="keyword">return</span> unicodedata.normalize(<span class="string">&quot;NFC&quot;</span>, shaved)</span><br></pre></td></tr></table></figure>

<p><strong>2.比较字符是否相等|忽略大小写</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> unicodedata <span class="keyword">import</span> normalize</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nfc_equal</span>(<span class="params">str1, str2</span>):</span></span><br><span class="line">    <span class="keyword">return</span> normalize(<span class="string">&quot;NFC&quot;</span>, str1) == normalize(<span class="string">&quot;NFC&quot;</span>, str2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fold_equal</span>(<span class="params">str1, str2</span>):</span></span><br><span class="line">    <span class="keyword">return</span> (normalize(<span class="string">&quot;NFC&quot;</span>, str1).casefold() == </span><br><span class="line">            normalize(<span class="string">&quot;NFC&quot;</span>, str2).casefold())</span><br></pre></td></tr></table></figure>

<h2 id="4-7-Unicode文本排序"><a href="#4-7-Unicode文本排序" class="headerlink" title="4.7 Unicode文本排序"></a>4.7 Unicode文本排序</h2><blockquote>
<p>对于ASCII字符串来说比较的是码位, 但在非ASCII字符时会使用locale.strxfrm函数, 这个函数会把string转化成适合的区域进行比较</p>
</blockquote>
<p>需要注意的是, 一般情况下, 变音符不会对排序造成影响, 如果有影响, 变音符号常常排在常规词后面</p>
<p>在使用locale.strxfrm函数作为排序key前, 要先调用setlocale(LC_COLLATE, your_locale)</p>
<p>需要注意:</p>
<ol>
<li>区域设置是全局的, 不建议库中调用, 且应用或框架应该在进程中调用</li>
<li>操作系统必须支持区域设置</li>
</ol>
<p><strong>使用unicode排序算法排序</strong></p>
<p><code>pyuca</code> </p>
<blockquote>
<p>Python Unicode Collator Algorithm</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pyuca</span><br><span class="line"></span><br><span class="line">coll = pyuca.Collator()</span><br><span class="line">fruits = [<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;alle&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;bba&quot;</span>]</span><br><span class="line">sorted_fruits = <span class="built_in">sorted</span>(fruits, key=coll.sort_key)</span><br><span class="line">print(sorted_fruits)</span><br></pre></td></tr></table></figure>

<h2 id="4-8-Unicode-数据库"><a href="#4-8-Unicode-数据库" class="headerlink" title="4.8 Unicode 数据库"></a>4.8 Unicode 数据库</h2><blockquote>
<p>本质上已经一个关于unicode以及个中映射关系的数据库, 就如码位与string bytes的映射一样, 同样基于此提供了许多双模式API对外调用, 出名的有unicodedata</p>
</blockquote>
<p><strong>regex库正在替代re库</strong></p>
<p><strong>双模式API是一个趋势</strong>: 即支持字符和字节参数,并根据参数的格式做出自适应的调整</p>
<h2 id="4-9-支持str和bytes的双模式API"><a href="#4-9-支持str和bytes的双模式API" class="headerlink" title="4.9 支持str和bytes的双模式API"></a>4.9 支持str和bytes的双模式API</h2><blockquote>
<p>标准库中一些函数能接受字符串或字节序列作为参数, 然后根据类型自适应做不同的行为, 其中re和os为例</p>
</blockquote>
<h3 id="4-9-1-正则str和bytes"><a href="#4-9-1-正则str和bytes" class="headerlink" title="4.9.1 正则str和bytes"></a>4.9.1 正则str和bytes</h3><table>
<thead>
<tr>
<th></th>
<th>unicode</th>
<th>bytes</th>
<th>次数|注</th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td></td>
<td></td>
<td>{0,}</td>
</tr>
<tr>
<td>+</td>
<td></td>
<td></td>
<td>{1,}</td>
</tr>
<tr>
<td>?</td>
<td></td>
<td></td>
<td>{0,1}</td>
</tr>
<tr>
<td>\d</td>
<td>匹配任何一个十进制数字, 包括[0-9]和其他数字字符</td>
<td>只匹配[0-9]</td>
<td>和re.ASCII</td>
</tr>
<tr>
<td>\w</td>
<td>任何Unicode字符, 所有语言|数字|下横线</td>
<td>[a-zA-A0-9]</td>
<td>和re.ASCII一样</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">re_numbers_str = re.<span class="built_in">compile</span>(<span class="string">r&quot;\d+&quot;</span>)</span><br><span class="line">re_words_str = re.<span class="built_in">compile</span>(<span class="string">r&quot;\w+&quot;</span>)</span><br><span class="line"></span><br><span class="line">re_numbers_bytes = re.<span class="built_in">compile</span>(<span class="string">rb&quot;\d+&quot;</span>)</span><br><span class="line">re_words_bytes = re.<span class="built_in">compile</span>(<span class="string">rb&quot;\w+&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里会默认拼接str</span></span><br><span class="line">text_str = <span class="string">&quot;Drink see \u0be7\u0be6\u0be5\u0be4&quot;</span> <span class="string">&quot;as 1999 = 1000 + 999&quot;</span></span><br><span class="line"></span><br><span class="line">text_bytes = text_str.encode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;TEXT&quot;</span>, <span class="built_in">repr</span>(text_str), sep=<span class="string">&quot;\n &quot;</span>)</span><br><span class="line">print(<span class="string">&quot;NUMBERS&quot;</span>)</span><br><span class="line">print(<span class="string">&quot;  str  :&quot;</span>, re_numbers_str.findall(text_str))</span><br><span class="line">print(<span class="string">&quot;  bytes:&quot;</span>, re_numbers_bytes.findall(text_bytes))</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;WORDS&quot;</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;  str  :&quot;</span>, re_words_str.findall(text_str))</span><br><span class="line">print(<span class="string">&quot;  bytes:&quot;</span>, re_words_bytes.findall(text_bytes))</span><br><span class="line"></span><br><span class="line">&gt;&gt;</span><br><span class="line">TEXT</span><br><span class="line"> <span class="string">&#x27;Drink see ௧௦\u0be5\u0be4as 1999 = 1000 + 999&#x27;</span></span><br><span class="line">NUMBERS</span><br><span class="line">  <span class="built_in">str</span>  : [<span class="string">&#x27;௧௦&#x27;</span>, <span class="string">&#x27;1999&#x27;</span>, <span class="string">&#x27;1000&#x27;</span>, <span class="string">&#x27;999&#x27;</span>]</span><br><span class="line">  <span class="built_in">bytes</span>: [<span class="string">b&#x27;1999&#x27;</span>, <span class="string">b&#x27;1000&#x27;</span>, <span class="string">b&#x27;999&#x27;</span>]</span><br><span class="line">WORDS</span><br><span class="line">  <span class="built_in">str</span>  : [<span class="string">&#x27;Drink&#x27;</span>, <span class="string">&#x27;see&#x27;</span>, <span class="string">&#x27;௧௦&#x27;</span>, <span class="string">&#x27;as&#x27;</span>, <span class="string">&#x27;1999&#x27;</span>, <span class="string">&#x27;1000&#x27;</span>, <span class="string">&#x27;999&#x27;</span>]</span><br><span class="line">  <span class="built_in">bytes</span>: [<span class="string">b&#x27;Drink&#x27;</span>, <span class="string">b&#x27;see&#x27;</span>, <span class="string">b&#x27;as&#x27;</span>, <span class="string">b&#x27;1999&#x27;</span>, <span class="string">b&#x27;1000&#x27;</span>, <span class="string">b&#x27;999&#x27;</span>]</span><br></pre></td></tr></table></figure>

<h3 id="4-9-2-os中的字符串和字节序列"><a href="#4-9-2-os中的字符串和字节序列" class="headerlink" title="4.9.2 os中的字符串和字节序列"></a>4.9.2 os中的字符串和字节序列</h3><blockquote>
<p>GNU/linux内核不理解Unicode, 因此文件名中使用字节序列都是无效的</p>
</blockquote>
<p>为了方便处理字符串或字节序列形式的文件名或路径名, os模块提供了特殊的编码和解码函数</p>
<p><strong>fsencode(filename)</strong></p>
<p>当filename是str时使用<code>sys.getfilesystemencoding()</code>编码成bytes</p>
<p><strong>fsdecode(filename)</strong></p>
<p>当filename是bytes时使用<code>sys.getfilesystemencoding()</code>解码成str</p>
<blockquote>
<p>在unix及其衍生平台中使用<code>surrogateescape</code>错误处理方式, 避免碰到意外字节卡住, windows使用strict, 这种处理方式在py3.1时被引进</p>
</blockquote>
<p>这种错误的处理方式实际上是将无法编码的字节替换成<code>Unicode</code>中<code>U+DC00</code>到<code>U+DCFF</code>之间的码位<code>(low surrogate area)</code>, 这些码位是保留的,没有分配字符, 只供程序内部使用</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://drinkle.top/2022/02/06/%E6%B5%81%E7%95%85%E7%9A%84python/" data-id="ckzb823ai0000ngf5h2vdfe6t" data-title="流畅的python" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/" rel="tag">Python</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2022/02/22/python%E9%9D%A2%E8%AF%95%E9%A2%98/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">前一篇</strong>
      <div class="article-nav-title">
        
          python面试题
        
      </div>
    </a>
  
  
    <a href="/2021/11/14/%E7%BB%8F%E6%B5%8E%E5%88%86%E6%9E%90-1/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">后一篇</strong>
      <div class="article-nav-title">经济分析[1]</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/825%E8%AE%A1%E5%88%92/" rel="tag">825计划</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Algorithm/" rel="tag">Algorithm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/BuiltIn/" rel="tag">BuiltIn</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Daily-Plan/" rel="tag">Daily Plan</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Data-Structure/" rel="tag">Data Structure</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DataBase/" rel="tag">DataBase</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Drink/" rel="tag">Drink</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/English-Study/" rel="tag">English Study</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GoodNotes/" rel="tag">GoodNotes</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hexo/" rel="tag">Hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LeeCode/" rel="tag">LeeCode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mongodb/" rel="tag">Mongodb</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Object-Oriented/" rel="tag">Object Oriented</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Postgraduate/" rel="tag">Postgraduate</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/" rel="tag">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python%E5%90%8E%E7%AB%AF/" rel="tag">Python后端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spirit/" rel="tag">Spirit</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/consciousness/" rel="tag">consciousness</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/django/" rel="tag">django</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/source-code/" rel="tag">source-code</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%96%E7%95%8C%E8%A7%82/" rel="tag">世界观</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%96%E7%95%8C%E8%A7%82-%E6%96%B9%E6%B3%95%E8%AE%BA/" rel="tag">世界观 方法论</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AE%9E%E8%B7%B5/" rel="tag">实践</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B7%A6%E7%BF%BC%E5%90%8C%E7%9B%9F%E4%BC%9A/" rel="tag">左翼同盟会</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%96%B0%E9%97%BB%E8%81%94%E6%92%AD/" rel="tag">新闻联播</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%8B%AC%E5%88%B0%E7%A7%91%E6%8A%80/" rel="tag">独到科技</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%87%B4%E4%BD%A0%E7%9A%84%E4%B8%80%E5%B0%81%E4%BF%A1/" rel="tag">致你的一封信</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/825%E8%AE%A1%E5%88%92/" style="font-size: 13.33px;">825计划</a> <a href="/tags/Algorithm/" style="font-size: 10px;">Algorithm</a> <a href="/tags/BuiltIn/" style="font-size: 10px;">BuiltIn</a> <a href="/tags/Daily-Plan/" style="font-size: 10px;">Daily Plan</a> <a href="/tags/Data-Structure/" style="font-size: 10px;">Data Structure</a> <a href="/tags/DataBase/" style="font-size: 10px;">DataBase</a> <a href="/tags/Drink/" style="font-size: 13.33px;">Drink</a> <a href="/tags/English-Study/" style="font-size: 20px;">English Study</a> <a href="/tags/GoodNotes/" style="font-size: 10px;">GoodNotes</a> <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/LeeCode/" style="font-size: 10px;">LeeCode</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/Mongodb/" style="font-size: 10px;">Mongodb</a> <a href="/tags/MySQL/" style="font-size: 10px;">MySQL</a> <a href="/tags/Object-Oriented/" style="font-size: 10px;">Object Oriented</a> <a href="/tags/Postgraduate/" style="font-size: 10px;">Postgraduate</a> <a href="/tags/Python/" style="font-size: 16.67px;">Python</a> <a href="/tags/Python%E5%90%8E%E7%AB%AF/" style="font-size: 10px;">Python后端</a> <a href="/tags/Spirit/" style="font-size: 10px;">Spirit</a> <a href="/tags/consciousness/" style="font-size: 10px;">consciousness</a> <a href="/tags/django/" style="font-size: 10px;">django</a> <a href="/tags/source-code/" style="font-size: 10px;">source-code</a> <a href="/tags/%E4%B8%96%E7%95%8C%E8%A7%82/" style="font-size: 13.33px;">世界观</a> <a href="/tags/%E4%B8%96%E7%95%8C%E8%A7%82-%E6%96%B9%E6%B3%95%E8%AE%BA/" style="font-size: 10px;">世界观 方法论</a> <a href="/tags/%E5%AE%9E%E8%B7%B5/" style="font-size: 10px;">实践</a> <a href="/tags/%E5%B7%A6%E7%BF%BC%E5%90%8C%E7%9B%9F%E4%BC%9A/" style="font-size: 10px;">左翼同盟会</a> <a href="/tags/%E6%96%B0%E9%97%BB%E8%81%94%E6%92%AD/" style="font-size: 10px;">新闻联播</a> <a href="/tags/%E7%8B%AC%E5%88%B0%E7%A7%91%E6%8A%80/" style="font-size: 10px;">独到科技</a> <a href="/tags/%E8%87%B4%E4%BD%A0%E7%9A%84%E4%B8%80%E5%B0%81%E4%BF%A1/" style="font-size: 10px;">致你的一封信</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">二月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">十一月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">十月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">九月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">八月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">七月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">六月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">五月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">四月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">三月 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/02/22/python%E9%9D%A2%E8%AF%95%E9%A2%98/">python面试题</a>
          </li>
        
          <li>
            <a href="/2022/02/06/%E6%B5%81%E7%95%85%E7%9A%84python/">流畅的python</a>
          </li>
        
          <li>
            <a href="/2021/11/14/%E7%BB%8F%E6%B5%8E%E5%88%86%E6%9E%90-1/">经济分析[1]</a>
          </li>
        
          <li>
            <a href="/2021/11/14/%E6%96%B0%E9%97%BB%E8%81%94%E6%92%AD-2/">新闻联播[2]</a>
          </li>
        
          <li>
            <a href="/2021/10/07/Question/">Question</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 Drink<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>