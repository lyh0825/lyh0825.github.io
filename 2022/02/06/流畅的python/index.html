<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>流畅的python | Drink`s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="Part0.BulitIn小知识处理大数据 如果是类 -&gt; 减少内存使用__slots__ 如果是数值类型 使用Numpy array memoryview  为什么说repr是开发者模式的str因为eval(repr(obj)) –&gt; obj 如果class中有self.__attr私有变量, 则无法通过eval(repr(obj))获取obj 1234567def repr(obj">
<meta property="og:type" content="article">
<meta property="og:title" content="流畅的python">
<meta property="og:url" content="https://drinkle.top/2022/02/06/%E6%B5%81%E7%95%85%E7%9A%84python/index.html">
<meta property="og:site_name" content="Drink&#96;s Blog">
<meta property="og:description" content="Part0.BulitIn小知识处理大数据 如果是类 -&gt; 减少内存使用__slots__ 如果是数值类型 使用Numpy array memoryview  为什么说repr是开发者模式的str因为eval(repr(obj)) –&gt; obj 如果class中有self.__attr私有变量, 则无法通过eval(repr(obj))获取obj 1234567def repr(obj">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/20220410215740.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/20220410220525.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/add_mul_operator.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/memoryview">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/20220303231533.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/fluent_python_dict_set">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/dict01.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/dict02">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/dict03.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/dict04">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/338FE41118E025DEC0F08E62E79242FB.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/04AFD0F1F67F70C8B753E15D433EBB86.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/9074D4974B2971BC1FA4BFBE2710A364.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/6D3B0816875580AF04759FD9538975E0.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/56D97AD7F6AB7ADC76CFDFC71D3CF306.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/20220312164711.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/20220313165653.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/20220313200437.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/496D8BAFE68A48610FC47DBC7BB2A83F.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/20220320144303.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/20220405202516.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/20220405203145.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/lyh0825/Drink@master/PicGo/20220411202433.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/lyh0825/Drink@master/PicGo/20220417193527.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/lyh0825/Drink@master/PicGo/20220419165520.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/lyh0825/Drink@master/PicGo/20220419170013.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/lyh0825/Drink@master/PicGo/20220419191131.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/lyh0825/Drink@master/PicGo/20220422190720.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/20220423222901.png">
<meta property="article:published_time" content="2022-02-06T10:02:01.000Z">
<meta property="article:modified_time" content="2022-05-08T14:20:30.565Z">
<meta property="article:author" content="Drink">
<meta property="article:tag" content="Python">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/20220410215740.png">
  
    <link rel="alternate" href="/atom.xml" title="Drink`s Blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Drink`s Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://drinkle.top"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-流畅的python" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/02/06/%E6%B5%81%E7%95%85%E7%9A%84python/" class="article-date">
  <time class="dt-published" datetime="2022-02-06T10:02:01.000Z" itemprop="datePublished">2022-02-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      流畅的python
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Part0-BulitIn"><a href="#Part0-BulitIn" class="headerlink" title="Part0.BulitIn"></a>Part0.BulitIn</h1><h2 id="小知识"><a href="#小知识" class="headerlink" title="小知识"></a>小知识</h2><h3 id="处理大数据"><a href="#处理大数据" class="headerlink" title="处理大数据"></a>处理大数据</h3><ol>
<li>如果是类 <code>-&gt;</code> 减少内存使用<code>__slots__</code></li>
<li>如果是数值类型 使用<code>Numpy</code> <code>array</code> <code>memoryview</code></li>
</ol>
<h3 id="为什么说repr是开发者模式的str"><a href="#为什么说repr是开发者模式的str" class="headerlink" title="为什么说repr是开发者模式的str"></a>为什么说repr是开发者模式的str</h3><p>因为<code>eval(repr(obj))</code> –&gt; <code>obj</code></p>
<p><strong>如果class中有<code>self.__attr</code>私有变量, 则无法通过<code>eval(repr(obj))</code>获取obj</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">repr</span>(<span class="params">obj</span>):</span> <span class="comment"># real signature unknown; restored from __doc__</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Return the canonical string representation of the object.</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    For many object types, including most builtins, eval(repr(obj)) == obj.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<h3 id="self-cls"><a href="#self-cls" class="headerlink" title="self|cls"></a>self|cls</h3><p><code>python</code>中<code>cls</code>代表的是类的本身，相对应的self则是类的一个实例对象。</p>
<p>因为<code>cls</code>等同于类本身，类方法中可以通过使用cls来实例化一个对象。</p>
<p><code>cls</code>通常于<code>@classmethod</code>搭配使用用于实例化类对象</p>
<h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>python的反射，它的核心本质其实就是<strong>利用字符串的形式去对象（模块）中操作（查找/获取/删除/添加）成员</strong>，一种基于字符串的事件驱动！</p>
<h3 id="林奈结构"><a href="#林奈结构" class="headerlink" title="林奈结构"></a><strong>林奈结构</strong></h3><p>没有采用一贯的下行二分法体系（系统）而是采用在一个界<code>（kingdom）</code>之内只含有四个阶元层次：<strong>纲（class），目（order），属（genus），种（species）</strong>的等级结构的体系。</p>
<h3 id="帮助"><a href="#帮助" class="headerlink" title="帮助"></a>帮助</h3><p><strong>想知道某个类或者函数有方法以及其例子时, 可以使用dir()或者help()</strong></p>
<p>比如想了解<code>pandas.read_excel</code>如何读取其<code>title</code>和<code>data</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">file = pd.read_excel(<span class="string">&quot;./students.xls&quot;</span>)</span><br><span class="line">columns = <span class="built_in">list</span>(file.columns)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> data <span class="keyword">in</span> file.values:</span><br><span class="line">    print(data)</span><br><span class="line">&gt;&gt;</span><br><span class="line">[<span class="string">&#x27;Star&#x27;</span> <span class="number">46599201</span> <span class="number">85</span> <span class="number">20</span>]</span><br><span class="line">[<span class="string">&#x27;Drink&#x27;</span> <span class="number">36784554</span> <span class="number">90</span> <span class="number">21</span>]</span><br><span class="line">[<span class="string">&#x27;Fire&#x27;</span> <span class="number">12492483</span> <span class="number">96</span> <span class="number">23</span>]</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/20220410215740.png"></p>
<p><strong>想了解一个函数或者对象要做什么事情可以使用<code>__annotation__ </code>  <code>__doc__</code>  <code>inspect.signature</code></strong></p>
<p><strong>annotation</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#x27;dtype&#x27;: &#x27;DtypeArg | None&#x27;, &#x27;storage_options&#x27;: &#x27;StorageOptions&#x27;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>doc</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/20220410220525.png"></p>
<p><strong>signature</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(io, sheet_name=0, header=0, names=None, index_col=None, usecols=None, squeeze=False, dtype: &#x27;DtypeArg | None&#x27; = None, engine=None, converters=None, true_values=None, false_values=None, skiprows=None, nrows=None, na_values=None, keep_default_na=True, na_filter=True, verbose=False, parse_dates=False, date_parser=None, thousands=None, comment=None, skipfooter=0, convert_float=None, mangle_dupe_cols=True, storage_options: &#x27;StorageOptions&#x27; = None)</span><br></pre></td></tr></table></figure>

<h3 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h3><table>
<thead>
<tr>
<th>模式</th>
<th>例子</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>单前导</td>
<td><code>_var</code></td>
<td>命名约定, 内部私有变量, 解释器不强制执行, 除<code>import *</code> 外</td>
</tr>
<tr>
<td>单末尾</td>
<td><code>var_</code></td>
<td>命名约定, 避免与关键字冲突</td>
</tr>
<tr>
<td>双前导</td>
<td><code>__var</code></td>
<td>类的上下位中使用, 名称修饰为<code>_class__var</code>避免属性被意外修改</td>
</tr>
<tr>
<td>双前导|双末尾</td>
<td><code>__var__</code></td>
<td><code>magic method</code></td>
</tr>
<tr>
<td>单下划</td>
<td><code>_</code></td>
<td>占位符</td>
</tr>
</tbody></table>
<h3 id="format"><a href="#format" class="headerlink" title="format"></a>format</h3><table>
<thead>
<tr>
<th align="left">数字</th>
<th align="left">格式</th>
<th align="center">输出</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">3.1415926</td>
<td align="left">{:.2f}</td>
<td align="center">3.14</td>
<td align="left">保留小数点后两位</td>
</tr>
<tr>
<td align="left">3.1415926</td>
<td align="left">{:+.2f}</td>
<td align="center">+3.14</td>
<td align="left">带符号保留小数点后两位</td>
</tr>
<tr>
<td align="left">-1</td>
<td align="left">{:+.2f}</td>
<td align="center">-1.00</td>
<td align="left">带符号保留小数点后两位</td>
</tr>
<tr>
<td align="left">2.71828</td>
<td align="left">{:.0f}</td>
<td align="center">3</td>
<td align="left">不带小数</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">{:0&gt;2d}</td>
<td align="center">05</td>
<td align="left">数字补零 (填充左边, 宽度为2)</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">{:x&lt;4d}</td>
<td align="center">5xxx</td>
<td align="left">数字补x (填充右边, 宽度为4)</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left">{:x&lt;4d}</td>
<td align="center">10xx</td>
<td align="left">数字补x (填充右边, 宽度为4)</td>
</tr>
<tr>
<td align="left">1000000</td>
<td align="left">{:,}</td>
<td align="center">1,000,000</td>
<td align="left">以逗号分隔的数字格式</td>
</tr>
<tr>
<td align="left">0.25</td>
<td align="left">{:.2%}</td>
<td align="center">25.00%</td>
<td align="left">百分比格式</td>
</tr>
<tr>
<td align="left">1000000000</td>
<td align="left">{:.2e}</td>
<td align="center">1.00e+09</td>
<td align="left">指数记法</td>
</tr>
<tr>
<td align="left">13</td>
<td align="left">{:&gt;10d}</td>
<td align="center">13</td>
<td align="left">右对齐 (默认, 宽度为10)</td>
</tr>
<tr>
<td align="left">13</td>
<td align="left">{:&lt;10d}</td>
<td align="center">13</td>
<td align="left">左对齐 (宽度为10)</td>
</tr>
<tr>
<td align="left">13</td>
<td align="left">{:^10d}</td>
<td align="center">13</td>
<td align="left">中间对齐 (宽度为10)</td>
</tr>
<tr>
<td align="left">11</td>
<td align="left"><code>&#39;&#123;:b&#125;&#39;.format(11) &#39;&#123;:d&#125;&#39;.format(11) &#39;&#123;:o&#125;&#39;.format(11) &#39;&#123;:x&#125;&#39;.format(11) &#39;&#123;:#x&#125;&#39;.format(11) &#39;&#123;:#X&#125;&#39;.format(11)</code></td>
<td align="center"><code>1011 11 13 b 0xb 0XB</code></td>
<td align="left">进制</td>
</tr>
</tbody></table>
<p><strong>^</strong>, <strong>&lt;**, **&gt;</strong> 分别是居中、左对齐、右对齐，后面带宽度， <strong>:</strong> <strong>号后面带填充的字符</strong>，**只能是一个字符[即只能填充一次]**，不指定则默认是用空格填充。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 即长度为多少</span></span><br><span class="line"><span class="built_in">str</span> = <span class="string">&quot;1&#123;:15&#125;&quot;</span>.<span class="built_in">format</span>(<span class="string">&quot;&amp;&quot;</span>)</span><br><span class="line">print(string_1, <span class="built_in">len</span>(<span class="built_in">str</span>))</span><br><span class="line">|<span class="number">1</span>&amp;               |</span><br><span class="line"><span class="number">16</span></span><br></pre></td></tr></table></figure>

<p><strong>+</strong> 表示在正数前显示 **+**，负数前显示 **-**； （空格）表示在正数前加空格</p>
<p>b、d、o、x 分别是二进制、十进制、八进制、十六进制。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># &#123;&#125; format</span></span><br><span class="line"><span class="comment"># &#123;0&#125; format the index</span></span><br><span class="line"><span class="comment"># &#123;0:2d&#125; format the type --&gt; d int 2d: remain two int</span></span><br><span class="line"><span class="comment"># &#123;&lt;2d&#125; 左对齐，宽度为2d，不足补空格</span></span><br><span class="line">ROW_FMT = <span class="string">&quot;&#123;0:2d&#125;  @ &#123;1:2d&#125;   &#123;2&#125; &#123;0:&lt;2d&#125;&quot;</span></span><br><span class="line">print(ROW_FMT.<span class="built_in">format</span>(needle, posotion, offset))</span><br></pre></td></tr></table></figure>

<h2 id="Dis常用字节码"><a href="#Dis常用字节码" class="headerlink" title="Dis常用字节码"></a>Dis常用字节码</h2><table>
<thead>
<tr>
<th>Name</th>
<th>args</th>
<th>Info</th>
</tr>
</thead>
<tbody><tr>
<td><strong>LOAD_GLOBAL</strong></td>
<td><em>namei</em></td>
<td>加载名称为 <code>co_names[namei]</code> 的全局对象推入栈顶。</td>
</tr>
<tr>
<td><strong>LOAD_FAST</strong></td>
<td><em>var_num</em></td>
<td>将指向局部对象 <code>co_varnames[var_num]</code> 的引用推入栈顶。</td>
</tr>
<tr>
<td><strong>LOAD_CONST</strong></td>
<td>consti</td>
<td>将 <code>co_consts[consti]</code> 推入栈顶。</td>
</tr>
<tr>
<td><strong>CALL_FUNCTION</strong></td>
<td><em>argc</em></td>
<td>调用一个可调用对象并传入位置参数。 <em>argc</em> 指明位置参数的数量。 栈顶包含位置参数，其中最右边的参数在最顶端。 在参数之下是一个待调用的可调用对象。 <code>CALL_FUNCTION</code> 会从栈中弹出所有参数以及可调用对象，附带这些参数调用该可调用对象，并将可调用对象所返回的返回值推入栈顶。<em>在 3.6 版更改:</em> 此操作码仅用于附带位置参数的调用。</td>
</tr>
<tr>
<td><strong>POP_TOP</strong></td>
<td></td>
<td>删除堆栈顶部（TOS）项</td>
</tr>
<tr>
<td><strong>STORE_FAST</strong></td>
<td><em>var_num</em></td>
<td>将 TOS 存放到局部对象 <code>co_varnames[var_num]</code>。</td>
</tr>
<tr>
<td><strong>RETURN_VALUE</strong></td>
<td></td>
<td>返回 TOS 到函数的调用者。</td>
</tr>
</tbody></table>
<h2 id="Attention"><a href="#Attention" class="headerlink" title="Attention"></a>Attention</h2><h3 id="函数-方法返回"><a href="#函数-方法返回" class="headerlink" title="函数|方法返回"></a>函数|方法返回</h3><p>python 会对operation返回return None来表示对对象的就地更改, 即不会id(obj)不会变</p>
<ul>
<li>用返回None来表示就地改动有一个弊端, 即调用者无法将其串联起来; 而返回一个新对象的方法(比如说str里的所有方法)则正好相反, 他们可以串联起来调用</li>
</ul>
<h3 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h3><p>sort分为两种， 一种是value sort即根据值进行排序， 另一种是time sort即就算两个元素比不出大小， 但在每次排序的结果里他们的相对位置是固定的</p>
<h3 id="推导式"><a href="#推导式" class="headerlink" title="推导式"></a>推导式</h3><ul>
<li>一般推导式的作用 <code>[]</code> <code>&#123;&#125;</code><ul>
<li>创建新的数据对象</li>
<li>过滤作用</li>
</ul>
</li>
</ul>
<h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><h3 id="1-python中list和array的区别"><a href="#1-python中list和array的区别" class="headerlink" title="1.python中list和array的区别"></a>1.python中list和array的区别</h3><ul>
<li>list是python的内置数据类型</li>
<li>list中的数据类不必相同的</li>
<li>array的中的类型必须全部相同</li>
<li>在list中的数据类型保存的是数据存放的地址，简单的说就是指针，并非数据</li>
<li>这种保存方式增加了存储和CPU的消耗例如list1=[1,2,3,’a’]需要4个指针和四个数据</li>
<li>数组在背后存的并不是float对象，而是数字的机器翻译，也就是字节表述。这一点和c语言中的数组一样</li>
<li>array创建的数组不适用于数字操作（比如矩阵和矢量运算）。另外+=和*=运算符可以用于array的添加。</li>
<li>从python3.4开始，数组（array）类型不再支持诸如list.sort()这种就地排序方法。要给数组排序的话，得用sorted函数新建一个数组：</li>
</ul>
<h2 id="Magic-Method"><a href="#Magic-Method" class="headerlink" title="Magic Method"></a>Magic Method</h2><p><strong>表1:跟运算符无关的 magic method</strong></p>
<table>
<thead>
<tr>
<th align="center">类别</th>
<th align="center">方法名</th>
</tr>
</thead>
<tbody><tr>
<td align="center">字符串/字节序列表示形式</td>
<td align="center">repr str format bytes</td>
</tr>
<tr>
<td align="center">数值转换</td>
<td align="center">abs bool complex int float hash index</td>
</tr>
<tr>
<td align="center">集合模拟</td>
<td align="center">len getitem setitem delitem contains</td>
</tr>
<tr>
<td align="center">迭代枚举</td>
<td align="center">iter reversed next</td>
</tr>
<tr>
<td align="center">可调用模拟</td>
<td align="center">call</td>
</tr>
<tr>
<td align="center">上下文管理</td>
<td align="center">enter exit</td>
</tr>
<tr>
<td align="center">实例创建/销毁</td>
<td align="center">new init del</td>
</tr>
<tr>
<td align="center">属性管理</td>
<td align="center">getattr getattribute setattr delattr dir</td>
</tr>
<tr>
<td align="center">属性描述符</td>
<td align="center">get set delete</td>
</tr>
<tr>
<td align="center">跟类有关的服务</td>
<td align="center">prepare instancecheck subclasscheck</td>
</tr>
</tbody></table>
<p><strong>表2:跟运算符相关的 magic method</strong></p>
<table>
<thead>
<tr>
<th align="center">类别</th>
<th align="center">方法名和对应的运算符</th>
</tr>
</thead>
<tbody><tr>
<td align="center">一元运算符</td>
<td align="center">neg - pos + abs abs()</td>
</tr>
<tr>
<td align="center">众多比较运算符</td>
<td align="center">lt &lt; le &lt;= eq == ne != gt &gt; ge &gt;=</td>
</tr>
<tr>
<td align="center">算术运算符</td>
<td align="center">add + sub - mul * truediv / floordiv // mod % divmod divmod() pow **|pow() round round()</td>
</tr>
<tr>
<td align="center">反向算术运算符</td>
<td align="center">radd rsub rmul rturediv rfloordiv rmod rdivmod  rpow</td>
</tr>
<tr>
<td align="center">增量赋值算术运算符</td>
<td align="center">iadd isub imul itruediv ifloordic imod ipow</td>
</tr>
<tr>
<td align="center">位运算符</td>
<td align="center">invert ~ lshift &lt;&lt; rshift &gt;&gt; and &amp; or | xor ^</td>
</tr>
<tr>
<td align="center">反向位运算符</td>
<td align="center">rlshift rrshift rand rxor ror</td>
</tr>
<tr>
<td align="center">增量赋值位运算符</td>
<td align="center">ilshift irshift iand ixor ior</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注: 以下所有的keyword默认为 self.__xx__():</span><br></pre></td></tr></table></figure>

<h3 id="bool-len"><a href="#bool-len" class="headerlink" title="bool|len"></a>bool|len</h3><p>默认情况下我们定义的类的实例总是被认为<code>True</code>,除非在<code>define class</code>中有实现<code>bool或者len</code></p>
<p><code>bool()</code>的背后其实是调用<code>x.__bool__()</code>的结果;如果<code>x.__bool__()</code>不存在, 则调用<code>len()</code>即<code>x.__len__()</code>,如果为<code>0-False other-True</code></p>
<p>调用优先级为<code>bool &gt; len</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># define a class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">temp</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.value = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    !<span class="function"><span class="keyword">def</span> <span class="title">__bool__</span>(<span class="params">self</span>):</span></span><br><span class="line">    !   <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">&gt;</span><br><span class="line"><span class="built_in">bool</span>(temp) <span class="literal">False</span></span><br><span class="line">? bool(temp) True</span><br></pre></td></tr></table></figure>



<h3 id="and-mul"><a href="#and-mul" class="headerlink" title="and|mul"></a>and|mul</h3><p><code>and --&gt; +  add</code></p>
<p><code>mul --&gt; *  multiple</code></p>
<h3 id="str-repr"><a href="#str-repr" class="headerlink" title="str|repr"></a>str|repr</h3><p>两者的却别在于<code>str will called by str() and print(), repr can only called by print()</code></p>
<p>如果两者特殊方法保留一个<code>repr</code>会是更好的选择, 因为在没有<code>str</code>时, 解释器会调用<code>repr</code></p>
<p>优先级<code>str &gt; repr </code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># define a class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">temp</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.value = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;repr value is <span class="subst">&#123;self.value&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;str value is <span class="subst">&#123;self.value&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">test = temp()</span><br><span class="line">print(test)</span><br><span class="line"></span><br><span class="line">H:\Python\python.exe H:/MY_TXM/test.py</span><br><span class="line"><span class="built_in">str</span> value <span class="keyword">is</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="Moudle"><a href="#Moudle" class="headerlink" title="Moudle"></a>Moudle</h2><h3 id="functools"><a href="#functools" class="headerlink" title="functools"></a>functools</h3><h4 id="recude"><a href="#recude" class="headerlink" title="recude"></a>recude</h4><p>对参数序列中元素进行累积。</p>
<p>函数将一个数据集合（链表，元组等）中的所有数据进行下列操作：用传给 reduce 中的函数 function（有两个参数）先对集合中的第 1、2 个元素进行操作，得到的结果再与第三个数据用 function 函数运算，最后得到一个结果。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sum2 = reduce(<span class="keyword">lambda</span> x, y: x+y, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line">&gt;&gt;</span><br><span class="line"><span class="number">15</span> = <span class="number">1</span> + <span class="number">2</span> + <span class="number">3</span> + <span class="number">4</span> + <span class="number">5</span></span><br></pre></td></tr></table></figure>

<h3 id="os"><a href="#os" class="headerlink" title="os"></a>os</h3><h4 id="listdir"><a href="#listdir" class="headerlink" title="listdir"></a>listdir</h4><blockquote>
<p>列出目录下的所有文件和文件夹不包括<code>.</code> <code>..</code>隐藏目录</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">print(os.listdir(<span class="string">&quot;H:\MY_TXM&quot;</span>))</span><br><span class="line">&gt;&gt;</span><br><span class="line">[<span class="string">&#x27;.git&#x27;</span>, <span class="string">&#x27;.gitignore&#x27;</span>, <span class="string">&#x27;.idea&#x27;</span>, <span class="string">&#x27;static&#x27;</span>, <span class="string">&#x27;venv&#x27;</span>]</span><br></pre></td></tr></table></figure>

<h4 id="locale"><a href="#locale" class="headerlink" title="locale"></a>locale</h4><blockquote>
<p>locale 是根据计算机用户所使用的语言，所在国家或者地区，以及当地的文化传统所定义的一个软件运行时的语言环境。通常情况下它可以按照涉及使用习惯分为12大类:</p>
</blockquote>
<ul>
<li>语言符号及其分类（LC_CTYPE)</li>
<li>数字（LC_NUMBERIC）</li>
<li>比较习惯（LC_COLLATE)</li>
<li>时间显示格式（LC_TIME）</li>
<li>货币单位（LC_MONETARY)</li>
<li>信息主要是提示信息，错误信息，状态信息，标题，标签，按钮和菜单等（LC_MESSAGES）</li>
<li>行么书写方式（LC_NAME）</li>
<li>地址书写方式（LC_ADDRESS）</li>
<li>电话号码书写方式（LC_TELEPHONE）<br>-度量衡表达方式（LC_MEASUREMENT）</li>
<li>默认纸张尺寸大小（LC_PAPER）</li>
<li>对locale 自身包含信息的概述（LC_IDENTIFICATION）</li>
<li>除此之外还有一个LANGUAGE参数，它与LC_MESSAGES相似</li>
</ul>
<h3 id="time"><a href="#time" class="headerlink" title="time"></a>time</h3><h4 id="time-1"><a href="#time-1" class="headerlink" title="time"></a>time</h4><h4 id="process-time"><a href="#process-time" class="headerlink" title="process_time"></a>process_time</h4><h4 id="process-time-ns"><a href="#process-time-ns" class="headerlink" title="process_time_ns"></a>process_time_ns</h4><h4 id="perf-counter"><a href="#perf-counter" class="headerlink" title="perf_counter"></a>perf_counter</h4><h4 id="perf-counter-ns"><a href="#perf-counter-ns" class="headerlink" title="perf_counter_ns"></a>perf_counter_ns</h4><p><code>time()</code>精度上相对没有那么高，而且受系统的影响，适合表示日期时间或者大程序程序的计时。</p>
<p><code>perf_counter()</code>适合小一点的程序测试，会计算<code>sleep()</code>时间。</p>
<p><code>process_counter()</code>适合小一点的程序测试，不会计算<code>sleep()</code>时间。</p>
<p>此外<code>Python3.7</code>开始还提供了以上三个方法精确到<code>纳秒</code>的计时。分别是：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">time.perf_counter_ns()</span><br><span class="line">time.process_time_ns()</span><br><span class="line">time.time_ns()</span><br></pre></td></tr></table></figure>

<h3 id="arrary"><a href="#arrary" class="headerlink" title="arrary"></a>arrary</h3><p>数组所接受的typecode以及其对应的存储数据类型</p>
<table>
<thead>
<tr>
<th align="left">Type code</th>
<th align="left">C Type</th>
<th align="left">Python Type</th>
<th align="left">Minimum size in bytes</th>
<th align="left">Notes</th>
</tr>
</thead>
<tbody><tr>
<td align="left">‘b’</td>
<td align="left">signed char</td>
<td align="left">int</td>
<td align="left">1</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">‘B’</td>
<td align="left">unsigned char</td>
<td align="left">int</td>
<td align="left">1</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">‘u’</td>
<td align="left">Py_UNICODE</td>
<td align="left">Unicode character</td>
<td align="left">2</td>
<td align="left">(1)</td>
</tr>
<tr>
<td align="left">‘h’</td>
<td align="left">signed short</td>
<td align="left">int</td>
<td align="left">2</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">‘H’</td>
<td align="left">unsigned short</td>
<td align="left">int</td>
<td align="left">2</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">‘i’</td>
<td align="left">signed int    int</td>
<td align="left">2</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">‘I’</td>
<td align="left">unsigned int</td>
<td align="left">int</td>
<td align="left">2</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">‘l’</td>
<td align="left">signed long</td>
<td align="left">int</td>
<td align="left">4</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">‘L’</td>
<td align="left">unsigned long</td>
<td align="left">int</td>
<td align="left">4</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">‘q’</td>
<td align="left">signed long long    int</td>
<td align="left">8</td>
<td align="left">(2)</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">‘Q’</td>
<td align="left">unsigned long long</td>
<td align="left">int</td>
<td align="left">8</td>
<td align="left">(2)</td>
</tr>
<tr>
<td align="left">‘f’</td>
<td align="left">float</td>
<td align="left">float</td>
<td align="left">4</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">‘d’</td>
<td align="left">double</td>
<td align="left">float</td>
<td align="left">8</td>
<td align="left"></td>
</tr>
</tbody></table>
<h3 id="bisect"><a href="#bisect" class="headerlink" title="bisect"></a>bisect</h3><p>bisect是一个根据二分算法写的库，其中主要的俩个方法是bisect和insert，根本上根据二分算法算出有序序列的索引，可以当做快速定位index使用</p>
<h4 id="bisect-bisect-left"><a href="#bisect-bisect-left" class="headerlink" title="bisect|bisect_left"></a>bisect|bisect_left</h4><p>接受一个有序序列，一个元素，返回该元素在有序序列的索引，索引以前全≤该元素，<code>bisect(bisect_right)|bisect_left</code>主要区别是如果俩对比元素相等，前者返回index是从右边插入，后者左边</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> bisect</span><br><span class="line">temp_sequence = [<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">index = bisect.bisect(temp_sequence, <span class="number">2</span>)</span><br><span class="line">_index = bisect.bisect_left(temp_sequence, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">print(index)</span><br><span class="line">print(_index)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<h4 id="insort"><a href="#insort" class="headerlink" title="insort"></a>insort</h4><p>根据bisect或者bisect_left返回的index进行插入，接受有序序列，返回有序序列</p>
<h3 id="itertools"><a href="#itertools" class="headerlink" title="itertools"></a>itertools</h3><h4 id="groupby"><a href="#groupby" class="headerlink" title="groupby"></a>groupby</h4><p>和<code>nlargest() nsmallest()</code>一样支持<code>key=</code></p>
<p>【聚合】</p>
<p>有时候我们需要给一个<code>sequence</code>按照某个属性分组，可以借助groupby来实现,groupby常常和<code>lambda map operator.itemgetter</code>一起使用，因为在分组前，大多希望相关的数据聚集在一起， 这样对于groupby来说分组才有意义</p>
<p>语法：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">groupby(seqence, key)</span><br><span class="line">args:</span><br><span class="line">    sequence must iterable</span><br><span class="line">    key sort the sequence 聚合</span><br><span class="line">return iterator contains key, data --&gt; type tuple</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ol>
<li>如果groupby中的key=None，那么group后的key是被group中的element， 如果key=fun那么group后的key是fun(element)</li>
<li>返回的数据<ul>
<li>type(key) type(element) </li>
<li>type(data) iterator</li>
</ul>
</li>
</ol>
<p>实列：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">a = [&#123;<span class="string">&#x27;severity&#x27;</span>: <span class="string">&#x27;严重&#x27;</span>&#125;, &#123;<span class="string">&#x27;severity&#x27;</span>: <span class="string">&#x27;严重&#x27;</span>&#125;, &#123;<span class="string">&#x27;severity&#x27;</span>: <span class="string">&#x27;不严重&#x27;</span>&#125;, &#123;<span class="string">&#x27;severity&#x27;</span>: <span class="string">&#x27;严重&#x27;</span>&#125;]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果不将数据进行排序直接group</span></span><br><span class="line"><span class="keyword">for</span> key, data <span class="keyword">in</span> groupby(a):</span><br><span class="line">    print(key, <span class="built_in">list</span>(data))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将会输出三组key</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&#123;&#x27;severity&#x27;: &#x27;严重&#x27;&#125; [&#123;&#x27;severity&#x27;: &#x27;严重&#x27;&#125;, &#123;&#x27;severity&#x27;: &#x27;严重&#x27;&#125;]</span></span><br><span class="line"><span class="string">&#123;&#x27;severity&#x27;: &#x27;不严重&#x27;&#125; [&#123;&#x27;severity&#x27;: &#x27;不严重&#x27;&#125;]</span></span><br><span class="line"><span class="string">&#123;&#x27;severity&#x27;: &#x27;严重&#x27;&#125; [&#123;&#x27;severity&#x27;: &#x27;严重&#x27;&#125;]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对数据进行聚合(排序)但不对group的key进行筛选</span></span><br><span class="line">a.sort(key=itemgetter(<span class="string">&quot;severity&quot;</span>))</span><br><span class="line"><span class="keyword">for</span> key, data <span class="keyword">in</span> groupby(a):</span><br><span class="line">    print(key, <span class="built_in">list</span>(data))</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 此时的key时a中的单个element</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&#123;&#x27;severity&#x27;: &#x27;不严重&#x27;&#125; [&#123;&#x27;severity&#x27;: &#x27;不严重&#x27;&#125;]</span></span><br><span class="line"><span class="string">&#123;&#x27;severity&#x27;: &#x27;严重&#x27;&#125; [&#123;&#x27;severity&#x27;: &#x27;严重&#x27;&#125;, &#123;&#x27;severity&#x27;: &#x27;严重&#x27;&#125;, &#123;&#x27;severity&#x27;: &#x27;严重&#x27;&#125;]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对数据进行聚合(排序)且对group的key进行筛选</span></span><br><span class="line">a.sort(key=itemgetter(<span class="string">&quot;severity&quot;</span>))</span><br><span class="line"><span class="keyword">for</span> key, data <span class="keyword">in</span> groupby(a, key=itemgetter(<span class="string">&quot;severity&quot;</span>)):</span><br><span class="line">    print(key, <span class="built_in">list</span>(data))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时的group返回的key是经过滤后的key</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">不严重 [&#123;&#x27;severity&#x27;: &#x27;不严重&#x27;&#125;]</span></span><br><span class="line"><span class="string">严重 [&#123;&#x27;severity&#x27;: &#x27;严重&#x27;&#125;, &#123;&#x27;severity&#x27;: &#x27;严重&#x27;&#125;, &#123;&#x27;severity&#x27;: &#x27;严重&#x27;&#125;]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="operator"><a href="#operator" class="headerlink" title="operator"></a>operator</h3><h4 id="itemgetter"><a href="#itemgetter" class="headerlink" title="itemgetter"></a>itemgetter</h4><blockquote>
<p>使用[]运算符, 不仅支持序列还支持映射和任何实现了<code>__getitem__</code>方法的类</p>
</blockquote>
<p>operator模块提供的itemgetter函数主要用于获取某一对象 <strong>特定维度的数据，</strong>其中的参数为特定维度的索引</p>
<p>operator.itemgetter函数获取的并不是某一个数值，而是<strong>某一个函数</strong>常常可以使用<code>lambda </code>函数替换</p>
<p>用法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">itemgetter(var)</span><br><span class="line">args:</span><br><span class="line">    var can accept index <span class="keyword">and</span> key</span><br><span class="line"><span class="keyword">return</span> fun()</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import operator</span><br><span class="line"></span><br><span class="line">a = [&#123;&quot;age&quot;: 10, &quot;socre&quot;: 90&#125;, &#123;&quot;age&quot;: 9, &quot;socre&quot;: 98&#125;, &#123;&quot;age&quot;: 0, &quot;socre&quot;: 50&#125;, &#123;&quot;age&quot;: 15, &quot;socre&quot;: 56&#125;]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 定义一个获取维度数据的函数</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取sequence的index=0&amp;1的数据</span></span><br><span class="line">condition = operator.itemgetter(0, 1)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将sequence传入获取函数中</span></span><br><span class="line">res = condition(a)</span><br><span class="line">print(res, type(a))</span><br><span class="line">(&#123;&#x27;age&#x27;: 10, &#x27;socre&#x27;: 90&#125;, &#123;&#x27;age&#x27;: 9, &#x27;socre&#x27;: 98&#125;) &lt;class &#x27;tuple&#x27;&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 对a的age进行排序</span></span><br><span class="line">a.sort(key=itemgetter(&quot;age&quot;))</span><br><span class="line">a.sort(key=lambda x: x[&quot;socre&quot;], reverse=True)</span><br><span class="line">print(a)</span><br><span class="line">[&#123;&#x27;age&#x27;: 0, &#x27;socre&#x27;: 50&#125;, &#123;&#x27;age&#x27;: 9, &#x27;socre&#x27;: 98&#125;, &#123;&#x27;age&#x27;: 10, &#x27;socre&#x27;: 90&#125;, &#123;&#x27;age&#x27;: 15, &#x27;socre&#x27;: 56&#125;]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 先对age排序在对score排序</span></span><br><span class="line">a.sort(key=itemgetter(&quot;age&quot;, &quot;socre&quot;), reverse=True)</span><br></pre></td></tr></table></figure>

<h3 id="headq"><a href="#headq" class="headerlink" title="headq"></a>headq</h3><h4 id="nlargest"><a href="#nlargest" class="headerlink" title="nlargest"></a>nlargest</h4><h4 id="nsmallest"><a href="#nsmallest" class="headerlink" title="nsmallest"></a>nsmallest</h4><p>和<code>groupby()</code>一样支持<code>key=</code></p>
<p> 介绍：</p>
<p>这两个函数可以帮助我们在某个集合中找出最大或最小的N个元素</p>
<p>语法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nlargest</span>(<span class="params">n, iterable, key=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Find the n largest elements in a dataset.</span></span><br><span class="line"><span class="string">    Equivalent to:  sorted(iterable, key=key, reverse=True)[:n]</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="random"><a href="#random" class="headerlink" title="random"></a>random</h3><ul>
<li>注意如果在random.method之前使用了seed，那么random.method每次都将按照一定规则返回相同的数值</li>
</ul>
<h4 id="shuffle"><a href="#shuffle" class="headerlink" title="shuffle"></a>shuffle</h4><p>语法:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">random.shuffle(iterable)</span><br><span class="line">args:</span><br><span class="line">    iterbale a <span class="built_in">list</span> <span class="keyword">or</span> <span class="built_in">tuple</span> (sequence)</span><br><span class="line"><span class="keyword">return</span>:</span><br><span class="line">	the origin sequence but the position of element is random ==&gt; None</span><br></pre></td></tr></table></figure>

<p>实列:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">print(a, <span class="built_in">id</span>(a))</span><br><span class="line"></span><br><span class="line"><span class="comment"># operation in ori return None</span></span><br><span class="line">random.shuffle(a)</span><br><span class="line"></span><br><span class="line">print(a, <span class="built_in">id</span>(a))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>] <span class="number">2200356865544</span></span><br><span class="line"><span class="literal">None</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>] <span class="number">2200356865544</span></span><br></pre></td></tr></table></figure>

<h4 id="seed"><a href="#seed" class="headerlink" title="seed"></a>seed</h4><p>调用 <code>random.random()|shuffle </code>生成随机数时，每一次生成的数都是随机的。<br>但是，当使用<code> random.seed(x)</code> 设定好种子之后，其中的 <code>x </code>可以是任意数字，这个时候，先调用<code>seed</code>的情况下，使用 <code>random() </code>生成的随机数将会是同一个</p>
<h4 id="randrange"><a href="#randrange" class="headerlink" title="randrange"></a>randrange</h4><p>从指定范围内，按指定基数递增的集合中 获取一个随机数。</p>
<p><code>random.randrange([start], stop[, step])</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 结果相当于从[10, 12, 14, 16, … 96, 98]序列中获取一个随机数。</span></span><br><span class="line">random.randrange(<span class="number">10</span>, <span class="number">100</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<h4 id="sample"><a href="#sample" class="headerlink" title="sample"></a>sample</h4><p><code>random.sample</code>的函数原型为：<code>random.sample(sequence, k)</code>从指定序列中随机获取指定长度的片断。sample函数不会修改原有序列。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">temp = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line">print(temp, <span class="built_in">id</span>(temp))</span><br><span class="line">random_choice = random.sample(temp, <span class="number">3</span>)</span><br><span class="line">print(random_choice, <span class="built_in">id</span>(random_choice))</span><br><span class="line">print(<span class="built_in">id</span>(temp))</span><br><span class="line"></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>] <span class="number">2483596469896</span></span><br><span class="line">[<span class="number">7</span>, <span class="number">8</span>, <span class="number">3</span>] <span class="number">2483594327944</span></span><br><span class="line"><span class="number">2483596469896</span></span><br></pre></td></tr></table></figure>

<h3 id="dis"><a href="#dis" class="headerlink" title="dis"></a>dis</h3><h4 id="dis-dis"><a href="#dis-dis" class="headerlink" title="dis.dis"></a>dis.dis</h4><p>Python代码在执行的时候，会被编译为Python字节码，再由Python虚拟机执行Python字节码。有时候就我们执行python文件的时候会生成一个pyc文件，这个pyc文件即用于存储Python字节码指令，而这些字节码是一种类似于汇编指令的中间语言，但是每个字节码对应的不是机器指令，而是一段C代码。</p>
<p>而dis模块，就是用于查看这些字节码的运行轨迹，因此我们可以用dis模块判断两个函数的内存占用谁会更大，谁会更消耗CPU性能，不仅如此，通过指令，我们还可以知道Python中一些内置函数、变量的取值过程、运行逻辑，对于我们代码性能并优化代码很有帮助。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> dis</span><br><span class="line">dis.dis(<span class="string">&quot;ori_tuple[index] += mutable_sequence&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="number">1</span>           <span class="number">0</span> LOAD_NAME                <span class="number">0</span> (ori_tuple)</span><br><span class="line">              <span class="number">2</span> LOAD_NAME                <span class="number">1</span> (index)</span><br><span class="line">              <span class="number">4</span> DUP_TOP_TWO</span><br><span class="line">              <span class="number">6</span>             <span class="comment"># 实现 TOS = TOS1[TOS] </span></span><br><span class="line">              <span class="number">8</span> LOAD_NAME                <span class="number">2</span> (mutable_sequence)</span><br><span class="line">             <span class="number">10</span> INPLACE_ADD</span><br><span class="line">             <span class="number">12</span> ROT_THREE</span><br><span class="line">             <span class="number">14</span> STORE_SUBSCR</span><br><span class="line">             <span class="number">16</span> LOAD_CONST               <span class="number">0</span> (<span class="literal">None</span>)</span><br><span class="line">             <span class="number">18</span> RETURN_VALUE</span><br></pre></td></tr></table></figure>

<p>字节码操作:</p>
<ul>
<li><p>假设</p>
<ul>
<li>ori_tuple = (1, 2,  [10, 20])</li>
<li>index = 2</li>
<li>mutable_sequence = [30, 40]</li>
</ul>
</li>
<li><p>6 BINARY_SUBSCR 将 <code>ori_tuple[index]</code>的值存入<code>TOS</code>(Top Of Stack)</p>
</li>
<li><p>10 INPLACE_ADD 计算<code>ori_tuple[index] += mutable_sequence</code>, 这一步骤可以完成, 是因为<code>TOS</code>指向的是一个可变对象</p>
</li>
<li><p>14 STORE_SUBSCR 赋值, 这一步骤失败, 是因为tuple属于不可变序列(immutable)</p>
</li>
</ul>
<hr>
<p>我们从这个操作中可以得到三个教训:</p>
<ol>
<li>不要把可变对象放在元组中</li>
<li>增量赋值(+=)不是一个原子操作, 在计算完后的赋值阶段如果抛出异常, 计算仍然会完成</li>
</ol>
<p>譬如:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">b = (1, 2, [10, 20])</span><br><span class="line">b += [30, 40]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;input&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">TypeError: can only concatenate tuple (not &quot;list&quot;) to tuple</span><br><span class="line">print(b)</span><br><span class="line">(1, 2, [10, 20])</span><br></pre></td></tr></table></figure>

<p><strong>在上述实列中, 即使在最后的赋值阶段tuple抛出异常, 但是此时tuple的数据依然发生了改变!</strong></p>
<table>
<thead>
<tr>
<th align="center">Python字节码 name(variable)</th>
<th>执行操作</th>
</tr>
</thead>
<tbody><tr>
<td align="center">LOAD_NAME</td>
<td>将与 <code>co_names[namei]</code> 相关联的值推入栈顶。</td>
</tr>
<tr>
<td align="center">DUP_TOP_TWO</td>
<td>复制堆栈顶部的两个引用，使它们保持相同的顺序。</td>
</tr>
<tr>
<td align="center">BINARY_SUBSCR</td>
<td>实现 <code>TOS = TOS1[TOS]</code> 。</td>
</tr>
<tr>
<td align="center">INPLACE_ADD</td>
<td>就地实现 <code>TOS = TOS1 + TOS</code> 。</td>
</tr>
<tr>
<td align="center">ROT_THREE</td>
<td>将第二个和第三个堆栈项向上提升一个位置，顶项移动到位置三。</td>
</tr>
<tr>
<td align="center">STORE_SUBSCR</td>
<td>实现 <code>TOS1[TOS] = TOS2</code> 。</td>
</tr>
<tr>
<td align="center">LOAD_CONST</td>
<td>将 <code>co_consts[consti]</code> 推入栈顶</td>
</tr>
<tr>
<td align="center">RETURN_VALUE</td>
<td>返回 TOS 到函数的调用者。</td>
</tr>
</tbody></table>
<ul>
<li>引用<a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/dis.html">dis — Python 字节码反汇编器 — Python 3.10.2 文档</a></li>
</ul>
<h3 id="sys"><a href="#sys" class="headerlink" title="sys"></a>sys</h3><h4 id="getsizeof"><a href="#getsizeof" class="headerlink" title="getsizeof"></a>getsizeof</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">getsizeof(object, default) -&gt; int</span><br><span class="line">Return the size of <span class="built_in">object</span> <span class="keyword">in</span> <span class="built_in">bytes</span>.</span><br></pre></td></tr></table></figure>

<p>获取对象所消耗的内存大小</p>
<h4 id="argv"><a href="#argv" class="headerlink" title="argv"></a>argv</h4><p>是一个从程序外部获取参数的桥梁，从外部取得的参数可以是多个，所以获得的是一个列表（list)，也就是说sys.argv其实可以看作是一个列表，所以才能用[]提取其中的元素。其第一个元素是程序本身，随后才依次是外部给予的参数。</p>
<h3 id="memoryview"><a href="#memoryview" class="headerlink" title="memoryview"></a>memoryview</h3><p>memoryview**[内存视图]<strong>是一个内置类, 它能让用户在不复制内容的情况下操作同一个数组的不同切片,其实内存试图时泛化和去数学化的</strong>numpy数组**,它允许你在不复制内容的前提下,在数据结构之间共享内存, 其中数据结构可以是任何形式,这个功能在处理大型数据集合的时候十分重要</p>
<p>memoryview 语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">memoryview(obj)</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li>obj – 对象</li>
</ul>
<p>返回元组列表(物理地址)。</p>
<h4 id="cast"><a href="#cast" class="headerlink" title=".cast"></a>.cast</h4><p><strong>memoryview.cast</strong>的概念和数组模型差不多,能用不同的方式读写同一块内存地址,而且内容字节不会随意移动,和C语言中类型转换的概念相似.cast会把同一块内存里的内容打包成一个全新的memoryview对象给你</p>
<h2 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h2><h3 id="all-any"><a href="#all-any" class="headerlink" title="all|any"></a>all|any</h3><p>都接受一个可迭代对象, 其中all是当可迭代对象中的元素都是True时返回True, any是有一个为True时则返回True</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">d = <span class="built_in">all</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: x &gt; <span class="number">10</span>, [<span class="number">1</span>, <span class="number">10</span>, <span class="number">11</span>]))</span><br><span class="line">print(d)</span><br><span class="line">f = <span class="built_in">any</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: x &gt; <span class="number">10</span>, [<span class="number">1</span>, <span class="number">10</span>, <span class="number">11</span>]))</span><br><span class="line">print(f)</span><br><span class="line">&gt;&gt;</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h3 id="eval"><a href="#eval" class="headerlink" title="eval"></a>eval</h3><p><strong>描述</strong></p>
<p>eval() 函数用来执行一个字符串表达式，并返回表达式的值。</p>
<p><strong>语法</strong></p>
<p>以下是 eval() 方法的语法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eval(expression[, globals[, locals]])</span><br></pre></td></tr></table></figure>

<p><strong>参数</strong></p>
<ul>
<li>expression – 表达式。</li>
<li>globals – 变量作用域，全局命名空间，如果被提供，则必须是一个字典对象。</li>
<li>locals – 变量作用域，局部命名空间，如果被提供，可以是任何映射对象。</li>
</ul>
<p><strong>返回值</strong></p>
<p>返回表达式计算结果。</p>
<h3 id="isatty"><a href="#isatty" class="headerlink" title="isatty"></a>isatty</h3><blockquote>
<p><strong>isatty()</strong> 方法检测文件是否连接到一个终端设备，如果是返回 True，否则返回 False。</p>
</blockquote>
<p><strong>语法</strong></p>
<p>isatty() 方法语法如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fileObject.isatty()</span><br></pre></td></tr></table></figure>

<h3 id="assert"><a href="#assert" class="headerlink" title="assert"></a>assert</h3><blockquote>
<p>python断言和try-except用法相反</p>
</blockquote>
<p>断言函数是对表达式布尔值的判断，要求表达式计算值必须为真。可用于自动调试。</p>
<p>如果表达式为假，触发异常；如果表达式为真，不执行任何操作。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span> condition</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> condition:</span><br><span class="line">    <span class="keyword">raise</span> AssertionError()</span><br></pre></td></tr></table></figure>

<h3 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a>reverse</h3><h3 id="reversed"><a href="#reversed" class="headerlink" title="reversed"></a>reversed</h3><ol>
<li><code>s.reverse()</code>就地排序, <code>id(s)</code>不变</li>
<li><code>reversed(s)</code>返回<code>s</code>的<strong>倒序迭代器</strong></li>
</ol>
<h3 id="id"><a href="#id" class="headerlink" title="id"></a>id</h3><p>返回对象的物理存储地址, 一般用作操作符是或否创建了一个新对象, 比较两个对象的物理地址是否相同使用<code>is</code></p>
<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>提供的函数对指定序列做映射。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>(function, iterable, ...)</span><br></pre></td></tr></table></figure>

<h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p><strong>filter()</strong> 函数用于过滤序列，过滤掉不符合条件的元素，返回由符合条件元素组成的新列表。</p>
<p><em>Python2.7 返回列表，Python3.x 返回迭代器对象</em></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">filter</span>(function, iterable)</span><br><span class="line"><span class="comment"># 通常和map函数一起使用</span></span><br></pre></td></tr></table></figure>

<p>Python2.x 中返回的是过滤后的列表, 而 Python3 中返回到是一个 filter 类。</p>
<p>filter 类实现了 <strong>iter</strong> 和 <strong>next</strong> 方法, 可以看成是一个迭代器, 有惰性运算的特性, 相对 Python2.x 提升了性能, 节约内存。</p>
<h3 id="abs-fabs-math"><a href="#abs-fabs-math" class="headerlink" title="abs|fabs[math]"></a>abs|fabs[math]</h3><p><code>Python</code> 中<code> fabs(x)</code> 方法返回 <code>x</code> 的绝对值。虽然类似于 <code>abs()</code> 函数，但是两个函数之间存在以下差异：</p>
<ul>
<li><p><code>abs()</code> 是一个内置函数，而 <code>fabs()</code> 在 <code>math</code> 模块中定义的。</p>
</li>
<li><p><code>fabs()</code> 函数只适用于 <code>float</code> 和 <code>integer</code> 类型，而 <code>abs()</code> 也适用于复数。</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line">a = -<span class="number">1</span></span><br><span class="line">b = -<span class="number">1.3232</span></span><br><span class="line">c = b</span><br><span class="line">d = <span class="number">1</span> + <span class="number">1.0j</span></span><br><span class="line">e = <span class="number">3</span> + <span class="number">4.0j</span></span><br><span class="line">print(<span class="string">&quot;a的绝对值是:&quot;</span>, <span class="built_in">abs</span>(a))</span><br><span class="line">print(<span class="string">&quot;b的绝对值是:&quot;</span>, <span class="built_in">abs</span>(b))</span><br><span class="line">print(<span class="string">&quot;c的绝对值是:&quot;</span>, math.fabs(c))</span><br><span class="line">print(<span class="string">&quot;d的的绝对值是:&quot;</span>, <span class="built_in">abs</span>(d))</span><br><span class="line">print(<span class="string">&quot;e的绝对值是:&quot;</span>, math.fabs(e))</span><br><span class="line"></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;H:/MY_TXM/test.py&quot;</span>, line <span class="number">80</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    print(<span class="string">&quot;e的绝对值是:&quot;</span>,math.fabs(e))</span><br><span class="line">TypeError: can<span class="string">&#x27;t convert complex to float</span></span><br></pre></td></tr></table></figure>

<h3 id="hypot-math"><a href="#hypot-math" class="headerlink" title="hypot[math]"></a>hypot[math]</h3><p><strong>hypot()</strong> 返回欧几里德范数 <code>sqrt(x*x + y*y)</code></p>
<p><code>hypot()</code>是不能直接访问的，需要导入 <code>math</code> 模块，然后通过 <code>math </code>静态对象调用该方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line">a = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入直角三角形的一条直角边长：&quot;</span>))</span><br><span class="line">b = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入直角三角形的另一条直角边长：&quot;</span>))</span><br><span class="line">print(<span class="string">&quot;该直角三角形的斜边长为: &quot;</span>,  <span class="built_in">int</span>(math.hypot(a, b)))</span><br><span class="line">print(<span class="string">&quot;Done&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="bool"><a href="#bool" class="headerlink" title="bool"></a>bool</h3><p><strong>bool()</strong> 函数用于将给定参数转换为布尔类型，如果没有参数，返回 <code>False</code>用于判断真假</p>
<p><code>bool </code>是 <code>int</code> 的子类。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">issubclass</span>(<span class="built_in">bool</span>, <span class="built_in">int</span>)  <span class="comment"># bool 是 int 子类</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h3 id="issubclass"><a href="#issubclass" class="headerlink" title="issubclass"></a>issubclass</h3><p><code>issubclass(class, classinfo) --&gt; return True|False</code></p>
<p><strong>issubclass()</strong> 方法用于判断参数 <code>class </code>是否是类型参数<code>classinfo</code>的子类</p>
<h1 id="Part1-DataModel"><a href="#Part1-DataModel" class="headerlink" title="Part1.DataModel"></a>Part1.DataModel</h1><h2 id="1-具名元组"><a href="#1-具名元组" class="headerlink" title="1.具名元组"></a>1.具名元组</h2><p>Python元组的升级版本 – namedtuple(具名元组)</p>
<p>因为元组的局限性：不能为元组内部的数据进行命名，所以往往我们并不知道一个元组所要表达的意义，所以在这里引入了 collections.namedtuple 这个工厂函数，来构造一个带字段名的元组。具名元组的实例和普通元组消耗的内存一样多，因为字段名都被存在对应的类里面。这个类跟普通的对象实例比起来也要小一些，因为 Python 不会用 <strong>dict</strong> 来存放这些实例的属性。</p>
<p>namedtuple 对象的定义如以下格式：</p>
<p><code>collections.namedtuple(typename, field_names, verbose=False, rename=False)</code><br>返回一个具名元组子类 typename，其中参数的意义如下：</p>
<ul>
<li>typename：元组名称</li>
<li>field_names: 元组中元素的名称</li>
<li>rename: 如果元素名称中含有 python 的关键字，则必须设置为 rename=True</li>
<li>verbose: 默认就好</li>
</ul>
<p>下面来看看声明一个具名元组及其实例化的方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line">两种方法来给 namedtuple 定义方法名</span><br><span class="line">User = collections.namedtuple(<span class="string">&#x27;User&#x27;</span>, [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;id&#x27;</span>])</span><br><span class="line">User = collections.namedtuple(<span class="string">&#x27;User&#x27;</span>, <span class="string">&#x27;name age id&#x27;</span>)</span><br><span class="line">user = User(<span class="string">&#x27;tester&#x27;</span>, <span class="string">&#x27;22&#x27;</span>, <span class="string">&#x27;464643123&#x27;</span>)</span><br><span class="line"></span><br><span class="line">print(user)</span><br><span class="line">collections.namedtuple(<span class="string">&#x27;User&#x27;</span>, <span class="string">&#x27;name age id&#x27;</span>) 创建一个具名元组，需要两个参数，一个是类名，另一个是类的各个字段名。后者可以是有多个字符串组成的可迭代对象，或者是有空格分隔开的字段名组成的字符串（比如本示例）。具名元组可以通过字段名或者位置来获取一个字段的信息。</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line"></span><br><span class="line">User(name=<span class="string">&#x27;tester&#x27;</span>, age=<span class="string">&#x27;22&#x27;</span>, <span class="built_in">id</span>=<span class="string">&#x27;464643123&#x27;</span>)</span><br><span class="line">具名元组的特有属性:</span><br><span class="line"></span><br><span class="line">类属性 _fields：包含这个类所有字段名的元组 类方法 _make(iterable)：接受一个可迭代对象来生产这个类的实例 实例方法 _asdict()：把具名元组以 collections.OrdereDict 的形式返回，可以利用它来把元组里的信息友好的展示出来</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个namedtuple类型User，并包含name，sex和age属性。</span></span><br><span class="line">User = namedtuple(<span class="string">&#x27;User&#x27;</span>, [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;sex&#x27;</span>, <span class="string">&#x27;age&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个User对象</span></span><br><span class="line">user = User(name=<span class="string">&#x27;Runoob&#x27;</span>, sex=<span class="string">&#x27;male&#x27;</span>, age=<span class="number">12</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取所有字段名</span></span><br><span class="line">print( user._fields )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以通过一个list来创建一个User对象，这里注意需要使用&quot;_make&quot;方法</span></span><br><span class="line">user = User._make([<span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;male&#x27;</span>, <span class="number">12</span>])</span><br><span class="line"></span><br><span class="line">print( user )</span><br><span class="line"><span class="comment"># User(name=&#x27;user1&#x27;, sex=&#x27;male&#x27;, age=12)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取用户的属性</span></span><br><span class="line">print( user.name )</span><br><span class="line">print( user.sex )</span><br><span class="line">print( user.age )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改对象属性，注意要使用&quot;_replace&quot;方法</span></span><br><span class="line">user = user._replace(age=<span class="number">22</span>)</span><br><span class="line">print( user )</span><br><span class="line"><span class="comment"># User(name=&#x27;user1&#x27;, sex=&#x27;male&#x27;, age=21)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将User对象转换成字典，注意要使用&quot;_asdict&quot;</span></span><br><span class="line">print( user._asdict() )</span><br><span class="line"><span class="comment"># OrderedDict([(&#x27;name&#x27;, &#x27;Runoob&#x27;), (&#x27;sex&#x27;, &#x27;male&#x27;), (&#x27;age&#x27;, 22)])</span></span><br><span class="line">以上实例输出结果为：</span><br><span class="line"></span><br><span class="line">(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;sex&#x27;</span>, <span class="string">&#x27;age&#x27;</span>)</span><br><span class="line">User(name=<span class="string">&#x27;Runoob&#x27;</span>, sex=<span class="string">&#x27;male&#x27;</span>, age=<span class="number">12</span>)</span><br><span class="line">Runoob</span><br><span class="line">male</span><br><span class="line"><span class="number">12</span></span><br><span class="line">User(name=<span class="string">&#x27;Runoob&#x27;</span>, sex=<span class="string">&#x27;male&#x27;</span>, age=<span class="number">22</span>)</span><br><span class="line">OrderedDict([(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;Runoob&#x27;</span>), (<span class="string">&#x27;sex&#x27;</span>, <span class="string">&#x27;male&#x27;</span>), (<span class="string">&#x27;age&#x27;</span>, <span class="number">22</span>)])</span><br></pre></td></tr></table></figure>

<h2 id="2-列表表达式"><a href="#2-列表表达式" class="headerlink" title="2.列表表达式"></a>2.列表表达式</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 两者相等</span></span><br><span class="line">print([(i, j) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>) <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">11</span>, <span class="number">20</span>)])</span><br><span class="line">res = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">11</span>, <span class="number">20</span>):</span><br><span class="line">        res.append((i, j))</span><br><span class="line">print(res)</span><br><span class="line"></span><br><span class="line"><span class="comment"># essential</span></span><br><span class="line">fun() <span class="keyword">for</span>-<span class="keyword">in</span>-loop_1 <span class="keyword">for</span>-<span class="keyword">in</span>-loop_2</span><br><span class="line">&lt;==&gt;</span><br><span class="line"><span class="keyword">for</span>-<span class="keyword">in</span>-loop_1:</span><br><span class="line">    <span class="keyword">for</span>-<span class="keyword">in</span>-loop_2:</span><br><span class="line">        fun()</span><br></pre></td></tr></table></figure>

<h2 id="3-random-choice"><a href="#3-random-choice" class="headerlink" title="3.random choice"></a>3.random choice</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> choice</span><br><span class="line">choice(obj) -&gt; obj: can iterable</span><br><span class="line">==&gt; this module can choice a random element from obj</span><br></pre></td></tr></table></figure>

<h2 id="4-Magic-Method"><a href="#4-Magic-Method" class="headerlink" title="4.Magic Method"></a>4.Magic Method</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">obj[key]</span><br><span class="line">本质上调用的是__getitem__</span><br><span class="line"></span><br><span class="line">magic method 又称为 dunder method 及双下滑线魔法方法</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>-<span class="keyword">in</span>-loop</span><br><span class="line">==&gt; __contains__ 迭代通常是隐式的</span><br><span class="line"></span><br><span class="line">obj[key]   --&gt;  self.__getitem__</span><br><span class="line"></span><br><span class="line">迭代通常是隐式的,如果一个集合类型没有实现slef.__contains__,</span><br><span class="line">那么<span class="keyword">in</span>运算符就会按照顺序做一次迭代搜索</span><br><span class="line"></span><br><span class="line">len(obj)   --&gt;   self.__len__</span><br><span class="line">注意如果obj是python内置的类型比如（<span class="built_in">list</span>、<span class="built_in">str</span>、bytearry）等Cpython会抄个近路，__len__实际上会直接返回PyVarObject的self.ob_size这个属性，而不是执行self.__len__这个方法</span><br><span class="line"></span><br><span class="line">for item in x:   --&gt;  self.__iter__</span><br><span class="line">x 必须是可迭代的</span><br></pre></td></tr></table></figure>

<h2 id="5-迭代器与生成器"><a href="#5-迭代器与生成器" class="headerlink" title="5.迭代器与生成器"></a>5.迭代器与生成器</h2><h3 id="5-1迭代器"><a href="#5-1迭代器" class="headerlink" title="5.1迭代器"></a>5.1迭代器</h3><p>迭代是Python最强大的功能之一，是访问集合元素的一种方式。</p>
<p>迭代器是一个可以记住遍历的位置的对象。</p>
<p>迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。</p>
<p>迭代器有两个基本的方法：<strong>iter()</strong> 和 **next()**。</p>
<p>字符串，列表或元组对象都可用于创建迭代器：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">it = <span class="built_in">iter</span>(<span class="built_in">list</span>)    <span class="comment"># 创建迭代器对象</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">next</span>(it))   <span class="comment"># 输出迭代器的下一个元素</span></span><br><span class="line">&gt;<span class="number">1</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">next</span>(it))</span><br><span class="line">&gt;<span class="number">2</span></span><br></pre></td></tr></table></figure>

<p><strong>迭代器对象可以使用常规for语句进行遍历</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">list</span>=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">it = <span class="built_in">iter</span>(<span class="built_in">list</span>)    <span class="comment"># 创建迭代器对象</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> it:</span><br><span class="line">    <span class="built_in">print</span> (x, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">    </span><br><span class="line">&gt; <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p><strong>也可以使用 next() 函数：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> sys         <span class="comment"># 引入 sys 模块</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">list</span>=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">it = <span class="built_in">iter</span>(<span class="built_in">list</span>)    <span class="comment"># 创建迭代器对象</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">print</span> (<span class="built_in">next</span>(it))</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        sys.exit()</span><br></pre></td></tr></table></figure>

<h3 id="5-2创建一个迭代器"><a href="#5-2创建一个迭代器" class="headerlink" title="5.2创建一个迭代器"></a>5.2创建一个迭代器</h3><p>把一个类作为一个迭代器使用需要在类中实现两个方法 <strong>iter</strong>() 与 <strong>next</strong>() </p>
<p>在定义类的时候都有一个构造函数，Python 的构造函数为 <strong>init</strong>(), 它会在对象初始化的时候执行。</p>
<p><strong>iter</strong>() 方法返回一个特殊的<strong>迭代器对象</strong>， 这个迭代器对象实现了 <strong>next</strong>() 方法并通过 <strong>StopIteration</strong> 异常标识迭代的完成。</p>
<p><strong>next</strong>() 方法（Python 2 里是 next()）会返回下一个迭代器对象。</p>
<p>创建一个返回数字的迭代器，初始值为 1，逐步递增 1：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Numbers</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    抽象一个迭代器对象，初始属性【value=0每次next自增1，并通过【value&gt;20】来rais StopInteration</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.value = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 注意这里返回的不是属性self.value而是self这个抽象对象</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.value &lt;= <span class="number">20</span>:</span><br><span class="line">	        self.value += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 这里我们需要输出值,print进行查看</span></span><br><span class="line">            <span class="keyword">return</span> self.value</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line">            </span><br><span class="line"><span class="comment"># ------</span></span><br><span class="line"></span><br><span class="line">temp = Numbers()</span><br><span class="line">temp_iter = <span class="built_in">iter</span>(temp)  <span class="comment"># 这一步骤可以省略，因为temp在实例化的时候已经是一个迭代器了（contains magic method） iterm | next</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以直接for-in-loop temp</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> temp_iter:</span><br><span class="line">    print(item)</span><br><span class="line">&gt; <span class="number">1</span> <span class="number">2</span> ... <span class="number">21</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将俩者的信息进行打印如下:</span></span><br><span class="line">print(<span class="string">f&quot;the obj is <span class="subst">&#123;temp&#125;</span> , type is <span class="subst">&#123;<span class="built_in">type</span>(temp)&#125;</span>&quot;</span>)</span><br><span class="line">print(<span class="string">f&quot;the iter is <span class="subst">&#123;temp_iter&#125;</span> , type is <span class="subst">&#123;<span class="built_in">type</span>(temp)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">&gt;&gt;</span><br><span class="line">the obj <span class="keyword">is</span> &lt;__main__.Numbers <span class="built_in">object</span> at <span class="number">0x0000016FFBD51088</span>&gt; , <span class="built_in">type</span> <span class="keyword">is</span> &lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">__main__</span>.<span class="title">Numbers</span>&#x27;&gt;</span></span><br><span class="line">the iter is &lt;__main__.Numbers object at 0x0000016FFBD51088&gt; , type is &lt;class &#x27;__main__.Numbers&#x27;&gt;</span><br><span class="line"><span class="comment"># 可以看到两者的物理地址相同，因此iter(OBJ)和OBJ一样都是属于迭代器</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="5-3生成器"><a href="#5-3生成器" class="headerlink" title="5.3生成器"></a>5.3生成器</h3><p>在 Python 中，使用了 yield 的函数被称为生成器（generator）。</p>
<p>跟普通函数不同的是，生成器是一个返回迭代器的函数，只能用于迭代操作，更简单点理解生成器就是一个迭代器。</p>
<p>在调用生成器运行的过程中，每次遇到 yield 时函数会暂停并保存当前所有的运行信息，返回 yield 的值, 并在下一次执行 next() 方法时从当前位置继续运行。</p>
<p>调用一个生成器函数，返回的是一个迭代器对象。</p>
<p>以下实例使用 yield 实现斐波那契数列：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibonacci</span>(<span class="params">n</span>):</span>  <span class="comment"># 生成器函数 - 斐波那契</span></span><br><span class="line">    a, b, counter = <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> (counter &gt; n): </span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">yield</span> a</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        counter += <span class="number">1</span></span><br><span class="line">f = fibonacci(<span class="number">10</span>)  <span class="comment"># f 是一个迭代器，由生成器返回生成</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">print</span> (<span class="built_in">next</span>(f), end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        sys.exit()</span><br><span class="line"><span class="comment">#  每次next（generator）所生成的迭代器对象公用和一个物理地址</span></span><br></pre></td></tr></table></figure>

<h3 id="5-4迭代器和生成器对比"><a href="#5-4迭代器和生成器对比" class="headerlink" title="5.4迭代器和生成器对比"></a>5.4迭代器和生成器对比</h3><ul>
<li><p>迭代器（iterator）是一个特殊的类，其中必有iterm和next方法，本质上是一个类|对象 </p>
<ul>
<li>除了使用class来定义一个迭代器外， 还可以使用iterm(obj)来快速生成一个迭代器对象</li>
<li>可以使用rais StopIteration来抛出exception阻止迭代器进入<strong>死循环</strong></li>
<li>是一个可以记住遍历的位置的对象（本质上含有iterm和next）</li>
</ul>
</li>
<li><p>生成器是一个含有yield的函数（generator），生成器是一个返回迭代器的函数，只能用于迭代操作，其实生成器也可以理解成一种特殊的迭代器</p>
<ul>
<li>生成器是一个返回迭代器的函数</li>
<li>在调用生成器运行的过程中，每次遇到 yield 时函数会暂停并保存当前所有的运行信息，返回 yield 的值, 并在下一次执行 next() 方法时从当前位置继续运行。</li>
<li>调用一个生成器函数，返回的是一个迭代器对象</li>
</ul>
</li>
</ul>
<h2 id="6-len为什么不是普通方法"><a href="#6-len为什么不是普通方法" class="headerlink" title="6.len为什么不是普通方法"></a>6.len为什么不是普通方法</h2><p>如果x是一个python内置类型的实例， 那么len(x)中Cpython会直接调用这个类的属性，解释器将不走<code>__len__()</code>这个方法</p>
<h2 id="杂谈"><a href="#杂谈" class="headerlink" title="杂谈"></a>杂谈</h2><ol>
<li><p>数据模型|对象模型</p>
<ul>
<li>python文档中大多使用数据模型, 而大多数喜欢使用对象模型</li>
<li>对象模型:计算机编程语言中对象的属性&lt;==&gt;数据模型</li>
</ul>
</li>
<li><p>魔法方法</p>
<ul>
<li>python用这个方法来提供更多的元对象协议,目的是让语言的使用者和开发者拥有并使用同样的工具</li>
</ul>
</li>
<li><p>元对象</p>
<p><code>the art of the MetaObject Protocal | AMOP</code></p>
<ul>
<li>元对象协议:那些对构建语言本身来讲很重要的对象, 以此为前提, 协议也可以看成是接口, 即是说, 元对象协议是对象模型(数据模型)的同义词, 他们的本质都是构建核心语言的API</li>
</ul>
</li>
</ol>
<h1 id="Part2-DataStructure"><a href="#Part2-DataStructure" class="headerlink" title="Part2.DataStructure"></a>Part2.DataStructure</h1><h2 id="2-0前言"><a href="#2-0前言" class="headerlink" title="2.0前言"></a>2.0前言</h2><p>在创建<code>poython</code>之前<code>Guido</code>曾为<code>ABC</code>语言贡献过代码, <code>ABC</code>语言是一个致力于为初学者设计变成环境的长达10的研究项目, 其中很多点子在现在看来任然具有python的特性如:</p>
<ol>
<li>序列的泛型操作</li>
<li>内置的元组</li>
<li>映射类型</li>
<li>用缩进来构建源码</li>
<li>无需变量声明的强类型</li>
</ol>
<p>python也从ABC继承了用统一风格处理<code>序列数据</code>这一特点, 无论是中数据结构(string|list|bytes|tuple|array|xml|element|database query)他们都公用一套操作:</p>
<ol>
<li>迭代</li>
<li>切片</li>
<li>排序</li>
<li>拼接</li>
</ol>
<h2 id="2-1内置序列类型"><a href="#2-1内置序列类型" class="headerlink" title="2.1内置序列类型"></a>2.1内置序列类型</h2><p>python使用C实现了两大类序列类型：<strong>容器序列 扁平序列</strong></p>
<blockquote>
<p>两者的却别前者支持存储不同类型的数据; 后者仅支持一种类型的数据</p>
</blockquote>
<p><strong>容器序列</strong>: <code>list tuple collection.deque</code></p>
<ul>
<li>存放的是任意类型的对象的引用</li>
<li>支持存储不同数据类型</li>
<li>非连续内存存储</li>
</ul>
<p><strong>扁平序列</strong>: <code>str bytes bytearray memoryvivew arrary.arrary</code></p>
<ul>
<li>存放的是值而不是引用</li>
<li>只能存储一种数据类型[字符 字节 数值]</li>
<li>连续存储</li>
</ul>
<p>根据是否可以被修改可以分为:<strong>可变序列</strong> <strong>不可变序列</strong></p>
<p>从UML图中可以看出两者之间的部分继承关系，但是<strong>内置的序列</strong>类型不是直接<code>sequence</code>和<code>mutale sequence</code>这两个抽象基类继承来的<code>Abstarct Base Class | ABC</code></p>
<table>
<thead>
<tr>
<th></th>
<th>immutable sequence</th>
<th>mutable sequence</th>
</tr>
</thead>
<tbody><tr>
<td>*getitem</td>
<td>y</td>
<td></td>
</tr>
<tr>
<td>*setitem</td>
<td></td>
<td>y</td>
</tr>
<tr>
<td>*delitem</td>
<td></td>
<td>y</td>
</tr>
<tr>
<td>*contains</td>
<td>y</td>
<td></td>
</tr>
<tr>
<td>*iter</td>
<td>y</td>
<td></td>
</tr>
<tr>
<td>*reversed</td>
<td>y</td>
<td></td>
</tr>
<tr>
<td>*iadd</td>
<td></td>
<td>y</td>
</tr>
<tr>
<td>index</td>
<td>y</td>
<td></td>
</tr>
<tr>
<td>insert</td>
<td></td>
<td>y</td>
</tr>
<tr>
<td>append</td>
<td></td>
<td>y</td>
</tr>
<tr>
<td>reverse</td>
<td></td>
<td>y</td>
</tr>
<tr>
<td>extend</td>
<td></td>
<td>y</td>
</tr>
<tr>
<td>pop</td>
<td></td>
<td>y</td>
</tr>
<tr>
<td>remove</td>
<td></td>
<td>y</td>
</tr>
<tr>
<td>count</td>
<td>y</td>
<td></td>
</tr>
</tbody></table>
<h2 id="2-2-列表推导和生成器表达"><a href="#2-2-列表推导和生成器表达" class="headerlink" title="2.2 列表推导和生成器表达"></a>2.2 列表推导和生成器表达</h2><blockquote>
<p>list comprehension and generator expression</p>
</blockquote>
<p><code>[]: 列表推导式</code></p>
<p><code>(): 生成器表达式</code></p>
<p><strong>列表推导式: 快速构建list</strong></p>
<p>使用原则:</p>
<ol start="0">
<li><p><strong>列表推导式的作用只有一个:生成列表</strong></p>
</li>
<li><p>创建新列表</p>
</li>
<li><p>尽量保持简短</p>
</li>
<li><p>在<code>py3.x</code>中修复了列表推导是中的变量泄露问题(通过局部作用域修复)</p>
</li>
<li><p>使用<code>filter + map</code>也可以达到相同效果</p>
</li>
<li><p>注意: <code>filter</code>返回的是一个迭代器</p>
</li>
<li><p>两者的效率根据不同情况表现不一样</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">temp = <span class="string">&#x27;!@#$%&#x27;</span></span><br><span class="line"></span><br><span class="line">m1 = [<span class="built_in">ord</span>(s) <span class="keyword">for</span> s <span class="keyword">in</span> temp <span class="keyword">if</span> <span class="built_in">ord</span>(s) &gt; <span class="number">35</span>]</span><br><span class="line">print(m1)</span><br><span class="line"></span><br><span class="line">m2 = <span class="built_in">list</span>(<span class="built_in">filter</span>(<span class="keyword">lambda</span> x: x &gt; <span class="number">35</span>, <span class="built_in">map</span>(<span class="built_in">ord</span>, temp)))</span><br><span class="line">print(m2)</span><br></pre></td></tr></table></figure>

<h3 id="2-2-1-笛卡尔积"><a href="#2-2-1-笛卡尔积" class="headerlink" title="2.2.1 笛卡尔积"></a>2.2.1 笛卡尔积</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">col_1 = [<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;c&quot;</span>]</span><br><span class="line">col_2 = [<span class="string">&quot;!&quot;</span>, <span class="string">&quot;@&quot;</span>, <span class="string">&quot;#&quot;</span>]</span><br><span class="line"></span><br><span class="line">col_3 = [(i, j) <span class="keyword">for</span> i <span class="keyword">in</span> col_1 <span class="keyword">for</span> j <span class="keyword">in</span> col_2]</span><br><span class="line">print(col_3)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> col_1:</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> col_2:</span><br><span class="line">        print(i, j)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>列表推导式和双层<code>for</code>循环俩者执行顺序一样</p>
</blockquote>
<h3 id="2-2-2生成器表达式"><a href="#2-2-2生成器表达式" class="headerlink" title="2.2.2生成器表达式"></a>2.2.2生成器表达式</h3><p>使用列表推导也可以初始化元组|数组|其他序列,但是生成器表达式是一个更好的选择, 因为背后支持迭代器协议,可以逐个产出元素而非先建立一个完整的<code>list</code>,可以更好的节省内存</p>
<p>生成器表达式和列表推导式的区别是:</p>
<ul>
<li><code>[]</code> <code>()</code></li>
<li>生成一个完整的<code>list</code>; 迭代器</li>
</ul>
<h2 id="2-3-元组"><a href="#2-3-元组" class="headerlink" title="2.3 元组"></a>2.3 元组</h2><blockquote>
<p>元组: 是一个不可变的list; 记录一定的维度[位置]的数据信息</p>
</blockquote>
<p>元组的拆包</p>
<p>本质上是将元组中的数据提取</p>
<ol start="0">
<li><p>元组的拆包方式在任意可迭代对象中都是通用的</p>
</li>
<li><p><code>for-loop</code></p>
</li>
<li><p><code>*</code></p>
<ul>
<li><code>*</code>拆包返回的是<code>list</code></li>
</ul>
</li>
<li><p>平行赋值</p>
</li>
<li><p><code>a, b = b, a </code>本质上也是拆包</p>
</li>
<li><p>可以使用<code>_</code>占位符来过滤掉不需要的数据</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.for-loop</span></span><br><span class="line">a = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> a:</span><br><span class="line">    print(i)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 2.*</span></span><br><span class="line"><span class="comment"># 提取元素</span></span><br><span class="line">i, *j = a</span><br><span class="line"><span class="comment"># 将可迭代对象拆开作为函数的参数</span></span><br><span class="line">b = (<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="built_in">divmod</span>(*b)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 平行赋值</span></span><br><span class="line">i, j, m = a</span><br></pre></td></tr></table></figure>

<h4 id="2-3-1-具名元组"><a href="#2-3-1-具名元组" class="headerlink" title="2.3.1 具名元组"></a>2.3.1 具名元组</h4><p><code>collections.namedtuple</code>构建的类的实例所消耗的内存和元组一样, 因为字段名都存在了相应的类里</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># namedtuple</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"></span><br><span class="line"><span class="comment"># define a class</span></span><br><span class="line"><span class="comment"># namedtuple(str, iterator)</span></span><br><span class="line"><span class="comment">#   &gt;&gt;&gt; str: the name of class</span></span><br><span class="line"><span class="comment">#   &gt;&gt;&gt; iterator: define the attributes of class</span></span><br><span class="line"><span class="comment">#   &gt;&gt;&gt; iterator(if accept str): &quot;name age score&quot; split whith &#x27; &#x27;</span></span><br><span class="line">student = namedtuple(<span class="string">&#x27;student&#x27;</span>, [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;score&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># create some instances</span></span><br><span class="line">drink = student(<span class="string">&#x27;Drink&#x27;</span>, <span class="string">&#x27;21&#x27;</span>, <span class="string">&#x27;90&#x27;</span>)</span><br><span class="line">starfire = student(<span class="string">&#x27;starfire&#x27;</span>, <span class="string">&#x27;23&#x27;</span>, <span class="string">&#x27;92&#x27;</span>)</span><br><span class="line">spark = student(<span class="string">&#x27;spark&#x27;</span>, <span class="string">&#x27;24&#x27;</span>, <span class="string">&#x27;95&#x27;</span>)</span><br><span class="line"></span><br><span class="line">print(drink)</span><br><span class="line">print(starfire)</span><br><span class="line">print(spark)</span><br><span class="line"></span><br><span class="line">student(name=<span class="string">&#x27;Drink&#x27;</span>, age=<span class="string">&#x27;21&#x27;</span>, score=<span class="string">&#x27;90&#x27;</span>)</span><br><span class="line">student(name=<span class="string">&#x27;starfire&#x27;</span>, age=<span class="string">&#x27;23&#x27;</span>, score=<span class="string">&#x27;92&#x27;</span>)</span><br><span class="line">student(name=<span class="string">&#x27;spark&#x27;</span>, age=<span class="string">&#x27;24&#x27;</span>, score=<span class="string">&#x27;95&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># we can get the specify value by [] or .attr</span></span><br><span class="line">print(drink[<span class="number">0</span>])</span><br><span class="line">print(drink.name)</span><br><span class="line"></span><br><span class="line">Drink</span><br><span class="line">Drink</span><br></pre></td></tr></table></figure>

<p>除了从普通元组继承的属性之外, 具名元组还有独特的属性:<code>_fields类属性|类方法|_make(iterable)和实列方法_asdict() </code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment"># get all attrs of drink</span></span><br><span class="line">print(drink._fields)</span><br><span class="line"></span><br><span class="line">(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;score&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># exchange drink into dict</span></span><br><span class="line">drink_dict = drink._asdict()</span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> drink_dict.items():</span><br><span class="line">    print(key, <span class="string">&quot;:&quot;</span>, value)</span><br><span class="line">    </span><br><span class="line">name : Drink</span><br><span class="line">age : <span class="number">21</span></span><br><span class="line">score : <span class="number">90</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># accept date generate an instance</span></span><br><span class="line">data = (<span class="string">&quot;star&quot;</span>, <span class="string">&quot;20&quot;</span>, <span class="string">&quot;60&quot;</span>)</span><br><span class="line">star = student._make(data)</span><br><span class="line">print(star)</span><br><span class="line"></span><br><span class="line">student(name=<span class="string">&#x27;star&#x27;</span>, age=<span class="string">&#x27;20&#x27;</span>, score=<span class="string">&#x27;60&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="2-3-2-不可变列表-元组"><a href="#2-3-2-不可变列表-元组" class="headerlink" title="2.3.2 不可变列表[元组]"></a>2.3.2 不可变列表[元组]</h4><blockquote>
<p>元组支持列表的大多数操作除了增删改元素之外</p>
</blockquote>
<h2 id="2-4切片"><a href="#2-4切片" class="headerlink" title="2.4切片"></a>2.4切片</h2><ol>
<li>切片支持大多数<code>可变序列</code></li>
<li>切片的数学表达式为<code>[&lt;= &lt;)</code></li>
<li>区间运算<code>start default=0</code></li>
<li><code>s[a:b:c] start end step</code>其中<code>step</code>可以为负即反向取值</li>
</ol>
<p>本质上在使用slice取值时, python会调用<code>seq.__getitem__(slice(start, end, step))</code></p>
<p>或者说<code>slice()</code>是一个切片对象, 可以改切片命名就像<code>excel--sheet</code>一样</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">name_slice = <span class="built_in">slice</span>(<span class="number">0</span>, <span class="number">5</span>)</span><br><span class="line">a = <span class="string">&quot;drink 21 98&quot;</span></span><br><span class="line">print(a[name_slice])</span><br><span class="line"></span><br><span class="line">drink</span><br></pre></td></tr></table></figure>

<h3 id="2-4-1-多维切片-省略"><a href="#2-4-1-多维切片-省略" class="headerlink" title="2.4.1 多维切片|省略"></a>2.4.1 多维切片|省略</h3><blockquote>
<p>多维切片所支持的数据序列也是多维度,而python内置的数据序列都是一维的</p>
</blockquote>
<p>本质上多维切片<code>seq[i, j]| seq[m:n, i:j]</code>调用的是<code>seq.__getitem__((i, j))</code>或者<code>seq.__setitem((i, j))</code></p>
<p>省略<code>...</code>在python解释器中是一个符号,其实本质上<code>Ellipsis</code>对象的别称</p>
<p>如果<code>x</code>是四维数组,那么<code>x[i:...]</code>就是<code>x[i:::]</code>的缩写</p>
<h3 id="2-4-2-切片赋值"><a href="#2-4-2-切片赋值" class="headerlink" title="2.4.2 切片赋值"></a>2.4.2 切片赋值</h3><ul>
<li>通过切片赋值右边必须是<strong>可迭代对象</strong></li>
</ul>
<h2 id="2-5-对序列使用-和"><a href="#2-5-对序列使用-和" class="headerlink" title="2.5 对序列使用+和*"></a>2.5 对序列使用+和*</h2><ul>
<li><p><code>+</code>和<code>*</code>都遵守一条规律即<strong>不修改原有的操作对象</strong>而是创建一个全新的序列</p>
</li>
<li><p><code>+</code>通常是相同类型的数据</p>
</li>
<li><p>在操作中python会创建一个包含相同类型数据的序列作为拼接的结果</p>
</li>
<li><p>注意在使用<code>seq * n</code>操作时, 如果<code>seq</code>里的元素是对其他可变对象的引用的话, 虽然<code>* n</code>拼接了, 但本质上还是对<code>seq</code>的引用, 对其进行操作时很可能会出现”多重操作”</p>
</li>
</ul>
<p>示例:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">a = [[<span class="string">&quot;_&quot;</span>] * <span class="number">3</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)]</span><br><span class="line"></span><br><span class="line">b = [[<span class="string">&quot;_&quot;</span>] * <span class="number">3</span>] * <span class="number">3</span></span><br><span class="line"></span><br><span class="line">a[<span class="number">1</span>][<span class="number">2</span>] = <span class="string">&quot;X&quot;</span></span><br><span class="line">b[<span class="number">1</span>][<span class="number">2</span>] = <span class="string">&quot;O&quot;</span></span><br><span class="line"></span><br><span class="line">print(a)</span><br><span class="line">print(b)</span><br><span class="line"></span><br><span class="line">[[<span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>],</span><br><span class="line"> [<span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;X&#x27;</span>],</span><br><span class="line"> [<span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>]]</span><br><span class="line"></span><br><span class="line">[[<span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;O&#x27;</span>],</span><br><span class="line"> [<span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;O&#x27;</span>], </span><br><span class="line"> [<span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;O&#x27;</span>]]</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/add_mul_operator.png"></p>
<p>其中<code>b</code>时三个指向同一对象的引用</p>
<p><code>b</code>所犯的错误和下面的错误一样</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># list中追加的是对同一对象的三次引用</span></span><br><span class="line">row = [<span class="string">&quot;_&quot;</span>] * <span class="number">3</span></span><br><span class="line">board = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    board.append(row)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># should optimize to this </span></span><br><span class="line">board = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    row = [<span class="string">&quot;_&quot;</span>] * <span class="number">3</span></span><br><span class="line">    board.append(row)</span><br></pre></td></tr></table></figure>

<h2 id="2-6-序列的增量赋值"><a href="#2-6-序列的增量赋值" class="headerlink" title="2.6 序列的增量赋值"></a>2.6 序列的增量赋值</h2><blockquote>
<p>即就地增量 += *= (仅针对可变序列), 不可变序列增量拼接的话实现的是 + * 每次都会创建一个新对象,效率会很低(str除外, 因为对于str的拼接操作过于频繁, CPython对其进行优化)</p>
</blockquote>
<p>在调用这些运算符中, python优先调用<code>__iadd__|__imul__</code>如果没有会次级调用<code>__add__|__mul__</code></p>
<p>需要注意的是:</p>
<p>如果<code>a</code>实现了<code>__iadd__</code>那么<code>+=</code>会实现就地增量赋值,像<code>a.extend(iterator)</code> 否则会调用<code>__add__</code>, 此时不是就地增加,而是首先计算<code>a + b</code>得到一个新的对象, 然后再将对象赋值给<code>a</code>,即是否实现<code>就地</code>完全取决于这个类型有没有实现<code>__iadd__</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">aa = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">print(<span class="built_in">id</span>(aa))</span><br><span class="line">aa += [<span class="number">1</span>, <span class="number">23</span>]</span><br><span class="line">print(<span class="built_in">id</span>(aa))</span><br><span class="line"></span><br><span class="line">ss = <span class="string">&quot;123&quot;</span></span><br><span class="line">print(<span class="built_in">id</span>(ss))</span><br><span class="line">ss += <span class="string">&quot;qwer&quot;</span></span><br><span class="line">print(<span class="built_in">id</span>(ss))</span><br><span class="line"></span><br><span class="line"><span class="number">1168530238600</span></span><br><span class="line"><span class="number">1168530238600</span></span><br><span class="line"><span class="number">1168257348464</span></span><br><span class="line"><span class="number">1168257157616</span></span><br></pre></td></tr></table></figure>

<p>对不可变序列进行重复拼接操作:</p>
<ol>
<li>创建一个新对象</li>
<li>将原来对象的元素复制到新对象中</li>
<li>追加寻元素</li>
</ol>
<p><code>str有优化:在为str初始化内存的时候,程序会为他流出额外的可扩展空间,因此进行增量操作的时候,并不会涉及复制原有字符串到新位置的这一操作</code></p>
<h3 id="2-6-1-元组的增量赋值"><a href="#2-6-1-元组的增量赋值" class="headerlink" title="2.6.1 元组的增量赋值"></a>2.6.1 元组的增量赋值</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">t = (<span class="number">1</span>, <span class="number">2</span>, [<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">t[<span class="number">2</span>] += [<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;input&gt;&quot;</span>, line <span class="number">2</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: <span class="string">&#x27;tuple&#x27;</span> <span class="built_in">object</span> does <span class="keyword">not</span> support item assignment</span><br><span class="line">print(t)</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br></pre></td></tr></table></figure>

<ol>
<li>元组中的元素被成功拼接</li>
<li>解释器抛出异常</li>
</ol>
<blockquote>
<p>其实写成t[2].extend([3, 4])就不会抛出异常了</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用dis.dis展示操作的python字节码</span></span><br><span class="line">dis.dis(<span class="string">&#x27;tuple[i] += iter&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="number">1</span>           <span class="number">0</span> LOAD_NAME                <span class="number">0</span> (<span class="built_in">tuple</span>)</span><br><span class="line">              <span class="number">2</span> LOAD_NAME                <span class="number">1</span> (i)</span><br><span class="line">              <span class="number">4</span> DUP_TOP_TWO</span><br><span class="line">              <span class="number">6</span> BINARY_SUBSCR</span><br><span class="line">              <span class="number">8</span> LOAD_NAME                <span class="number">2</span> (<span class="built_in">iter</span>)</span><br><span class="line">             <span class="number">10</span> INPLACE_ADD</span><br><span class="line">             <span class="number">12</span> ROT_THREE</span><br><span class="line">             <span class="number">14</span> STORE_SUBSCR</span><br><span class="line">             <span class="number">16</span> LOAD_CONST               <span class="number">0</span> (<span class="literal">None</span>)</span><br><span class="line">             <span class="number">18</span> RETURN_VALUE</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>BINARY_SUBSCR: 将值存入stack (DONE)</li>
<li>INPLACE_ADD 完成 += (DONE)</li>
<li>STORE_SUBSCR 赋值 (ERROR)</li>
</ul>
<p>可以得出:</p>
<ol>
<li>不要把可变对象放在元组里</li>
<li>增量赋值不是一个原子操作<ul>
<li>先计算</li>
<li>后赋值</li>
</ul>
</li>
</ol>
<h2 id="2-7-排序-sort和sorted"><a href="#2-7-排序-sort和sorted" class="headerlink" title="2.7 排序.sort和sorted()"></a>2.7 排序.sort和sorted()</h2><blockquote>
<p>两者都是排序, 且内部算法使用的是<code>Timsort</code>,它是一种自适应算法,会根据原始数据的顺序特点交替使用插入排序和并归排序,而且<code>Timsort</code>算法是稳定的(相等元素的相对位置保持不变)</p>
</blockquote>
<ul>
<li><p>seq.sort: 就地排序, 在原始数据的基础上排序, id不会改变, 这个方法返回<code>None</code> </p>
<ul>
<li>python operation返回<code>None</code>表示就地修改, 不会创建新对象</li>
<li>如果函数或者方法对对象进行就地修改,那么就应该让他返回<code>None</code>,通知调用者传入的参数发生改变,但并未创建新对象</li>
<li><code>random.shuffle(iterator)</code>|<code>id(iterator)</code>不会修改</li>
<li>返回<code>None</code>表示就地改动又个弊端, 就是调用者无法串联接口,即始终使用的是一个对象引用</li>
</ul>
</li>
<li><p>sort(obj) 会返回一个新建的<code>list</code></p>
<ul>
<li>可以接收任何形式的可迭代对象作为参数,包括不可变序列和生成器</li>
<li>最后返回的是一个<code>list</code></li>
</ul>
</li>
<li><p>两者都接受两个参数</p>
<ol>
<li><code>reverse=False</code>: 是否反向排序</li>
<li><code>key=identity function:接收一个排序</code>fun<code>通常使用</code>lambda函数<ul>
<li>恒等函数<code>(identity funtion)</code>默认用元素自己的值进行排序</li>
<li><code>key=str.lower</code>:忽略大小写排序</li>
<li><code>key=len</code>: 基于长度排序</li>
</ul>
</li>
</ol>
</li>
<li><p>接收<code>key</code>参数:</p>
<ol>
<li><code>min|max</code></li>
<li><code>sort|.sort</code></li>
<li><code>itertools.groupby()</code></li>
<li><code>heapq.nlargest()|heapq.nsmller()</code></li>
</ol>
</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> groupby</span><br><span class="line"><span class="keyword">from</span> operator <span class="keyword">import</span> itemgetter</span><br><span class="line"><span class="keyword">from</span> heapq <span class="keyword">import</span> nlargest, nsmallest</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">random.seed(<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line">a = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 就地随机打乱seq</span></span><br><span class="line">random.shuffle(a)</span><br><span class="line"></span><br><span class="line">print(a)</span><br><span class="line">a.sort()</span><br><span class="line">print(a)</span><br><span class="line">print(nlargest(<span class="number">3</span>, a))</span><br><span class="line">print(nsmallest(<span class="number">3</span>, a))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">temp_data = [</span><br><span class="line">    &#123;<span class="string">&quot;name&quot;</span>: <span class="number">1</span>, <span class="string">&quot;age&quot;</span>: <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;name&quot;</span>: <span class="number">2</span>, <span class="string">&quot;age&quot;</span>: <span class="number">32</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;name&quot;</span>: <span class="number">1</span>, <span class="string">&quot;age&quot;</span>: <span class="number">45</span>&#125;,</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据list中每个ele中的name进行排序</span></span><br><span class="line">temp_data.sort(key=itemgetter(<span class="string">&quot;name&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 过滤key=name</span></span><br><span class="line"><span class="keyword">for</span> name, data <span class="keyword">in</span> groupby(temp_data, key=itemgetter(<span class="string">&quot;name&quot;</span>)):</span><br><span class="line">    print(<span class="string">f&quot;name---[<span class="subst">&#123;name&#125;</span>]-----&gt; [<span class="subst">&#123;<span class="built_in">list</span>(data)&#125;</span>]&quot;</span>)</span><br><span class="line">    </span><br><span class="line">[<span class="number">4</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">[<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>]</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">name---[1]-----&gt; [[&#123;&#x27;name&#x27;: 1, &#x27;age&#x27;: 1&#125;, &#123;&#x27;name&#x27;: 1, &#x27;age&#x27;: 45&#125;]]</span><br><span class="line">name---[2]-----&gt; [[&#123;&#x27;name&#x27;: 2, &#x27;age&#x27;: 32&#125;]]</span><br></pre></td></tr></table></figure>

<h2 id="2-8-bisect管理有序序列"><a href="#2-8-bisect管理有序序列" class="headerlink" title="2.8 bisect管理有序序列"></a>2.8 bisect管理有序序列</h2><blockquote>
<p><code>bisect</code>模块包含两个主要的函数<code>bisect</code>和<code>insort</code>, 两者都是通过二分法获取<code>index</code>并进行操作</p>
</blockquote>
<p><code>bisect(haystack, needle)</code>, 在<code>haystack</code>中搜索<code>needle</code>其中:</p>
<ol>
<li><code>haystack</code>必须是有序的</li>
<li><code>return index</code></li>
</ol>
<p><code>bisect</code>可以建立一个用数字作为索引的查询表格, 比如把表格和成绩对应起来</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> bisect</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">grade</span>(<span class="params">socre, grades=<span class="literal">None</span>, breakpoints=<span class="string">&quot;FDCBA&quot;</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> grades <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        grades = [<span class="number">50</span>, <span class="number">60</span>, <span class="number">70</span>, <span class="number">80</span>, <span class="number">90</span>]</span><br><span class="line">    socre_index = bisect.bisect(grades, score)</span><br><span class="line">    <span class="keyword">return</span> breakpoints[socre_index]</span><br></pre></td></tr></table></figure>

<p><code>bisect.insort(seq, item)</code> 把变量<code>item</code>插入到有序序列<code>seq</code>中<code>[本质上是通过二分法获取index后插入]</code></p>
<ul>
<li>如果只是处理数字列表的话, <code>array</code>是一个更好的选择</li>
</ul>
<h2 id="2-9-当list不是首选时"><a href="#2-9-当list不是首选时" class="headerlink" title="2.9 当list不是首选时"></a>2.9 当list不是首选时</h2><p><code>list</code>可以处理多个数据类型,但当面对大量的数字类型时, <code>array</code>是一个更好的选择</p>
<ol>
<li>数组存储的不是<code>num</code>对象,而是数字的机器翻译(字节表述)</li>
<li>和C语言的数组一样, 如果需要频繁的对序列进行进出操作, <code>deque</code>的速度会更快</li>
<li>在处理<code>包含</code>操作时,<code>set</code>是个更好的选择,python对此进行过优化,需要注意的是,<code>set</code>不是序列,他是无序的</li>
</ol>
<h3 id="2-9-1-数组"><a href="#2-9-1-数组" class="headerlink" title="2.9.1 数组"></a>2.9.1 数组</h3><p><code>array.array</code>在存储数字方面效率胜于<code>list</code>且支持<code>list</code>的基本操作,此外数组还提供从文件读取<code>(.frombytes)</code>和存入文件<code>(.tofile)</code>的快速方法</p>
<blockquote>
<p>python中的数组和C一样, 在创建数组时都需要一个类型码,以表明要存储的数据类型</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> array <span class="keyword">import</span> array</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="comment"># init a array</span></span><br><span class="line">floats = array(<span class="string">&quot;d&quot;</span>, [random() <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span> ** <span class="number">7</span>)])</span><br><span class="line"><span class="comment"># get ele by index</span></span><br><span class="line">print(floats[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># init the path</span></span><br><span class="line">file_path = <span class="string">&quot;./floats.bin&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># open the file with &quot;wb&quot;</span></span><br><span class="line">fp = <span class="built_in">open</span>(file_path, <span class="string">&quot;wb&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># write the data to the specify file</span></span><br><span class="line"><span class="comment"># by binaryIO</span></span><br><span class="line">floats.tofile(fp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># close the file</span></span><br><span class="line">fp.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># init an empty array</span></span><br><span class="line">floats2 = array(<span class="string">&quot;d&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># open the file with &quot;rb</span></span><br><span class="line">op = <span class="built_in">open</span>(file_path, <span class="string">&quot;rb&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># open the file 10 ** 7 from file</span></span><br><span class="line"><span class="comment"># by binaryIO</span></span><br><span class="line">floats2.fromfile(op, <span class="number">10</span>**<span class="number">7</span>)</span><br><span class="line">print(floats2[<span class="number">1</span>])</span><br></pre></td></tr></table></figure>

<p>method区别:</p>
<ol>
<li>数组不支持浅拷贝|但支持<code>__deepcopy__</code></li>
<li>数组支持<code>seq.reverse()</code>但不支持<code>seq.__reversed__()</code></li>
<li>数组不支持就地排序<code>seq.sort()</code></li>
</ol>
<blockquote>
<p>从python3.4开始数组不再支持就地排序seq.sort(), 如果需要排序得用sorted函数重新建立一个数组</p>
</blockquote>
<p><code>a = array.array(a.typecode, sorted(a))</code></p>
<h3 id="2-9-2-内存视图"><a href="#2-9-2-内存视图" class="headerlink" title="2.9.2 内存视图"></a>2.9.2 内存视图</h3><p><code>memoryview</code>是一个内置类, 可以让用户在不复制内容的情况下操作同一数组的不同切片</p>
<ul>
<li>本质上是泛化和去数学化的<code>Numpy</code>数组</li>
<li>可以在不需要复制内容的前提下,在任何数据结构之间共享内存 </li>
<li>处理大数据很实用 –&gt; 节省了数据copy内存和时间</li>
<li>需要注意是对原数据直接进行操作</li>
</ul>
<p><code>memoryview.cast</code><strong>能用不同的方式读写同一块内存数据</strong>,并且内容字节不会随意移动,会把同一块内存里的内容打包成一个全新的<code>memoryview.cast</code>对象给你    </p>
<p> <strong>不同方式</strong>:可以用不同的读写方式操作数据</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># init array 类型码“h”</span></span><br><span class="line">temp_array = array(<span class="string">&#x27;h&#x27;</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用数组创一个memoryview实例</span></span><br><span class="line">view = <span class="built_in">memoryview</span>(temp_array)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个memoryview实例,其中把这块内存内容用“B”类型存储[无符号字符]</span></span><br><span class="line">cast = view.cast(<span class="string">&quot;B&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># .tolist()以列表的形式查看|return --&gt; list</span></span><br><span class="line">temp = cast.tolist()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把位于1的字节赋值为6, 因为把占2个字节的整数高位字节改成了6</span></span><br><span class="line"><span class="comment"># 那么之歌有符号整数的值就变为了 1537</span></span><br><span class="line">cast[<span class="number">1</span>] = <span class="number">6</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/memoryview"></p>
<p><img src="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/20220303231533.png"></p>
<h3 id="2-9-3-NumPy-SciPy"><a href="#2-9-3-NumPy-SciPy" class="headerlink" title="2.9.3 NumPy|SciPy"></a>2.9.3 NumPy|SciPy</h3><blockquote>
<p>NumPy和SciPy提供了高阶数组和矩阵操作, python内置数据类型都是一维数据</p>
</blockquote>
<p>维度: row</p>
<p>每个维度所含元素: col</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy</span><br><span class="line"></span><br><span class="line">a = numpy.arange(<span class="number">12</span>)</span><br><span class="line">print(a.shape)</span><br><span class="line"><span class="comment"># 表述1维row 12元素</span></span><br><span class="line">(<span class="number">12</span>,) </span><br><span class="line"></span><br><span class="line"><span class="comment"># using unpacking tuple </span></span><br><span class="line"><span class="comment"># 将1维12元素转化成4维3元素</span></span><br><span class="line">a.shape = <span class="number">4</span>, <span class="number">3</span></span><br><span class="line">[[ <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>]</span><br><span class="line"> [ <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>]</span><br><span class="line"> [ <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>]</span><br><span class="line"> [ <span class="number">9</span> <span class="number">10</span> <span class="number">11</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># get index_row = 1 index_col = 2</span></span><br><span class="line">a[<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># get all index_row index_col = 1</span></span><br><span class="line">a[:, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># transpose() matrix</span></span><br><span class="line"><span class="comment"># return new view</span></span><br><span class="line">a.transpose()</span><br></pre></td></tr></table></figure>

<h3 id="2-9-4-双向队列"><a href="#2-9-4-双向队列" class="headerlink" title="2.9.4 双向队列"></a>2.9.4 双向队列</h3><blockquote>
<p>用列表和append pop(0)可以实现队列 先进先出, 但是删除list中的第一个或者在第一元素前添加一个元素都是十分耗时的, 因为这涉及到所有元素的移动</p>
</blockquote>
<p><code>collection.deque</code>双端队列实现了队列两端元素操作的优化, 但是涉及到中间元素的操作依然会耗时, 并且是一个<code>thread safe</code>类</p>
<ul>
<li>快速从两端对元素进行操作</li>
<li>存储最近使用的几个元素</li>
<li><code>collection.deque</code>可以实现简单的过期机制&lt;通过设置maxlen&gt;</li>
<li><code>append(item)|popleft(index)</code>都是原子操作, 因此<code>deque</code>可以在多线程程序中安全地当作<code>先进先出</code>的<code>栈</code>使用, 而且使用者不需要担心<code>资源锁</code>问题</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="comment"># create dequeue maxlen=10 eles=range(10)</span></span><br><span class="line">dq = deque(<span class="built_in">range</span>(<span class="number">10</span>), maxlen=<span class="number">10</span>)</span><br><span class="line"><span class="comment"># [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># append one ele - right</span></span><br><span class="line">dq.append(<span class="number">10</span>)</span><br><span class="line"><span class="comment"># [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># append one ele - left</span></span><br><span class="line">dq.appendleft(<span class="number">0</span>)</span><br><span class="line"><span class="comment"># [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># rotate num ele default=right | negative=left</span></span><br><span class="line"><span class="comment"># return None ==&gt; will change ori data</span></span><br><span class="line">dq.rotate(<span class="number">3</span>)</span><br><span class="line"><span class="comment"># [7, 8, 9, 0, 1, 2, 3, 4, 5, 6]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># extend iterator ele default=right</span></span><br><span class="line">dq.extend([<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>])</span><br><span class="line"><span class="comment"># [0, 1, 2, 3, 4, 5, 6, 10, 11, 12]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># extendleft iterator ele</span></span><br><span class="line"><span class="comment"># attention the order!</span></span><br><span class="line">dq.extendleft([-<span class="number">1</span>, -<span class="number">2</span>, -<span class="number">3</span>])</span><br><span class="line"><span class="comment"># [-3, -2, -1, 0, 1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure>

<h2 id="2-10-线程安全"><a href="#2-10-线程安全" class="headerlink" title="2.10 线程安全"></a>2.10 线程安全</h2><blockquote>
<p>除了<code>collections.deque</code>外还有其他<code>python</code>标准库也有对队列的实现</p>
</blockquote>
<p><strong>queue</strong></p>
<p>提供了同步<code>线程安全</code>类<code>Queue|LifoQueue|PriorityQueue</code>,不同的<strong>线程</strong>可以利用这些数据类型来交换信息</p>
<ul>
<li>线程通信</li>
<li>三个类构造时都有一个可选参数<code>maxsize</code>用来限制队列大小</li>
<li>在满员时这些类并<strong>不会丢掉旧的元素腾出位置</strong></li>
<li>而是会锁住资源, 直到另外的线程移除了某个元素</li>
<li>适合<strong>控制活跃线程的数量</strong></li>
</ul>
<hr>
<p><strong>multiprocessing</strong></p>
<p>这个包实现了自己的<code>Queue</code>和<code>queue.Queue</code>类似, 是设计给<strong>进程</strong>通信用的还有一个<code>multiprocessiong.JoinableQueue</code></p>
<ul>
<li>进程通信</li>
<li>任务管理</li>
</ul>
<hr>
<p><strong>asyncio</strong></p>
<p><code>python3.4</code>及以上提供, 里面有<code>Queue</code> <code>LifoQueue PriorityQueue</code>和<code>JoinableQueue</code>这些类受到<code>queue</code>和<code>multiprocessing</code>的影响,用于异步变成任务管理</p>
<ul>
<li>异步编程</li>
</ul>
<hr>
<p><strong>heapq</strong></p>
<p>和上面三个模块不同, <code>heapq</code>没有队列类,而是提供了<code>heappush</code>和<code>heappop</code>方法, 可以让用户把<code>可变序列</code>当作堆队列或者优先队列使用</p>
<h2 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h2><p>可变序列 不可变序列</p>
<p>容器序列: 存储引用 非连续存储</p>
<p>扁平序列: 存储值 连续存储 原子性数据</p>
<p>列表: 列表中数据最好是具有相同特性的数据</p>
<p>拆包: 获取元组内数据最安全可靠的方法,<code>*</code>拆包的利器</p>
<p>具名元组: 将元组与数据关联</p>
<ul>
<li><code>namedtuple()._asdict</code>将具名元组转化成<code>ordereddoct</code></li>
<li><code>dict(zip(iter_key, iter_value))</code>普通元组转化<code>dict</code></li>
</ul>
<p>序列切片是python中最受欢迎的语言特性之一</p>
<p><strong>对切片赋值是一个修改可变序列的捷径</strong></p>
<p>重复拼接<code>n*seq</code>要在正确的前提下使用!!!!!</p>
<ul>
<li>初始化含有不可变元素的序列</li>
</ul>
<p>增量赋值<code>+= 和 *=</code>的操作行为和序列本身有关(可变序列|不可变序列) </p>
<p>PS: string类型有优化不会重复复制原数据</p>
<ul>
<li><p>可变序列: 就地修改</p>
</li>
<li><p>不可变序列: 生成新的序列</p>
<p><code>sort</code>和<code>sorted()</code>与<code>key</code>的用法</p>
</li>
<li><p>背后的逻辑是<code>timsort</code>算法, 它是一种自适应算法, 会根据原始数据的特点交替使用插入排序和并归排序</p>
</li>
</ul>
<hr>
<p>元组的鼻祖是ABC语言中的compounds, tuple更准确的说是<code>frozenlist</code></p>
<p><strong>key参数</strong></p>
<p>再使用默认函数key进行排序时<code>Python</code>总会比较两个键, 但是这一计算阶段发生在<code>C</code>语言层, 这也是比调用用户自定义比较函数快的原因</p>
<ul>
<li>当<code>ele</code>是<code>int</code> 或者<code>str</code>时, <code>key</code>支持<code>int</code>或者<code>str</code><ul>
<li><code>int</code>: 比较整个数值</li>
<li><code>str</code>: 只比较第一位数值</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">temp_1 = [<span class="number">3</span>, <span class="number">45</span>, <span class="number">2</span>, <span class="string">&quot;10&quot;</span>, <span class="string">&quot;34&quot;</span>]</span><br><span class="line">print(<span class="built_in">sorted</span>(temp_1, key=<span class="built_in">int</span>))</span><br><span class="line">print(<span class="built_in">sorted</span>(temp_1, key=<span class="built_in">str</span>))</span><br><span class="line"></span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="string">&#x27;10&#x27;</span>, <span class="string">&#x27;34&#x27;</span>, <span class="number">45</span>]</span><br><span class="line">[<span class="string">&#x27;10&#x27;</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">&#x27;34&#x27;</span>, <span class="number">45</span>]</span><br></pre></td></tr></table></figure>

<h1 id="Part3-Dict-Set"><a href="#Part3-Dict-Set" class="headerlink" title="Part3.Dict|Set"></a>Part3.Dict|Set</h1><blockquote>
<p><code>dict</code>的内置函数<code>_builtins_.dict_</code>, Python对字典实现了高度优化 –&gt; <code>hashtable</code></p>
</blockquote>
<h2 id="3-1-泛映射类型"><a href="#3-1-泛映射类型" class="headerlink" title="3.1 泛映射类型"></a>3.1 泛映射类型</h2><p><code>collections.abc</code>中含有<code>Mapping</code>和<code>MutableMapping</code>这俩个抽象类,为<code>dict</code>和其他类似的类型定义形式接口</p>
<p><img src="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/fluent_python_dict_set"></p>
<p>非抽象类一般不会直接继承这些抽象基类, 而是直接对<code>dict</code>或者<code>collections.User.Dict</code>进行扩展,这些抽象基类的主要作用是作为形式化的文档, 定义构建一个映射类型所需要的最基本接口.而且还可以与<code>isinstance</code>一起使用来判断某个数据是否是广义上的<code>mapping</code>类型</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">my_dict = &#123;&#125;</span><br><span class="line"><span class="built_in">isinstance</span>(my_dict, abc.mapping)</span><br></pre></td></tr></table></figure>

<ul>
<li>使用<code>isinstance</code>而不是<code>type</code></li>
<li>可以判断除<code>dict</code>外的广义映射类型</li>
</ul>
<blockquote>
<p>标准库的所有映射类型都是通过dict来实现的,他们有个共同的限制, 即key必须是可散列的</p>
</blockquote>
<p><strong>可散列数据</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">An <span class="built_in">object</span> <span class="keyword">is</span> hashable <span class="keyword">if</span> it has a <span class="built_in">hash</span> value which never changes during its lifetime (it needs a __hash__() method), <span class="keyword">and</span> can be compared to other objects (it needs an __eq__() method). Hashable objects which compare equal must have the same <span class="built_in">hash</span> value. </span><br></pre></td></tr></table></figure>

<ul>
<li>含有<code>__hash__</code> 散列</li>
<li>含有<code>__eq__ </code>比较key</li>
<li>哈希值在整个声明周期不会变化</li>
<li>散列对象相等==&gt;散列值一定相等</li>
</ul>
<p>可散列的数据类型:</p>
<ul>
<li>str</li>
<li>bytes</li>
<li>数值类型</li>
<li>frozenset</li>
<li>tuple(所含的元素全为可散列)</li>
</ul>
<hr>
<p>一般用户自定义的类型的对象都是可散列的, 其中散列值就是<code>id(obj)</code>, 所以所有这些对象在比较时都是不相等的. 如果一个对象实现了<code>__eq__</code>方法, 并且在方法中用到了这个对象的内部状态的话, 那么只有当所有这些内部状态都是不可变的情况下, 这个对象才是可散列的</p>
<hr>
<p><strong>构造字典方法</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;</span><br><span class="line"><span class="built_in">dict</span>(name=<span class="string">&quot;Drink&quot;</span>, age=<span class="string">&quot;23&quot;</span>, score=<span class="string">&quot;98&quot;</span>)</span><br><span class="line"></span><br><span class="line">&gt;&gt;</span><br><span class="line">&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Drink&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="string">&quot;23&quot;</span>, <span class="string">&quot;score&quot;</span>: <span class="string">&quot;98&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;</span><br><span class="line"><span class="built_in">dict</span>(<span class="built_in">zip</span>([<span class="string">&quot;name&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="string">&quot;score&quot;</span>], [<span class="string">&quot;Drink&quot;</span>, <span class="string">&quot;23&quot;</span>, <span class="string">&quot;98&quot;</span>]))</span><br><span class="line"></span><br><span class="line">&gt;&gt;</span><br><span class="line"><span class="built_in">dict</span>([(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Drink&quot;</span>), (<span class="string">&quot;age&quot;</span>, <span class="string">&quot;23&quot;</span>), (<span class="string">&quot;score&quot;</span>, <span class="string">&quot;98&quot;</span>)])</span><br><span class="line"></span><br><span class="line">&gt;&gt;</span><br><span class="line"><span class="built_in">dict</span>(&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Drink&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="string">&quot;23&quot;</span>, <span class="string">&quot;score&quot;</span>: <span class="string">&quot;98&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line">&gt;&gt;</span><br><span class="line">&#123;key, value <span class="keyword">for</span> key, value <span class="keyword">in</span> iterator(key-value-pair)&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-2-字典推导"><a href="#3-2-字典推导" class="headerlink" title="3.2 字典推导"></a>3.2 字典推导</h2><blockquote>
<p>推导式的作用: </p>
<p>创建新的数据对象</p>
<p>过滤作用</p>
</blockquote>
<h2 id="3-3-常见的映射方法"><a href="#3-3-常见的映射方法" class="headerlink" title="3.3 常见的映射方法"></a>3.3 常见的映射方法</h2><p>映射类型的方法很丰富, <code>dict</code> <code>defalutdict</code> 和<code>OrderedDict</code>的常见方法, 后面两个数据类型是<code>dict</code>的变种,位于<code>collections</code>模块内</p>
<p><img src="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/dict01.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/dict02"></p>
<p><img src="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/dict03.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/dict04"></p>
<p><code>default_factory</code>不是一个方法而是一个可调用对象, 他的值在<code>defaultdict</code>初始化中由用户设置</p>
<p><code>OrderedDict.popitem()</code>会移除最先插入的元素**(先进先出)<strong>, 如果<code>.popitem(last=True)</code>则会移除最后插入的元素</strong>(后进先出)**</p>
<p><code>d.update(m, [**kargs])</code>, 在处理<code>m</code>时, 函数首先检验<code>m</code>是否有<code>keys</code>方法,</p>
<ul>
<li>有–&gt;<code>update</code>会把它当作映射对象处理</li>
<li>无–&gt;<code>update</code>会把它当作含有<code>(key-vaule)</code>键值对元素的迭代器</li>
<li><code>python</code>大多数映射类型的构建都采用了相似的逻辑</li>
</ul>
<p><strong>可调用对象</strong></p>
<blockquote>
<p>将类当作函数调用instance()</p>
</blockquote>
<ul>
<li>类中实现<code>__call__</code></li>
<li>快速调用带有某一实例化属性的类的函数</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">eval_some</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">slef, g</span>):</span></span><br><span class="line">        self.g = g</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self, t</span>):</span></span><br><span class="line">        <span class="keyword">return</span> (self.g * <span class="number">2</span>) / t</span><br><span class="line"></span><br><span class="line">earth = eval_some(<span class="number">9.8</span>)</span><br><span class="line">print(earth(<span class="number">10</span>))</span><br></pre></td></tr></table></figure>

<h3 id="3-3-1-更新字典kV"><a href="#3-3-1-更新字典kV" class="headerlink" title="3.3.1 更新字典kV"></a>3.3.1 更新字典kV</h3><p><strong>用setdefault处理找不到的键</strong></p>
<p><code>d[k] --&gt; getitem</code>找不到键时, 会有异常抛出<code>KeyError</code></p>
<ul>
<li>符合python的快速失败哲学</li>
<li>可以使用<code>d.get(k, default)</code>代替异常</li>
<li><strong>当在更新某个键对应的值的时候, 以上俩个方式效率都很低</strong></li>
</ul>
<p>如果要更新字典的一个键值对(包括不存在)使用<code>setdefault(key, default) [operate]</code>这样只会<code>query 1</code>,如果使用<code>if else []</code>则会查询<code>2~3</code>次</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Drink&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里只会查询一次key并更新或初始化</span></span><br><span class="line"><span class="comment"># 如果key存在则对key-value更新</span></span><br><span class="line"><span class="comment"># 不存在将key-default放进映射中</span></span><br><span class="line">a.setdefault(<span class="string">&quot;things&quot;</span>, []).append(<span class="string">&quot;reading&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当存在key时查询2次, 不存在会查询3次</span></span><br><span class="line"><span class="keyword">if</span> <span class="string">&quot;things&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> a:</span><br><span class="line">    a[<span class="string">&quot;things&quot;</span>] = []</span><br><span class="line">a[<span class="string">&quot;things&quot;</span>].append(<span class="string">&quot;reading&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="3-4-映射的弹性键查询"><a href="#3-4-映射的弹性键查询" class="headerlink" title="3.4 映射的弹性键查询"></a>3.4 映射的弹性键查询</h2><blockquote>
<p>在映射中查找不存的key时, 我们希望可以返回一个default value而不是error, 以下俩途径可以实现弹性键查询</p>
</blockquote>
<ol>
<li>通过<code>defaultdict</code>这个类而不是普通的<code>dict</code></li>
<li>自己定义一个<code>dict</code>子类, 并在在子类中实现<code>__missing__</code>方法</li>
</ol>
<h3 id="3-4-1-defaultdict处理不存在的key"><a href="#3-4-1-defaultdict处理不存在的key" class="headerlink" title="3.4.1 defaultdict处理不存在的key"></a>3.4.1 defaultdict处理不存在的key</h3><blockquote>
<p><code>defaultdict</code>是<code>collections</code>中的一个类, 在实例化它时,可以接受一个<code>defaultfoctory</code>不接受参数(一定是可调用的且不接受参数的方法类|函数)</p>
</blockquote>
<ol>
<li><p>在调用<code>d[key]</code>中如果<code>__getitem__</code>找不到对应的<code>key</code>会调用<code>__missing__</code>查看是否定义了<code>defaultfactory</code></p>
</li>
<li><p>将<code>defaultfactory</code>返回的值赋值给<code>d[key]</code></p>
</li>
<li><p>更新<code>dict</code></p>
</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line">temp = defaultdict(<span class="built_in">list</span>)</span><br><span class="line"></span><br><span class="line">temp[<span class="string">&quot;name&quot;</span>]</span><br><span class="line">print(temp)</span><br><span class="line">&gt;&gt; </span><br><span class="line">defaultdict(&lt;class &#x27;list&#x27;&gt;, &#123;&quot;name&quot;: []&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>如果<code>defaultfactory=None</code>在没有找到对应的<code>key</code>时会抛出<code>KeyError</code></p>
</li>
<li><p><code>defaultfactory</code>只会在<code>__getitem__</code>中调用, 比如<code>dict[key]</code>才会被调用, 其中连接两者桥梁的时<code>__missing__</code></p>
</li>
</ul>
<h3 id="3-4-2-特殊方法missing"><a href="#3-4-2-特殊方法missing" class="headerlink" title="3.4.2 特殊方法missing"></a>3.4.2 特殊方法missing</h3><blockquote>
<p>所有的映射类型在找不到key的时候都会牵扯到missing, python基类虽然直到这个方法,但并没有定义这个方法, 不过, 如果一个class继承了dict并且这个类提供了missing方法,那么在<code>getitem</code>找不到值的时候不会抛出<code>异常</code></p>
</blockquote>
<p>特点:</p>
<ol>
<li><code>missing</code>方法只会被<code>getitem</code>调用</li>
<li>不会对<code>.get()</code> <code>__contains__</code>方法产生影响</li>
</ol>
<p><code>dict[key] -- __getitem__ -- __missing__</code></p>
<p><code>dict.get() -- get -- try except</code></p>
<hr>
<p>如果要自定义一个映射类型, 更合适的策略是继承<code>collections.UserDict</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># define the new mapping class by user based on dict</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrKeyDict</span>(<span class="params"><span class="built_in">dict</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__missing__</span>(<span class="params">self, key</span>):</span></span><br><span class="line">        <span class="comment"># 如果键不存在且本身是str则抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(key, <span class="built_in">str</span>):</span><br><span class="line">            <span class="keyword">raise</span> KeyError(key)</span><br><span class="line">        <span class="comment"># 如果键不存在且本身不是str则调用getitem</span></span><br><span class="line">        <span class="keyword">return</span> self[<span class="built_in">str</span>(key)]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># get方法吧查找工作用self[key]的形式委托给getitem,这样</span></span><br><span class="line">    <span class="comment"># 在宣布查找失败之前还missing再给某个键一个机会</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, key, default=<span class="literal">None</span></span>):</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> self[key]</span><br><span class="line">        <span class="keyword">except</span> KeyError:</span><br><span class="line">            <span class="comment"># 如果cast异常则missing也失败了,返回default</span></span><br><span class="line">            <span class="keyword">return</span> default</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__contains__</span>(<span class="params">self, key</span>):</span></span><br><span class="line">        <span class="comment"># 按照传入键的原本值来查找,如果没找到则转化成str再次查找</span></span><br><span class="line">        <span class="keyword">return</span> key <span class="keyword">in</span> self.keys() <span class="keyword">or</span> <span class="built_in">str</span>(key) <span class="keyword">in</span> self.keys()</span><br></pre></td></tr></table></figure>

<blockquote>
<p> 像<code>k in dict.keys()</code>操作在<code>python3</code>中是十分快速的, 即使映射类型对象很庞大, 因为:</p>
</blockquote>
<ul>
<li><code>dict.keys()</code>返回的值是一个视图, 就像集合, 在里面查找一个元素是十分快的</li>
<li><code>key in dict</code>扫描的是一个list, 处理大数据效率低<code>dict.keys()</code></li>
</ul>
<h2 id="3-5-字典的变种"><a href="#3-5-字典的变种" class="headerlink" title="3.5 字典的变种"></a>3.5 字典的变种</h2><p>都是基于<code>collections</code>库</p>
<blockquote>
<p>除了bultin中定义的dict外, 其余字典的变种都是<code>collections</code>库中的</p>
</blockquote>
<h3 id="UserDict"><a href="#UserDict" class="headerlink" title="UserDict"></a>UserDict</h3><blockquote>
<p>比较特殊的一种dict, 这个类其实是把builtin中的dict用纯Pyhton又实现了一遍</p>
</blockquote>
<p>一般用于用户自定义子类的继承</p>
<h3 id="OrderedDict"><a href="#OrderedDict" class="headerlink" title="OrderedDict"></a>OrderedDict</h3><blockquote>
<p>这个类型会在添加键的时候保持顺序, 因此键的每次迭代次序总是一致的</p>
</blockquote>
<p><code>OrderedDict</code>的<code>popitem</code>方法默认删除并返回的时字典里的最后一个元素(先进后出), 如果<code>popitem(last=False)</code>则会删除并返回第一个元素(先进先出)</p>
<h3 id="ChainMap"><a href="#ChainMap" class="headerlink" title="ChainMap"></a>ChainMap</h3><p><a target="_blank" rel="noopener" href="https://zditect.com/main-advanced/python/python-chainmap.html">什么是chainmap?为什么要搞chainmap</a></p>
<blockquote>
<p>该类型可以容纳数个不同的映射对象,然后在进行键查找操作时, 这些对象会被当作一个整体逐个进行查找,直到键被找到</p>
</blockquote>
<p>在给有嵌套功能作用域的语言做解释器的时候很有用, 可以用一个映射对象来代表一个作用域的上下文</p>
<p><code>ChainMap</code>可以将多个字典合并为一个独有的字典，这样的操作 并不是对源数据的拷贝，而是指向源数据，假如原字典数据修改，<code>ChainMap</code>映射也会改变；如果对<code>ChainMap</code>的结果修改，那么原数据一样也会被修改</p>
<p><strong>使用update进行合并字典,是对源数据的拷贝</strong></p>
<ol>
<li><p><code>ChainMap</code> 可接受多个映射然后在逻辑上使它们表现为一个单独的映射结构；它只是维护了一个记录底层映射关系的列表，然后去重定义常用的字典操作</p>
</li>
<li><p>如果有重复的键，会采用第一个映射中键对应的值</p>
</li>
<li><p>修改 <code>ChainMap </code>映射结构，会同时作用在自己和原始字典结构上</p>
</li>
<li><p>可以使用字典的 <code>update() </code>方法，来替代上面的合并方案；但是这就需要创建一个新的字典对象(或者修改原字典，破坏了原始数据)，并且原始字典做了修改，并不会反映到新建的字典上</p>
</li>
<li><p><code>ChainMap </code>使用的就是原始字典，因此原字典变，它也会改变。</p>
</li>
<li><p><strong>如果在使用 ChainMap 合并多个字典时，字典中有重复的 key 值，默认取第一个字典中 key 对应的 value</strong> ，从原理上面讲，ChainMap 实际上是把放入的字典存储在一个队列中，当进行字典的增加删除等操作只会在第一个字典上进行，当进行查找的时候会依次查找<code>(以查找的第一个key-value返回)</code></p>
</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">m1 = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Drink&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">23</span>&#125;</span><br><span class="line">m2 = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Drinkle&quot;</span>, <span class="string">&quot;score&quot;</span>: <span class="number">93</span>&#125;</span><br><span class="line">m3 = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Spark&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">23</span>, <span class="string">&quot;score&quot;</span>: <span class="number">98</span>, <span class="string">&quot;sex&quot;</span>: <span class="string">&quot;man&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">cm = collections.ChainMap(m1, m2, m3)</span><br><span class="line">print(cm)</span><br><span class="line">print(cm[<span class="string">&quot;name&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> cm.items():</span><br><span class="line">    print(key, <span class="string">&quot; &lt;--&gt; &quot;</span>, value)</span><br><span class="line"></span><br><span class="line">ChainMap(&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Drink&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">23</span>&#125;, &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Drinkle&#x27;</span>, <span class="string">&#x27;score&#x27;</span>: <span class="number">93</span>&#125;, &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Spark&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">23</span>, <span class="string">&#x27;score&#x27;</span>: <span class="number">98</span>, <span class="string">&#x27;sex&#x27;</span>: <span class="string">&#x27;man&#x27;</span>&#125;)</span><br><span class="line">Drink</span><br><span class="line">name  &lt;--&gt;  Drink</span><br><span class="line">age  &lt;--&gt;  23</span><br><span class="line">score  &lt;--&gt;  93</span><br><span class="line">sex  &lt;--&gt;  man</span><br></pre></td></tr></table></figure>

<h3 id="Counter"><a href="#Counter" class="headerlink" title="Counter"></a>Counter</h3><blockquote>
<p>这个类型会给键准备一个整数计数器, 每次更新一个键的时候都会增加这个计数器.因此这个类型可以用来给可散列对象计数(str bytes frozenset 数值型)或者当成多重集来用–&gt;多重集合就是集合里的元素可以出现不止一次, Counter实现了+ - 运算符来和并记录</p>
</blockquote>
<p>还有像<code>most_common(num)</code>这类方法, 会按照次序返回映射里最常见的num个键和他们的计数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">counter = collections.Counter(<span class="string">&quot;asdxzcsdfwerewrfewzsqawd&quot;</span>)</span><br><span class="line"></span><br><span class="line">print(counter)</span><br><span class="line"></span><br><span class="line">counter.update(<span class="string">&quot;asdsassd&quot;</span>)</span><br><span class="line"></span><br><span class="line">print(counter.most_common())</span><br><span class="line"></span><br><span class="line">Counter(&#123;<span class="string">&#x27;w&#x27;</span>: <span class="number">4</span>, <span class="string">&#x27;s&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;d&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;e&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;a&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;z&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;f&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;r&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;x&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;q&#x27;</span>: <span class="number">1</span>&#125;)</span><br><span class="line"></span><br><span class="line">[(<span class="string">&#x27;s&#x27;</span>, <span class="number">7</span>), (<span class="string">&#x27;d&#x27;</span>, <span class="number">5</span>)]</span><br></pre></td></tr></table></figure>

<h2 id="3-6-子类化UserDict"><a href="#3-6-子类化UserDict" class="headerlink" title="3.6 子类化UserDict"></a>3.6 子类化UserDict</h2><blockquote>
<p>自定义mapping类型,以<code>UserDict</code>为基类更加方便,因为<code>UserDict</code>是原生的方法, 而<code>dict</code>可能会走写捷径,导致我们不得不在子类中重写这些方法, 而<code>UserDict</code>则不会出现这个问题</p>
</blockquote>
<p>需要注意的是, <code>UserDict</code>并不是<code>Dict</code>的子类,但在<code>data</code>属性是基于<code>Dict</code>的实例实现的, 这个属性实际上是<code>UserDict</code>最终存储数据的地方</p>
<ul>
<li><code>UserDict</code>的子类在实现<code>__setitem__</code>避免了不必要的递归</li>
<li>可以让<code>__contains__</code>的代码更加简洁</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrKeyDict</span>(<span class="params">collections.UserDict</span>):</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__missing__</span>(<span class="params">self, key</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(key, <span class="built_in">str</span>):</span><br><span class="line">            <span class="keyword">raise</span> KeyError (key)</span><br><span class="line">        <span class="keyword">return</span> self[<span class="built_in">str</span>(key)]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__contains__</span>(<span class="params">self, key</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">str</span>(key) <span class="keyword">in</span> self.data</span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span>(<span class="params">self, key, value</span>):</span></span><br><span class="line">        self.data[<span class="built_in">str</span>(key)] = value</span><br></pre></td></tr></table></figure>

<p><code>UserDict</code>继承的是<code>MutableMapping</code>,所以<code>StrKeyDict</code>里剩下的映射类型方法都是从<code>UserDict</code> <code>MutableMapping</code> 和 <code>Mapping</code>这些超类中继承的</p>
<p><code>Mapping</code>类虽然是一个抽象基类<code>ABC</code>,但它提供了许多实用方法</p>
<p><strong>1.MutableMapping.update</strong></p>
<ul>
<li>可以直接使用<code>dict.update(obj)</code></li>
<li>定义在<code>__init__</code>中, 实列化时可以接受多个不同类型的参数构造<code>dict</code></li>
<li>本质上调用的是<code>__setitem__</code> –&gt; <code>self[key]=value</code></li>
</ul>
<p><strong>2.Mapping.get</strong></p>
<ul>
<li><code>.get()</code> –&gt; <code>def get()</code> –&gt; <code>try except</code></li>
</ul>
<h2 id="3-7-不可变映射类型"><a href="#3-7-不可变映射类型" class="headerlink" title="3.7 不可变映射类型"></a>3.7 不可变映射类型</h2><blockquote>
<p>接受一个mapping类型, 返还一个动态只读视图, 在原数据上更改可以反映到视图上,但不能对视图进行写操作, 只能读取 <code>types.MappingProxyType</code></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> types <span class="keyword">import</span> MappingProxyType</span><br><span class="line"></span><br><span class="line">temp = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Drink&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">proxy_dict = MappingProxyType(temp)</span><br><span class="line"></span><br><span class="line">&gt;&gt;</span><br><span class="line">proxy_dict[<span class="string">&quot;name&quot;</span>] </span><br><span class="line">proxy_dict[<span class="string">&quot;age&quot;</span>]</span><br><span class="line">proxy_dict[<span class="string">&quot;score&quot;</span>] = <span class="number">90</span></span><br><span class="line">temp[<span class="string">&quot;age&quot;</span>] = <span class="number">23</span></span><br><span class="line">proxy_dict</span><br><span class="line">&gt;&gt;</span><br><span class="line">&lt;Dirnk&gt;</span><br><span class="line">&lt;KeyError: <span class="string">&#x27;age&#x27;</span>&gt;</span><br><span class="line">&lt;TypeError: <span class="string">&#x27;mappingproxy&#x27;</span> <span class="built_in">object</span> does <span class="keyword">not</span> support item assignment&gt;</span><br><span class="line">&lt;SUCCESS&gt;</span><br><span class="line">&lt;&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Drink&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">23</span>&#125;&gt;</span><br></pre></td></tr></table></figure>

<h2 id="3-8-集合论"><a href="#3-8-集合论" class="headerlink" title="3.8 集合论"></a>3.8 集合论</h2><blockquote>
<p>集合从2.3以module出现, 到2.6才成为built-in type, 包括<code>set</code> <code>frozenset</code></p>
<p>集合的本质是许多唯一对象的聚集(去重)</p>
<p>拥有极快的查找速度 ==&gt; 散列表</p>
</blockquote>
<p>空集 –&gt; <code>set()</code></p>
<p><code>&#123;&#125;</code> –&gt; <code>dict 本质上是一个空字典</code></p>
<p>集合内元素必须是<code>can hash</code>即可散列的</p>
<ul>
<li>str</li>
<li>bytes</li>
<li>数值类型</li>
<li>frozenset</li>
</ul>
<p>集合的操作</p>
<p><code>|</code> –&gt; <code>∪</code></p>
<p><code>&amp;</code> –&gt; <code>∩</code> –&gt; <code>set.intersection(set)</code></p>
<p><code>-</code> –&gt; 差集</p>
<h3 id="3-8-1-集合字面量「仅set」"><a href="#3-8-1-集合字面量「仅set」" class="headerlink" title="3.8.1 集合字面量「仅set」"></a>3.8.1 集合字面量「仅set」</h3><blockquote>
<p>除了空集合<code>set()</code>外, 集合的字面量如同<code>&#123;1&#125; &#123;1, 2&#125;</code></p>
</blockquote>
<p>字面量语句构造集合的方法比<code>set([1, 2, &quot;3&quot;])</code>更快, 后者<code>python</code>需要新建一个列表, 最后吧这个列表传入到构造方法中, 如果是<code>&#123;1, 2, &quot;3&quot;&#125;</code>的字面量构造, <code>python</code>会利用一个<code>BUILD_SET</code>的字节码创建集合</p>
<p>使用反汇编函数查看字节码:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> dis <span class="keyword">import</span> dis</span><br><span class="line"></span><br><span class="line">dis(<span class="string">&quot;&#123;1&#125;&quot;</span>)</span><br><span class="line">dis(<span class="string">&quot;set([1])&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">0</span> LOAD_CONST    <span class="number">0</span> (<span class="number">1</span>)</span><br><span class="line"><span class="number">2</span> BUILD_SET     <span class="number">1</span></span><br><span class="line"><span class="number">4</span> RETURN_VALUE</span><br><span class="line">            </span><br><span class="line"><span class="number">0</span> LOAD_NAME      <span class="number">0</span> (<span class="built_in">set</span>)</span><br><span class="line"><span class="number">2</span> LOAD_CONST     <span class="number">0</span> (<span class="number">1</span>)</span><br><span class="line"><span class="number">4</span> BUILD_LIST     <span class="number">1</span>  --</span><br><span class="line"><span class="number">6</span> CALL_FUNCTION  <span class="number">1</span>  --</span><br><span class="line"><span class="number">8</span> RETURN_VALUE</span><br></pre></td></tr></table></figure>

<p><code>python</code>对于<code>frozenset</code>没有特殊字面量句法, 只能采用构造的方式</p>
<h3 id="3-8-2-集合推导"><a href="#3-8-2-集合推导" class="headerlink" title="3.8.2 集合推导"></a>3.8.2 集合推导</h3><blockquote>
<p>同列表推导字典推导一样</p>
</blockquote>
<ol>
<li>创建一个新的序列</li>
<li>起到过滤条件的作用</li>
</ol>
<h3 id="3-8-3-集合的操作"><a href="#3-8-3-集合的操作" class="headerlink" title="3.8.3 集合的操作"></a>3.8.3 集合的操作</h3><p><img src="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/338FE41118E025DEC0F08E62E79242FB.png"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># KeyError</span></span><br><span class="line">a.remove(<span class="number">4</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment"># pop the first one ele</span></span><br><span class="line">a.pop()  </span><br><span class="line"></span><br><span class="line"><span class="comment"># if number not in set do nothing</span></span><br><span class="line">a.discard(<span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<p>下表中, 缀运算符需要两侧的对象都是集合类型, 但是其他的方法则只要求所传入的参数是可迭代对象</p>
<p><img src="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/04AFD0F1F67F70C8B753E15D433EBB86.png"></p>
<p><strong>集合的比较运算符, 返回布尔值</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/9074D4974B2971BC1FA4BFBE2710A364.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/6D3B0816875580AF04759FD9538975E0.png"></p>
<p><strong>集合的其他操作方法</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/56D97AD7F6AB7ADC76CFDFC71D3CF306.png"></p>
<h2 id="3-9-dict和set的原理"><a href="#3-9-dict和set的原理" class="headerlink" title="3.9 dict和set的原理"></a>3.9 dict和set的原理</h2><blockquote>
<p><code>principles of dict and set</code>, 了解<code>python</code>里的字典和集合类型,他们背后所涉及的<code>hash table</code>是必不可少的</p>
<p>这节将会回答以下几个问题</p>
</blockquote>
<ol>
<li><code>python</code>中的<code>dict</code>和<code>set</code>效率有多高?</li>
<li>为什么他是无序且不稳定的?</li>
<li>为什么并不是所有的<code>python</code>对象都可以当作<code>dict</code>的<code>key</code>或<code>set</code>里的<code>number</code>?</li>
<li>为什么<code>dict</code>的<code>key</code>和<code>set</code>的<code>number</code>的顺序是根据它们被添加的次序而定的,以及为什么在映射对象的生命周期中,这个顺序并不是一成不变的?</li>
<li>为什么不应该迭代循环<code>dict</code>或<code>set</code>的同时往里面添加元素?</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">temp_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">a = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Drink&quot;</span>&#125;.fromkeys(temp_list, <span class="string">&quot;&quot;</span>)</span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line"><span class="built_in">dict</span>.fromkeys(iterator, values)</span><br><span class="line"><span class="comment"># Create a new dictionary with keys from iterable</span></span><br><span class="line"><span class="comment"># and values set to value.</span></span><br><span class="line">&#123;<span class="number">1</span>: <span class="string">&#x27;&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;&#x27;</span>, <span class="number">3</span>: <span class="string">&#x27;&#x27;</span>, <span class="number">4</span>: <span class="string">&#x27;&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-9-1-效率实验"><a href="#3-9-1-效率实验" class="headerlink" title="3.9.1 效率实验"></a>3.9.1 效率实验</h3><p>使用<code>in set(&amp;)</code>  操作符,分别在<code>set dict list</code>查询是否含有某个元素</p>
<p>其中结果如下:</p>
<p>最快的是<code>&amp;</code></p>
<p>最慢的是<code>list in</code></p>
<p>由于列表背后没有散列表来支持<code>in</code>运算符, 每次搜索都会扫描一次完成的列表 [说明了, <code>dict</code>和<code>set</code>在使用散列表存储的时候使用了类似排序的功能]</p>
<h3 id="3-9-2-dict中的散列表"><a href="#3-9-2-dict中的散列表" class="headerlink" title="3.9.2 dict中的散列表"></a>3.9.2 dict中的散列表</h3><blockquote>
<p>这一节只是笼统的描述python如何使用hashtable来实现dict, 其中Cpython对dict有过优化</p>
</blockquote>
<p><strong>散列表</strong> </p>
<ul>
<li><p>本质上是一个稀疏数组(总是有空白元素的数组称为稀疏数组)</p>
</li>
<li><p>散列表中的单元叫做表元(bucket)</p>
</li>
<li><p>在dict的散列表中, 每个键值对占用一个表元,一个表元有俩部分, 分别是对值的引用和对键的引用</p>
</li>
<li><p>表元大小一致, 可以通过偏移量读取特定的表元</p>
</li>
<li><p>python会保证散列表中大约三分之一的表元是空的,如果达到阈值, <strong>原有的散列表会被复制</strong>到一个更大的空间中</p>
</li>
<li><p>把对象放入散列表, 首先使用<code>hash()</code>计算这个元素键的散列值</p>
</li>
</ul>
<p><strong>有关散列表的概念</strong>:</p>
<p><strong>1.散列值和相等性</strong></p>
<blockquote>
<p><code>hash()</code> <code>  ==</code></p>
</blockquote>
<ul>
<li><code>hash()</code>可以用于任何内置类型对象, 自定义对象调用自定义实现的<code>__hash__</code></li>
<li>如果俩对象在比较时是相等的, 则它们的散列值一定相等(但对象的类型和存储结构不一定相等)</li>
<li>为了让散列值可以当作散列表的索引, 越是相似但不相等的对象,他们散列值的差别就越大</li>
</ul>
<p>从python3.3开始 str bytes datetime对象的散列值计算过程中多了随机<code>加盐</code> 所加盐值是python进程内的一个常量每次启动python解释器都会生成一个不同的盐值,目的是为了防止<code>DOS</code>攻击而采取的安全措施</p>
<p><strong>2.散列表算法</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/20220312164711.png"></p>
<p>以<code>dict[key]</code>为例:</p>
<ul>
<li>python首先会调用<code>hash(key)</code>计算key的散列值</li>
<li>把计算的散列值最低的几位数字当作偏移量, 在散列表中查找表元<code>bucket</code><ul>
<li>具体取几位要看散列表的大小</li>
<li>若对应的表元为空 –&gt;  <code>KeyError</code></li>
<li>若非空 –&gt; 表元里会有<code>key-value-pairs</code></li>
</ul>
</li>
<li>python会校验<code>key-value-pairs</code>中的<code>key</code>与输入的<code>key</code>是否相等<code>==</code><ul>
<li>相等 –&gt; 返回对应的<code>value</code></li>
<li>不等 –&gt; 散列冲突</li>
</ul>
</li>
<li>散列冲突: 因为散列表所做的是把随机的元素映射到只有几位的数字上,而散列表本身的索引又依赖于这个数字的一部分<ul>
<li>为了解决冲突,算法会在散列值中另外再取几位数字用特殊方法处理后把新的数字当作索引寻找表元,并重复之前的操作</li>
</ul>
</li>
</ul>
<hr>
<p><strong>添加新元素:</strong></p>
<p>发现表元为空时会放入一个新元素</p>
<p><strong>更新元素</strong>:</p>
<p>找到表元后会更新元素</p>
<p><strong>需要注意的是,python会按照散列表的拥挤程度来决定是否要重新分配内存为它扩容,如果增加散列表的大小,那散列值所占的位数和用作索引的位数会增加,减少了散列冲突</strong></p>
<hr>
<p>**注意:**Cpython中规定如果有一个整型对象,而且他能存进入一个机器字中,那么他的散列值就是它本身</p>
<h3 id="3-9-3-dict的实现和限制"><a href="#3-9-3-dict的实现和限制" class="headerlink" title="3.9.3 dict的实现和限制"></a>3.9.3 dict的实现和限制</h3><blockquote>
<p>主要讨论hashtable给dict带来的优势和限制</p>
</blockquote>
<p><strong>1.键必须是可散列的</strong></p>
<p>包括: str bytes frozenset 数值类型</p>
<p>一个可散列的对象必须包括</p>
<ul>
<li>支持<code>hash()</code>函数并且通过<code>__hash__</code>所得到的散列值不变(在他的生命周期中)</li>
<li>支持通过<code>__eq__</code>方法检测相等性</li>
<li>若<code>a==b</code>那么<code>hash(a)==hash(b)</code></li>
<li>所有由用户自定义的对象默认都是可散列的,因为他们的散列值都是<code>id()</code>来获取的,而且他们不相等</li>
</ul>
<p>**注意:**如果自定义的类实现了<code>_eq_</code>,并且希望他是可散列的, 那么必须定义一个恰当的<code>_hash_</code>保证<code>a==b</code>时<code>hash(a)==hash(b)</code>另一方面,如果一个含有自定义<code>_eq_</code>依赖的类处于可变状态, 那么就不要在这个类中实现<code>_hash_</code>,因为他的实例是不可散列的</p>
<hr>
<p><strong>2.字典在内存中开销大</strong></p>
<ul>
<li>字典使用散列表实现</li>
<li>散列表是稀疏的</li>
<li>在自定义类中<code>_slots_</code>属性可以改变实例属性的存储方式, 由<code>dict--&gt;tuple</code></li>
<li><code>optimization</code>优化往往和可维护相对立<code>maintain</code></li>
</ul>
<hr>
<p><strong>3.键查询很快</strong></p>
<ul>
<li>空间换时间</li>
<li><code>hash table</code>实现了无视数据量大小的快速访问<code>(在数据能放入内存的前提下)</code></li>
</ul>
<p><strong>4.键的次序取决于添加次序</strong></p>
<ul>
<li>在添加新键时, 可能会由哈希冲突, 此时新键会被安排到另一个表元(bucket)中</li>
<li>但是和俩个值相同的键添加顺序有关</li>
<li>虽然逻辑和面向用户表现形式上如此,在判断俩上依旧是相等的</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Drink&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">23</span>&#125;</span><br><span class="line">b = &#123;<span class="string">&quot;age&quot;</span>: <span class="number">23</span>, <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Drink&quot;</span>&#125;</span><br><span class="line"><span class="keyword">if</span> a == b:</span><br><span class="line">    print(<span class="string">&quot;you are right&quot;</span>)</span><br><span class="line">&gt;&gt;</span><br><span class="line">right</span><br></pre></td></tr></table></figure>

<p><strong>5.添加新键会改变已有键的顺序</strong></p>
<blockquote>
<p>尽量不要边遍历边添加新键</p>
</blockquote>
<ul>
<li>添加新键</li>
<li>python解释器为字典扩容</li>
<li>新键散列表并把已有元素添加到新表中</li>
<li>这个过程可能会发生散列冲突,导致新散列表中键的次序变化</li>
<li>如果在迭代一个字典的所有键的过程中同时对字典进行修改,那么这个循环可能会跳过一些键甚至是字典中已有的键</li>
</ul>
<p>因此:不要对字典同时进行迭代和修改,如果扫描并修改一个字典,最好分成俩步 :</p>
<p>​        [迭代–得出要添加的内容–并把内容放到新字典]  </p>
<p>​        [对原有字典进行更新]</p>
<p>不过在<code>python3</code>中对此进行了优化,<code>.keys()</code> <code>.items()</code> <code>.values()</code>方法返回的都是字典视图, 换句话说这些方法返回的更像<code>set</code>而不是<code>list</code>,此外视图还可以动态的反馈字典的变化</p>
<h3 id="3-9-4-set的实现和限制"><a href="#3-9-4-set的实现和限制" class="headerlink" title="3.9.4 set的实现和限制"></a>3.9.4 set的实现和限制</h3><blockquote>
<p>set 和 frozenset的实现也依赖于散列表</p>
</blockquote>
<ul>
<li>在散列表中只存放元素的引用(类似只存放key的引用)</li>
<li>集合中的元素必须是可散列的</li>
<li>集合很消耗内存</li>
<li>可以很高效的判断元素是否在集合中</li>
<li>元素的次序取决于被添加到集合中的顺序</li>
<li>在集合里添加元素会改变集合里已有元素的次序</li>
</ul>
<h2 id="本章小结-1"><a href="#本章小结-1" class="headerlink" title="本章小结"></a>本章小结</h2><p><code>dict</code>是<code>python</code>的基石, 除了<code>dict</code>外<code>builtin</code>里还提供了特殊映射比如<code>collections</code>里的<code>defaultdict</code> <code>OrderDict</code> <code>ChainMap</code> <code>Counter</code> <code>UserDict</code>以及<code>types</code>里的<code>MappingProxyTypes</code></p>
<p><strong>映射类型的重要方法</strong></p>
<p><strong>1.setdefault</strong></p>
<ul>
<li>更新字典里存档的可变值(比如列表)</li>
<li>避免重复搜索键</li>
</ul>
<p><strong>2.update</strong></p>
<ul>
<li>让批量更新字典成为可能</li>
</ul>
<p><strong>3.missing</strong></p>
<ul>
<li>可以自定当找不到对应的<code>key</code>时, 对象如何处理</li>
</ul>
<p><code>collections.abc</code>模块提供了<code>Mapping</code>和<code>MutableMapping</code>俩大抽象基类,利用它可以进行类型查询或者引用,此外还有<code>Set</code>和<code>MutableSet</code>俩大抽象基类</p>
<h1 id="Part4-TextAndBytes"><a href="#Part4-TextAndBytes" class="headerlink" title="Part4.TextAndBytes"></a>Part4.TextAndBytes</h1><blockquote>
<p>human use text and computer use bytes.</p>
</blockquote>
<p>本章节主要讨论:</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 字符 码位 字节表述</li>
<li><input checked="" disabled="" type="checkbox"> <code>bytes</code> <code>bytearray</code> 和 <code>memoryview</code>等二进制序列的独特性</li>
<li><input checked="" disabled="" type="checkbox"> 全部<code>unicode</code>和陈旧字符集的编解码器</li>
<li><input checked="" disabled="" type="checkbox"> 避免和处理编码错误</li>
<li><input checked="" disabled="" type="checkbox"> 处理文本文件的最佳实践</li>
<li><input checked="" disabled="" type="checkbox"> 默认编码的陷阱和标准<code>I/O</code>问题</li>
<li><input checked="" disabled="" type="checkbox"> 规范化 <code>Unicode</code>文本 进行安全比较</li>
<li><input checked="" disabled="" type="checkbox"> 规范化 大小写折叠和暴力移除音调符号的实用函数</li>
<li><input checked="" disabled="" type="checkbox"> 使用<code>locale</code>模块和<code>PyUCA</code>库正确地排序<code>Unicode</code>文本</li>
<li><input checked="" disabled="" type="checkbox"> <code>Unicode</code>数据库中的字符元数据</li>
<li><input checked="" disabled="" type="checkbox"> 能处理字符串和字节序列的双模式<code>API</code></li>
</ul>
<h2 id="4-1-字符问题"><a href="#4-1-字符问题" class="headerlink" title="4.1 字符问题"></a>4.1 字符问题</h2><blockquote>
<p>字符串:一个字符序列, 本质上是一个序列; 问题是什么是字符?</p>
<p>2015年字符的定义为Unicode字符(面向人)</p>
</blockquote>
<p>Unicode标准把字符的标识-和具体的字节表述进行了区分:</p>
<ul>
<li><strong>字符的标识即码位</strong>:是0<del>1114111的数字(10进制)在<code>unicode</code>标准中以4</del>6个十六进制数字标识,并且加前缀<code>U+</code></li>
<li><strong>字符的具体表述取决于所用的编码</strong>:编码是在码位和字节序列之间转换时使用的算法</li>
</ul>
<p><strong>把码位转化成字节序列的过程时编码,反之是解码</strong></p>
<p>简单的理解: </p>
<p><strong>码位</strong>是数字映射后的准备编码的<strong>字符标识</strong>;</p>
<p><strong>字节序列</strong>是通过一定编码规则(算法)编码后的用于计算机存储和传播的<strong>字节序列</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/20220313165653.png"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># init string</span></span><br><span class="line">a = <span class="string">&#x27;advdv我&#x27;</span>  </span><br><span class="line"></span><br><span class="line"><span class="comment"># advdv我字符串有四个Unicode字符</span></span><br><span class="line">print(<span class="built_in">len</span>(a))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用UTF-8把str对象编码成bytes对象</span></span><br><span class="line">b = a.encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># check b and len of b</span></span><br><span class="line"><span class="comment"># \xe6 --&gt; one 16-base</span></span><br><span class="line"><span class="comment"># 我 -encode-&gt; three bytes</span></span><br><span class="line"><span class="comment"># -&gt; \xe6\x88\x91</span></span><br><span class="line">print(b, <span class="built_in">len</span>(b))</span><br><span class="line"></span><br><span class="line"><span class="comment"># decode b with utf-8</span></span><br><span class="line"><span class="comment"># 使用UTF-8把bytes对象解码成str对象</span></span><br><span class="line">print(b.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line">&gt;&gt;</span><br><span class="line"><span class="number">6</span> </span><br><span class="line"><span class="comment"># bytes对象字面量以b开头</span></span><br><span class="line"><span class="comment"># 字节序列b有8个字节 我被编码成了三个字节</span></span><br><span class="line"><span class="string">b&#x27;advdv\xe6\x88\x91&#x27;</span> <span class="number">8</span></span><br><span class="line">advdv我</span><br></pre></td></tr></table></figure>

<p><code>python3</code>的<code>str</code>类型基本相当于<code>python2</code>的<code>unicode</code>类型, 但是前者的<code>bytes</code>类型却不是把<code>str</code>类型换个名字那么简单</p>
<h2 id="4-2-字节概要"><a href="#4-2-字节概要" class="headerlink" title="4.2 字节概要"></a>4.2 字节概要</h2><p><code>python</code>内置了两个基本的二进制序列类型其中有<code>py3</code>引入的不可变<code>bytes</code>类型和<code>py2.6</code>添加的可变<code>bytesarray</code>类型</p>
<p><code>bytes</code>和<code>bytearray</code>对象的各个元素是介于<code>0~255(含)</code>之间的整数而不是<code>py2</code>的<code>str</code>对象那样的单个字符.</p>
<p>需要注意的是二进制序列的切片始终是同一类型的二进制序列</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># bytes对象可以从str对象加给定的编码方法构建</span></span><br><span class="line">cafe = <span class="built_in">bytes</span>(<span class="string">&quot;cafの&quot;</span>, encoding=<span class="string">&quot;utf_8&quot;</span>)</span><br><span class="line">print(cafe)</span><br><span class="line"></span><br><span class="line"><span class="comment"># bytes对象中的各个元素是range(256)的整数</span></span><br><span class="line">print(cafe[<span class="number">0</span>])</span><br><span class="line"><span class="comment"># bytes对象的切片依然是bytes</span></span><br><span class="line">print(cafe[:<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># bytesarray对象没有字面量语句而是以bytearray()</span></span><br><span class="line"><span class="comment"># 和字节序列字面量参数的形式显示</span></span><br><span class="line">cafe_arr = <span class="built_in">bytearray</span>(cafe)</span><br><span class="line">print(cafe_arr)</span><br><span class="line"><span class="comment"># bytearray对象的切片还是bytearray对象</span></span><br><span class="line">print(cafe_arr[-<span class="number">1</span>:])</span><br><span class="line"></span><br><span class="line">&gt;&gt;</span><br><span class="line"><span class="string">b&#x27;caf\xe3\x81\xae&#x27;</span></span><br><span class="line"><span class="number">99</span></span><br><span class="line"><span class="string">b&#x27;c&#x27;</span></span><br><span class="line"><span class="built_in">bytearray</span>(<span class="string">b&#x27;caf\xe3\x81\xae&#x27;</span>)</span><br><span class="line"><span class="built_in">bytearray</span>(<span class="string">b&#x27;\xae&#x27;</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>二进制序列本质上整数序列,但是他们的字面量表示含有ASCII文本,因此各个字节的值会有以下三种不同的方式显示 –&gt; 例如<code>b&#39;xxxxx\xx\xx\t&#39;</code></p>
</blockquote>
<ul>
<li>可打印的ASCII范围内的字节(从空格到~)使用ASCII字符本身</li>
<li>制表符 换行符 回车符和\ 使用转义序列 <code>\t</code> <code>\n</code>  <code>\r</code> <code>\\</code></li>
<li>其他字节的值,使用十六进制转义序列(<code>\x00</code>空字节)</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/20220313200437.png"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="built_in">bytes</span>.fromhex(<span class="string">&#x27;31 4b ce a9&#x27;</span>)</span><br><span class="line">print(a)</span><br><span class="line"><span class="string">b&#x27;1K\xce\xa9&#x27;</span></span><br><span class="line">31(16进制) --&gt; 49(10进制) --&gt; ASCII(1K)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">在ASCII中K代表10进制</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="4-2-1-str方法"><a href="#4-2-1-str方法" class="headerlink" title="4.2.1 str方法"></a>4.2.1 str方法</h3><p><strong>1.casefold</strong></p>
<p><code>lower()</code> 只对 ASCII 也就是 <code>&#39;A-Z&#39;</code>有效，但是其它一些语言里面存在小写的情况就没办法了。文档里面举得例子是德语中<code>&#39;ß&#39;</code>的小写是<code>&#39;ss&#39;</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&#x27;ß&#x27;</span></span><br><span class="line">s.lower() <span class="comment">#  &#x27;ß&#x27;</span></span><br><span class="line">s.casefold() <span class="comment"># &#x27;ss&#x27;</span></span><br></pre></td></tr></table></figure>

<p>汉语 &amp; 英语环境下面，继续用 <code>lower()</code>没问题；要处理其它语言且存在大小写情况的时候再用<code>casefold()</code></p>
<p><strong>2.isdecimal</strong></p>
<p>判断<code>string</code>是否是十进制, 返回<code>bool</code>空字符为<code>False</code></p>
<p><strong>3.isidentifier</strong></p>
<blockquote>
<p>Python 对各种变量、方法、函数等命名时使用的字符序列称为标识符</p>
</blockquote>
<p>检查<code>string</code>是否是<code>python</code>标识符</p>
<p>标准为:</p>
<ul>
<li><p>由 26 个英文字母大小写，0-9 ，_ 组成，不能以数字开头，且严格区分大小写</p>
</li>
<li><p>不能包含空格、@、% 以及 $ 等特殊字符，不能以系统保留关键字作为标识符一共有25 个</p>
</li>
<li><p>以下划线开头的标识符有特殊含义</p>
</li>
</ul>
<p>对应<code>keyword.iskeyword(str)</code>检查是否是<code>python</code>保留的关键字</p>
<p><strong>4.isnumeric</strong></p>
<p><code>isnumeric()</code> 方法检测字符串是否只由数字组成，数字可以是<code>Unicode</code>数字，全角数字（双字节） 罗马数字 汉字数字。指数类似 <strong>²</strong> 与分数类似 <strong>½</strong> 也属于数字。返回<code>bool</code></p>
<p><strong>5.isprintable</strong></p>
<p>判断是否是可打印字符,不可打印的有:</p>
<ul>
<li>换行符制表符等<code>\t \n</code></li>
</ul>
<p><strong>6.translate</strong></p>
<p><code>s.transelate(table)</code></p>
<p><code>table</code>用<code>str.maketrans(in-str, out-str)</code>生成<strong>用于创建字符映射的转换表</strong></p>
<p>转换表本质上整数映射</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(transtable)</span><br><span class="line"></span><br><span class="line">&#123;<span class="number">115</span>: <span class="number">109</span>, <span class="number">111</span>: <span class="number">97</span>, <span class="number">109</span>: <span class="number">110</span>, <span class="number">101</span>: <span class="number">121</span>&#125;</span><br></pre></td></tr></table></figure>

<p>以<code>table</code>作为基础替换<code>s</code>中所有命中的字符</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">&quot;i like something relaxing!&quot;</span></span><br><span class="line">in_str = <span class="string">&quot;some&quot;</span></span><br><span class="line">out_str = <span class="string">&quot;many&quot;</span></span><br><span class="line">transtable = <span class="built_in">str</span>.maketrans(in_str, out_str)</span><br><span class="line"></span><br><span class="line">print(a.translate(transtable))</span><br><span class="line">&gt;&gt;</span><br><span class="line">i liky manything rylaxing!</span><br></pre></td></tr></table></figure>

<hr>
<p><code>str</code>类型的其他方法都支持<code>bytes</code>和<code>bytearray</code>类型</p>
<p><strong>二进制序列并不是指字节序列全是二进制编码,而是指用于计算机存储和传播的二进制字节序列即字节序列,其本质上还是整数序列</strong></p>
<ul>
<li>在<code>ASCII</code>中<code>K</code>表示十进制</li>
<li><code>1k</code>表示十进制<code>1</code></li>
</ul>
<hr>
<p>构建<code>bytes</code>或<code>bytearray</code>实例还可以调用各自的构造方法,传参如下:</p>
<ul>
<li>一个<code>str</code>对象(码位)和<code>encoding</code>关键字参数(编码规则)</li>
<li>一个可迭代对象, 提供<code>0~255</code>数值</li>
<li>一个实现缓冲协议的对象<code>(bytes bytearray memoryview array.array)</code> 此时把源对象中的字节序列复制到新建的二进制序列中</li>
</ul>
<p>注意使用缓冲类对象构建二进制序列是一个底层操作,可能涉及类型转换</p>
<p><strong>下面是将<code>array.array</code>转化成字节序列表示</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> array</span><br><span class="line"><span class="comment"># 创建一个短整数16位数组</span></span><br><span class="line">numbers = array.array(<span class="string">&#x27;h&#x27;</span>, [-<span class="number">2</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line"><span class="comment"># 保存组成的numbers的字节序列副本</span></span><br><span class="line">to_bytes = <span class="built_in">bytes</span>(numbers)</span><br><span class="line"><span class="comment"># 表示5个短整数的10个字节</span></span><br><span class="line">print(to_bytes)</span><br><span class="line">&gt;&gt;</span><br><span class="line"><span class="string">b&#x27;\xfe\xff\xff\xff\x00\x00\x01\x00\x02\x00&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个空array接收bytes</span></span><br><span class="line"><span class="comment"># 并输出结构化的bytes</span></span><br><span class="line">temp_array = array.array(<span class="string">&#x27;h&#x27;</span>)</span><br><span class="line">print(temp_array.frombytes(to_bytes))</span><br><span class="line">print(temp_array)</span><br><span class="line">&gt;&gt;</span><br><span class="line"><span class="literal">None</span></span><br><span class="line">array(<span class="string">&#x27;h&#x27;</span>, [-<span class="number">2</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>])</span><br></pre></td></tr></table></figure>

<p><strong>需要注意</strong></p>
<ul>
<li><p><strong>使用缓冲类对象<code>(bytes bytearray array.array memoryview)</code>创建<code>bytes</code> <code>bytearray</code>对象时, 始终复制的是源对象中的字节序列</strong></p>
</li>
<li><p>不过<code>memoryview</code>对象允许在二进制数据结构之间共享内存</p>
</li>
<li><p>从二进制序列提取结构化信息需要<code>struct</code>模块</p>
</li>
</ul>
<h3 id="4-2-2-结构体和内存视图"><a href="#4-2-2-结构体和内存视图" class="headerlink" title="4.2.2 结构体和内存视图"></a>4.2.2 结构体和内存视图</h3><p><code>struct</code>模块提供了一些函数, 把打包的字节序列转换成不同类型字段组成的元组,还有一些函数用于执行反向转换,把元组转化成打包的字节序列.可以处理<code>bytes</code> <code>bytearray</code> <code>memoryview</code>对象</p>
<p><strong>注意</strong>:</p>
<p><code>memoryview</code>类不是用于创建或存储字节序列的, 而是共享内存,让你访问其他二进制序列 打包的数组和缓冲中的数据切片,而无需复制字节序列</p>
<p><strong>memoryview 对象的切片是一个新 memoryview 对象，而且不会复制字节序列</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="comment"># 结构体格式: &lt; 小字节序列</span></span><br><span class="line"><span class="comment">#		  3s3s 俩个3字节序列</span></span><br><span class="line"><span class="comment">#         HH   俩个16位二进制整数</span></span><br><span class="line">fmt = <span class="string">&quot;&lt;3s3sHH&quot;</span></span><br><span class="line">whith <span class="built_in">open</span>(<span class="string">&quot;filter.gif&quot;</span>, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">    <span class="comment"># 使用内存中的文件内容创建一个memoryview对象</span></span><br><span class="line">    img = <span class="built_in">memoryview</span>(fp.read())</span><br><span class="line"><span class="comment"># 使用他的切片再创建一个mv对象(这里不会复制字节序列)</span></span><br><span class="line">header = img[:<span class="number">10</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转化成字节序列(10字节)</span></span><br><span class="line"><span class="built_in">bytes</span>(header)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拆包mv对象获得一个元组包括类型 版本 宽度 高度</span></span><br><span class="line">struct.unpack(fmt, header)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除引用 释放mv实列占用的内存</span></span><br><span class="line"><span class="keyword">del</span> header</span><br><span class="line"><span class="keyword">del</span> img</span><br></pre></td></tr></table></figure>

<p>如果经常处理二进制数据推荐阅读:</p>
<p><strong><a target="_blank" rel="noopener" href="https://docs.python.org/3/library/stdtypes.html#memory-views">memoryview</a></strong></p>
<p><a target="_blank" rel="noopener" href="https://docs.python.org/3/library/struct.html"><strong>struct interpret bytes as packed binary data</strong></a></p>
<h2 id="4-3-基本的编解码器"><a href="#4-3-基本的编解码器" class="headerlink" title="4.3 基本的编解码器"></a>4.3 基本的编解码器</h2><blockquote>
<p>python自带了超过100种编解码器(编码算法)用于在文本和字节之间相互转换</p>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/496D8BAFE68A48610FC47DBC7BB2A83F.png" style="zoom:150%;" />

<p>其中后三者是可变长度的多字节编码, 其余都是单字节编码</p>
<p>图中星号表示某些编码(<code>ASCII</code>和多字节编码<code>GB2312</code>)不能表示所有的<code>Unicode</code>字符, <code>UTF</code>编码的设计目的是处理每一个<code>Unicode</code>码位</p>
<h2 id="4-4-编解码问题"><a href="#4-4-编解码问题" class="headerlink" title="4.4 编解码问题"></a>4.4 编解码问题</h2><blockquote>
<p>编解码涉及到<code>unicode</code>或者<code>string</code>或称<code>码位</code>与<code>byte</code>的编解码转换</p>
</blockquote>
<p>编解码异常有三种:</p>
<p><strong>1.UnicodeEncodeError</strong></p>
<p><code>str</code>转<code>byte</code>异常</p>
<p><strong>2.UnicodeDecodeError</strong></p>
<p><code>byte</code>转<code>str</code>异常</p>
<p><strong>3.SynatxError</strong></p>
<p>如果在编解码中,源码的编码与预期不符, 在加载模块时会抛出语法异常</p>
<h3 id="4-4-1-UnicodeEncodeError"><a href="#4-4-1-UnicodeEncodeError" class="headerlink" title="4.4.1 UnicodeEncodeError"></a>4.4.1 UnicodeEncodeError</h3><h3 id="4-4-2-UnicodeDecodeError"><a href="#4-4-2-UnicodeDecodeError" class="headerlink" title="4.4.2 UnicodeDecodeError"></a>4.4.2 UnicodeDecodeError</h3><h3 id="4-4-3-SyntaxError"><a href="#4-4-3-SyntaxError" class="headerlink" title="4.4.3 SyntaxError"></a>4.4.3 SyntaxError</h3><blockquote>
<p>多数非<code>UTF</code>编解码器只能处理<code>Unicode</code>字符的一小部分子集, 把文本转化成字节序列时, 如果目标编码中没有定义某个字符就会抛该异常, 处理方式是把<code>errors</code>参数传给编码方法或函数,对错误进行特殊处理</p>
</blockquote>
<blockquote>
<p>不是每个字节都包含有效的ASCII字符,也不是每个字符序列都是有效<code>UTF-8</code> 或<code>UTF-16</code> 因此,在把二进制序列转化成文本时, 如果假设是这俩个编码中的一个, 遇到无法转换的字节序列时会抛出UnicodeDecodeError</p>
</blockquote>
<p><strong>str.en|decode(encoding=””, errors=””)</strong></p>
<p><code>errors</code>接收四个参数</p>
<ul>
<li><p>strict: 遇到无法编码的字符raise error</p>
</li>
<li><p>ignore: 忽略不能编码的字符</p>
</li>
<li><p>replace: 使用<code>?</code>代替不能编码的字符</p>
</li>
<li><p>xmlcharrefreplace: 把无法编码的字符替换成XML实体</p>
</li>
</ul>
<p>需要注意的是errors接受的参数是可以扩展的, 你可以位errors参数注册额外的字符串方法<code>codecs.register_error</code>函数</p>
<ul>
<li>python3允许在源码中使用非ASCII标识符</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">β = <span class="number">1</span></span><br><span class="line">print(β)</span><br></pre></td></tr></table></figure>

<h3 id="4-4-4-找出字节序列编码"><a href="#4-4-4-找出字节序列编码" class="headerlink" title="4.4.4 找出字节序列编码"></a>4.4.4 找出字节序列编码</h3><blockquote>
<p>简单的说一般找不出字节序列的编码, 有些通讯协议和文件格式, 比如 HTTP和XML包含<strong>明确指明内容编码的首部</strong>. 可以肯定的是, 某些字节流不是ASCII, 因为其中包含大于127的字节值, 而且制定UTF-8和UTF-16的方式也限制了可用的字节序列.即使如此我们也无法根据特定的位模式来确定二进制文件的编码时ASCII或UTF-8</p>
</blockquote>
<p>  统一字符编码侦测包<code>Chartdetect</code>,可以识别30中编码</p>
<p>二进制序列编码通常不会指明自己的编码, 但是<code>UTF</code>格式可以在文本内容的开头添加一个字节序列标记</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> chardet</span><br><span class="line">a = chardet.detect(<span class="string">b&quot;sddssfsd&quot;</span>)</span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line">&#123;<span class="string">&#x27;encoding&#x27;</span>: <span class="string">&#x27;ascii&#x27;</span>, <span class="string">&#x27;confidence&#x27;</span>: <span class="number">1.0</span>, <span class="string">&#x27;language&#x27;</span>: <span class="string">&#x27;&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-4-5-BOM有用的鬼符"><a href="#4-4-5-BOM有用的鬼符" class="headerlink" title="4.4.5 BOM有用的鬼符"></a>4.4.5 BOM有用的鬼符</h3><blockquote>
<p>BOM (bytes-Order-Mark)字节序列标记, 指明编码时使用的是IntelGPU的小子节序</p>
</blockquote>
<ul>
<li><code>utf-16</code>有俩种编码格式<code>UTF-16LE</code>小子节序<code>UTF-6BE</code>大字节序</li>
<li>小子节序各个码位的最低有效字节在前面, 大字节序相反(Unicode码位)</li>
<li>因此在<code>utf-16</code>编码中使用开头的BOM<code>b&#39;\xff\xfe&#39;</code>十进制(255 254)表示小子节编码</li>
<li><code>utf-8</code>无论设备使用哪种字节序,生成的字节序列始终一致, 因此不需要BOM</li>
</ul>
<h2 id="4-5-处理文本文件"><a href="#4-5-处理文本文件" class="headerlink" title="4.5 处理文本文件"></a>4.5 处理文本文件</h2><p><img src="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/20220320144303.png"></p>
<p>处理文本文件最好的方式是三明治处理法, 首先将输入的字节序列转码成字符串, 在对字符串进行处理, 最后把处理好的字符串编码成字节序列进行输出</p>
<p><code>Python3</code>中的<code>Open</code>函数会在读取文本进行必要的解码, 在以文本模式写入文件时也会进行必要的编码, 所以<code>my_file.read()</code>方法得到的以及传递给<code>my_file.write(text)</code>方法的都是字符串对象</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用utf-8编码打开(创建)txt文件, 模式位写</span></span><br><span class="line"><span class="comment"># 此时使用open函数创建一个TextIowrapper对象</span></span><br><span class="line">fp = <span class="built_in">open</span>(<span class="string">&quot;text.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">print(fp)</span><br><span class="line">&lt;_io.TextIOWrapper name=<span class="string">&#x27;text.txt&#x27;</span> mode=<span class="string">&#x27;w&#x27;</span> encoding=<span class="string">&#x27;utf-8&#x27;</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将字符串对象写入TextIo对象中</span></span><br><span class="line">fp.write(<span class="string">&quot;Drink&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭TextIo对象</span></span><br><span class="line">fp.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="comment"># 调用系统stat,查看路径文件的字节大小</span></span><br><span class="line">print(os.stat(<span class="string">&quot;text.txt&quot;</span>).st_size)</span><br><span class="line"><span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开文本文件, 返回一个TextIoWrapper对象</span></span><br><span class="line"><span class="comment"># 编码是区域设置中的默认值</span></span><br><span class="line">fp2 = <span class="built_in">open</span>(<span class="string">&quot;text.txt&quot;</span>)</span><br><span class="line"><span class="comment"># TextIO对象有encoding属性, 查看所使用的编码</span></span><br><span class="line">print(fp2.encoding)</span><br><span class="line">cp936</span><br><span class="line">fp2.read()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以特定的编码方式打开文本文件流</span></span><br><span class="line">fp3 = <span class="built_in">open</span>(<span class="string">&quot;text.txt&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">fp3.read()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用open函数创建一个BytesIoWrapper对象</span></span><br><span class="line">fp4 = <span class="built_in">open</span>(<span class="string">&quot;text.txt&quot;</span>, <span class="string">&quot;rb&quot;</span>)</span><br><span class="line"><span class="comment"># 在二进制模式即字节流中返回的是BufferedReader对象</span></span><br><span class="line"><span class="comment"># 其满足buffer-protocol协议</span></span><br><span class="line">print(fp4)</span><br><span class="line">&lt;_io.BufferedReader name=<span class="string">&#x27;text.txt&#x27;</span>&gt;</span><br><span class="line">fp4.read()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>除非想要判断编码否则不要使用二进制模式打开文本文件, 即便想要查看编码类型也不要重复发明轮子, 可以使用chardet</p>
</blockquote>
<p><strong>通常不建议使用默认编码方式取处理二进制或文本流</strong></p>
<h3 id="编码默认值"><a href="#编码默认值" class="headerlink" title="编码默认值"></a>编码默认值</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> locale</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">expressions = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    locale.getpreferredencoding()</span></span><br><span class="line"><span class="string">    type(my_file)</span></span><br><span class="line"><span class="string">    sys.stdout.isatty()</span></span><br><span class="line"><span class="string">    sys.stdout.encoding</span></span><br><span class="line"><span class="string">    sys.stdin.isatty()</span></span><br><span class="line"><span class="string">    sys.stdin.encoding</span></span><br><span class="line"><span class="string">    sys.stderr.isatty()</span></span><br><span class="line"><span class="string">    sys.stderr.encoding</span></span><br><span class="line"><span class="string">    sys.getdefaultencoding()</span></span><br><span class="line"><span class="string">    sys.getfilesystemencoding()</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">my_file = <span class="built_in">open</span>(<span class="string">&#x27;dummy&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> expression <span class="keyword">in</span> expressions.split():</span><br><span class="line">    value = <span class="built_in">eval</span>(expression)</span><br><span class="line">    print(expression.rjust(<span class="number">30</span>), <span class="string">&quot;--&gt;&quot;</span>, <span class="built_in">repr</span>(value))</span><br><span class="line"></span><br><span class="line">sys.stdin.isatty()</span><br><span class="line">sys.stderr.isatty()</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">locale.getpreferredencoding() --&gt; &#x27;cp936&#x27;</span><br><span class="line">                type(my_file) --&gt; &lt;class &#x27;_io.TextIOWrapper&#x27;&gt;</span><br><span class="line">          sys.stdout.isatty() --&gt; False</span><br><span class="line">          sys.stdout.encoding --&gt; &#x27;UTF-8&#x27;</span><br><span class="line">           sys.stdin.isatty() --&gt; False</span><br><span class="line">           sys.stdin.encoding --&gt; &#x27;UTF-8&#x27;</span><br><span class="line">          sys.stderr.isatty() --&gt; False</span><br><span class="line">          sys.stderr.encoding --&gt; &#x27;UTF-8&#x27;</span><br><span class="line">     sys.getdefaultencoding() --&gt; &#x27;utf-8&#x27;</span><br><span class="line">  sys.getfilesystemencoding() --&gt; &#x27;utf-8&#x27;</span><br></pre></td></tr></table></figure>

<p><code>sys.getfilesystemencoding()</code>用于编解码文件名而非文件内容, 把字符串参数作为文件名传给<code>open()</code>函数会使用它, 如果是字节序列则直接传给<code>OS API</code></p>
<blockquote>
<p><code>locale.getprefferedencoding()</code>返回的编码即是打开文件的默认编码,同时也是重定向文件的<code>sys.stdout/stdin/stderr</code></p>
</blockquote>
<blockquote>
<p>不要依赖默认编码尤其是windows用户</p>
</blockquote>
<h2 id="4-6-规范化Unicode字符"><a href="#4-6-规范化Unicode字符" class="headerlink" title="4.6 规范化Unicode字符"></a>4.6 规范化Unicode字符</h2><blockquote>
<p>因为Unicode有组合字符(变音字符和附加到前一个字符上的记号, 打印时作为一个整体)所以字符串比较起来比较复杂</p>
</blockquote>
<p>比如<code>é</code>这个词, 是<code>e</code>后加<code>U+0301</code>得来的, 在<code>unicode</code>中称为标准等价物, 但是<code>python</code>看到的是不同的码位序列, 因此判断两者不相等, 这时就需要一个统一的标准, 来规范化<code>Unicode</code>就像规范两种方言一样</p>
<p>使用<code>unicodedata.normalize</code>函数</p>
<p>第一个参数:</p>
<ul>
<li><strong>NFC (Normalization Form C)</strong></li>
</ul>
<p>使用最少的码位构成等价的字符串</p>
<ul>
<li><strong>NFD</strong></li>
</ul>
<p>把组合字符分解成 [基字符] 和 [单独的组合字符]</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">s1 = <span class="string">&quot;café&quot;</span></span><br><span class="line">s2 = <span class="string">&quot;cafe\u3001&quot;</span></span><br><span class="line"></span><br><span class="line">print(unicodedata.normalize(<span class="string">&quot;NFC&quot;</span>, s1))</span><br><span class="line">print(unicodedata.normalize(<span class="string">&quot;NFC&quot;</span>, s2))</span><br><span class="line"></span><br><span class="line">print(unicodedata.normalize(<span class="string">&quot;NFD&quot;</span>, s1))</span><br><span class="line">print(unicodedata.normalize(<span class="string">&quot;NFD&quot;</span>, s2))</span><br><span class="line"></span><br><span class="line">café</span><br><span class="line">cafe、</span><br><span class="line">café</span><br><span class="line">cafe、</span><br></pre></td></tr></table></figure>

<blockquote>
<p>用户输入的文本默认是NFC格式, 在保存文本前, 最好使用normalization(“NFC”, text)清洗字符串</p>
<p>需要注意的是, 在使用NFC清洗字符串时, 有些单字符会被规范成另一个单字符, 比如电阻的单位Ω会被规范成欧米茄, 在视觉上是一样的, 但在比较时并不相等</p>
</blockquote>
<ul>
<li><p>NFKC</p>
</li>
<li><p>NFKD</p>
</li>
</ul>
<p><strong>这俩个规范化方法是兼容性规范化, 这些规范化更适合用在用户搜索或索引上, 需要注意的是, 经过NFKC或者NFKD兼容性规范化后的字符可能会丧失原本的意义, 尽量不要用于数据的持久化</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s3 = <span class="string">&quot;¼&quot;</span></span><br><span class="line">print(unicodedata.normalize(<span class="string">&quot;NFKC&quot;</span>, s3))</span><br><span class="line">&gt;&gt; <span class="number">1</span>/<span class="number">4</span></span><br></pre></td></tr></table></figure>

<h3 id="4-6-1-大小写折叠"><a href="#4-6-1-大小写折叠" class="headerlink" title="4.6.1 大小写折叠"></a>4.6.1 大小写折叠</h3><blockquote>
<p>即将所有的字符转化成小写, 相比于lower()只支持Unicode, casefold()支持更多的大小写转化, 尽管如此, 两者不同的字符仅有116个码位, 占比0.11%</p>
</blockquote>
<h3 id="4-6-2-规范化文本匹配实用函数"><a href="#4-6-2-规范化文本匹配实用函数" class="headerlink" title="4.6.2 规范化文本匹配实用函数"></a>4.6.2 规范化文本匹配实用函数</h3><blockquote>
<p>NFC和NFD可以很合理的比较Unicode字符串, 并且NFC是最好的规范化形式, 不区分大小写应该使用casefold()</p>
</blockquote>
<p><strong>1.去掉变音字符号</strong></p>
<blockquote>
<p>unicodedata.combining (unichr) <strong>将分配给Unicode字符 unichr 的规范组合类 返回 为整数</strong>。 如果未定义组合类，则返回 0 。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> unicodedata <span class="keyword">import</span> normalize</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shave_marks</span>(<span class="params">txt</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    去掉所有的变音符号</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 把所有的字符拆成基字符和组合记号</span></span><br><span class="line">    norm_txt = unicodedata.normalize(<span class="string">&quot;NFD&quot;</span>, txt)</span><br><span class="line">    <span class="comment"># 过滤掉所有组合记号</span></span><br><span class="line">    shaved = <span class="string">&quot;&quot;</span>.join(c <span class="keyword">for</span> c <span class="keyword">in</span> norm_txt <span class="keyword">if</span> <span class="keyword">not</span> unicodedata.combining(c))</span><br><span class="line">    <span class="comment"># 重组所有字符</span></span><br><span class="line">    <span class="keyword">return</span> unicodedata.normalize(<span class="string">&quot;NFC&quot;</span>, shaved)</span><br></pre></td></tr></table></figure>

<p><strong>2.比较字符是否相等|忽略大小写</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> unicodedata <span class="keyword">import</span> normalize</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nfc_equal</span>(<span class="params">str1, str2</span>):</span></span><br><span class="line">    <span class="keyword">return</span> normalize(<span class="string">&quot;NFC&quot;</span>, str1) == normalize(<span class="string">&quot;NFC&quot;</span>, str2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fold_equal</span>(<span class="params">str1, str2</span>):</span></span><br><span class="line">    <span class="keyword">return</span> (normalize(<span class="string">&quot;NFC&quot;</span>, str1).casefold() == </span><br><span class="line">            normalize(<span class="string">&quot;NFC&quot;</span>, str2).casefold())</span><br></pre></td></tr></table></figure>

<h2 id="4-7-Unicode文本排序"><a href="#4-7-Unicode文本排序" class="headerlink" title="4.7 Unicode文本排序"></a>4.7 Unicode文本排序</h2><blockquote>
<p>对于ASCII字符串来说比较的是码位, 但在非ASCII字符时会使用locale.strxfrm函数, 这个函数会把string转化成适合的区域进行比较</p>
</blockquote>
<p>需要注意的是, 一般情况下, 变音符不会对排序造成影响, 如果有影响, 变音符号常常排在常规词后面</p>
<p>在使用locale.strxfrm函数作为排序key前, 要先调用setlocale(LC_COLLATE, your_locale)</p>
<p>需要注意:</p>
<ol>
<li>区域设置是全局的, 不建议库中调用, 且应用或框架应该在进程中调用</li>
<li>操作系统必须支持区域设置</li>
</ol>
<p><strong>使用unicode排序算法排序</strong></p>
<p><code>pyuca</code> </p>
<blockquote>
<p>Python Unicode Collator Algorithm</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pyuca</span><br><span class="line"></span><br><span class="line">coll = pyuca.Collator()</span><br><span class="line">fruits = [<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;alle&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;bba&quot;</span>]</span><br><span class="line">sorted_fruits = <span class="built_in">sorted</span>(fruits, key=coll.sort_key)</span><br><span class="line">print(sorted_fruits)</span><br></pre></td></tr></table></figure>

<h2 id="4-8-Unicode-数据库"><a href="#4-8-Unicode-数据库" class="headerlink" title="4.8 Unicode 数据库"></a>4.8 Unicode 数据库</h2><blockquote>
<p>本质上已经一个关于unicode以及个中映射关系的数据库, 就如码位与string bytes的映射一样, 同样基于此提供了许多双模式API对外调用, 出名的有unicodedata</p>
</blockquote>
<p><strong>regex库正在替代re库</strong></p>
<p><strong>双模式API是一个趋势</strong>: 即支持字符和字节参数,并根据参数的格式做出自适应的调整</p>
<h2 id="4-9-支持str和bytes的双模式API"><a href="#4-9-支持str和bytes的双模式API" class="headerlink" title="4.9 支持str和bytes的双模式API"></a>4.9 支持str和bytes的双模式API</h2><blockquote>
<p>标准库中一些函数能接受字符串或字节序列作为参数, 然后根据类型自适应做不同的行为, 其中re和os为例</p>
</blockquote>
<h3 id="4-9-1-正则str和bytes"><a href="#4-9-1-正则str和bytes" class="headerlink" title="4.9.1 正则str和bytes"></a>4.9.1 正则str和bytes</h3><table>
<thead>
<tr>
<th></th>
<th>unicode</th>
<th>bytes</th>
<th>次数|注</th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td></td>
<td></td>
<td>{0,}</td>
</tr>
<tr>
<td>+</td>
<td></td>
<td></td>
<td>{1,}</td>
</tr>
<tr>
<td>?</td>
<td></td>
<td></td>
<td>{0,1}</td>
</tr>
<tr>
<td>\d</td>
<td>匹配任何一个十进制数字, 包括[0-9]和其他数字字符</td>
<td>只匹配[0-9]</td>
<td>和re.ASCII</td>
</tr>
<tr>
<td>\w</td>
<td>任何Unicode字符, 所有语言|数字|下横线</td>
<td>[a-zA-A0-9]</td>
<td>和re.ASCII一样</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">re_numbers_str = re.<span class="built_in">compile</span>(<span class="string">r&quot;\d+&quot;</span>)</span><br><span class="line">re_words_str = re.<span class="built_in">compile</span>(<span class="string">r&quot;\w+&quot;</span>)</span><br><span class="line"></span><br><span class="line">re_numbers_bytes = re.<span class="built_in">compile</span>(<span class="string">rb&quot;\d+&quot;</span>)</span><br><span class="line">re_words_bytes = re.<span class="built_in">compile</span>(<span class="string">rb&quot;\w+&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里会默认拼接str</span></span><br><span class="line">text_str = <span class="string">&quot;Drink see \u0be7\u0be6\u0be5\u0be4&quot;</span> <span class="string">&quot;as 1999 = 1000 + 999&quot;</span></span><br><span class="line"></span><br><span class="line">text_bytes = text_str.encode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;TEXT&quot;</span>, <span class="built_in">repr</span>(text_str), sep=<span class="string">&quot;\n &quot;</span>)</span><br><span class="line">print(<span class="string">&quot;NUMBERS&quot;</span>)</span><br><span class="line">print(<span class="string">&quot;  str  :&quot;</span>, re_numbers_str.findall(text_str))</span><br><span class="line">print(<span class="string">&quot;  bytes:&quot;</span>, re_numbers_bytes.findall(text_bytes))</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;WORDS&quot;</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;  str  :&quot;</span>, re_words_str.findall(text_str))</span><br><span class="line">print(<span class="string">&quot;  bytes:&quot;</span>, re_words_bytes.findall(text_bytes))</span><br><span class="line"></span><br><span class="line">&gt;&gt;</span><br><span class="line">TEXT</span><br><span class="line"> <span class="string">&#x27;Drink see ௧௦\u0be5\u0be4as 1999 = 1000 + 999&#x27;</span></span><br><span class="line">NUMBERS</span><br><span class="line">  <span class="built_in">str</span>  : [<span class="string">&#x27;௧௦&#x27;</span>, <span class="string">&#x27;1999&#x27;</span>, <span class="string">&#x27;1000&#x27;</span>, <span class="string">&#x27;999&#x27;</span>]</span><br><span class="line">  <span class="built_in">bytes</span>: [<span class="string">b&#x27;1999&#x27;</span>, <span class="string">b&#x27;1000&#x27;</span>, <span class="string">b&#x27;999&#x27;</span>]</span><br><span class="line">WORDS</span><br><span class="line">  <span class="built_in">str</span>  : [<span class="string">&#x27;Drink&#x27;</span>, <span class="string">&#x27;see&#x27;</span>, <span class="string">&#x27;௧௦&#x27;</span>, <span class="string">&#x27;as&#x27;</span>, <span class="string">&#x27;1999&#x27;</span>, <span class="string">&#x27;1000&#x27;</span>, <span class="string">&#x27;999&#x27;</span>]</span><br><span class="line">  <span class="built_in">bytes</span>: [<span class="string">b&#x27;Drink&#x27;</span>, <span class="string">b&#x27;see&#x27;</span>, <span class="string">b&#x27;as&#x27;</span>, <span class="string">b&#x27;1999&#x27;</span>, <span class="string">b&#x27;1000&#x27;</span>, <span class="string">b&#x27;999&#x27;</span>]</span><br></pre></td></tr></table></figure>

<h3 id="4-9-2-os中的字符串和字节序列"><a href="#4-9-2-os中的字符串和字节序列" class="headerlink" title="4.9.2 os中的字符串和字节序列"></a>4.9.2 os中的字符串和字节序列</h3><blockquote>
<p>GNU/linux内核不理解Unicode, 因此文件名中使用字节序列都是无效的</p>
</blockquote>
<p>为了方便处理字符串或字节序列形式的文件名或路径名, os模块提供了特殊的编码和解码函数</p>
<p><strong>fsencode(filename)</strong></p>
<p>当filename是str时使用<code>sys.getfilesystemencoding()</code>编码成bytes</p>
<p><strong>fsdecode(filename)</strong></p>
<p>当filename是bytes时使用<code>sys.getfilesystemencoding()</code>解码成str</p>
<blockquote>
<p>在unix及其衍生平台中使用<code>surrogateescape</code>错误处理方式, 避免碰到意外字节卡住, windows使用strict, 这种处理方式在py3.1时被引进</p>
</blockquote>
<p>这种错误的处理方式实际上是将无法编码的字节替换成<code>Unicode</code>中<code>U+DC00</code>到<code>U+DCFF</code>之间的码位<code>(low surrogate area)</code>, 这些码位是保留的,没有分配字符, 只供程序内部使用</p>
<h2 id="4-10-本章小结"><a href="#4-10-本章小结" class="headerlink" title="4.10 本章小结"></a>4.10 本章小结</h2><p>1.一个字符不等于一个字节, 两者的对应关系取决于编码所用的算法</p>
<p>2.chardet包可以在没有元数据的情况下检测编码的大概方法</p>
<p>3.在str-bytes的编解码中, 避免使用系统默认编解码</p>
<p>4.文本比较由于编解码的不同, 在比较之前需要进行规范化和大小写折叠</p>
<p>5.双模式API的自适应调整是以后的趋势</p>
<p><strong>杂谈</strong></p>
<p><strong>Q1:纯文本是什么?</strong></p>
<p>A: 由特定标准的码位序列组成的没有任何字节表示除文本之外的信息的结构化或非结构化计算机编码文本</p>
<p><strong>Unicode从广义上讲比较复杂, 因为要面对多种实际情况, 但在日常使用中不需要有这种担心</strong></p>
<p><strong>Q2:在RAM中表示字符串</strong></p>
<p>A: 在内存中, 使用固定数量的字节序列存储字符串的各个码位, 在py3.3之前, 编译Cpython时可以配置在内存中使用16|32位, 存储各个码位</p>
<ul>
<li>16: 窄构建 sys.maxunicode 65535</li>
<li>32: 宽构建</li>
</ul>
<p>从py3.3后, 创建str对象时, 解释器会检查里面的字符并自适应选择最适合的内存布局</p>
<h1 id="Part5-Fun-is-Obj"><a href="#Part5-Fun-is-Obj" class="headerlink" title="Part5 Fun is Obj"></a>Part5 Fun is Obj</h1><h2 id="5-0-1st-Fun"><a href="#5-0-1st-Fun" class="headerlink" title="5.0 1st Fun"></a>5.0 1st Fun</h2><p>在python中函数被称为一等对象</p>
<ul>
<li>在运行时创建</li>
<li>能赋值给变量或数据结构中的元素</li>
<li>能作为参数传给函数</li>
<li>能作为函数的返回结果</li>
</ul>
<p>我们熟悉的int float string dict都属于一等对象</p>
<p>在python中所有函数都是一等对象</p>
<p><strong>DocStrings</strong> 文档字符串是一个重要工具，用于解释文档程序，帮助你的程序文档更加简单易懂。</p>
<p>我们可以在函数体的第一行使用一对三个单引号 <strong>‘’’</strong> 或者一对三个双引号 <strong>“””</strong> 来定义文档字符串。</p>
<p>你可以使用 <strong><strong>doc</strong></strong>（注意双下划线）调用函数中的文档字符串属性。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    test function</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">if</span> n &lt; <span class="number">2</span> <span class="keyword">else</span> n * test(n-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">print(test.__doc__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将函数赋值给变量</span></span><br><span class="line">fact = test</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过变量调用函数</span></span><br><span class="line">print(fact(<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># treat fun as params</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">map</span>(fact, [<span class="number">10</span>, <span class="number">1</span>]):</span><br><span class="line">    print(i)</span><br><span class="line">&gt;&gt;</span><br><span class="line">test function</span><br></pre></td></tr></table></figure>

<h2 id="5-2-Higher-Order-Fun"><a href="#5-2-Higher-Order-Fun" class="headerlink" title="5.2 Higher Order Fun"></a>5.2 Higher Order Fun</h2><blockquote>
<p>接受函数为参数或者把函数作为结果返回的函数都是高阶函数(Higher-Order-Functions), 常见的有map sorted filter reduce apply(已经过时|使用不定量的参数调用函数, 已经使用解包代替)</p>
<p>为了使高阶函数具有更多的可读性, 一般会在高阶函数中使用匿名函数</p>
</blockquote>
<p><strong>reduce()</strong> 函数会对参数序列中元素进行累积。</p>
<p>函数将一个数据集合（链表，元组等）中的所有数据进行下列操作：用传给 reduce 中的函数 function（有两个参数）先对集合中的第 1、2 个元素进行操作，得到的结果再与第三个数据用 function 函数运算，最后得到一个结果。</p>
<p><strong>注意：</strong><code>Python3.x reduce()</code> 已经被移到 <code>functools</code> 模块里，如果我们要使用，需要引入 <code>functools</code> 模块来调用 <code>reduce()</code> 函数：</p>
<ul>
<li>此函数多用求和</li>
<li>现在已经出现<code>sum()</code>内置函数代替此函数</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br></pre></td></tr></table></figure>

<h2 id="5-3-匿名函数"><a href="#5-3-匿名函数" class="headerlink" title="5.3 匿名函数"></a>5.3 匿名函数</h2><blockquote>
<p>lambda用于创建匿名函数</p>
</blockquote>
<ul>
<li>使用<code>lambda</code>创建</li>
<li>多用作高阶函数的传参函数</li>
<li><code>lambda</code>函数十分简单, 无法在定义体中赋值, 也不能使用<code>while</code> <code>try</code>等函数</li>
<li>建议除了给高级函数作为传参函数外, 不要过度使用匿名函数</li>
</ul>
<p>需要注意: <code>lambda</code>和<code>def</code>一样都会创建一个函数对象</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">45</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">23</span>]</span><br><span class="line"></span><br><span class="line">b = <span class="built_in">filter</span>(<span class="keyword">lambda</span> x: x &gt; <span class="number">19</span>, a)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> b:</span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line">c = functools.reduce(<span class="keyword">lambda</span> x, y: x + y, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">print(c)</span><br><span class="line"></span><br><span class="line">d = <span class="built_in">all</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: x &gt; <span class="number">10</span>, [<span class="number">1</span>, <span class="number">10</span>, <span class="number">11</span>]))</span><br><span class="line">print(d)</span><br><span class="line"></span><br><span class="line">f = <span class="built_in">any</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: x &gt; <span class="number">10</span>, [<span class="number">1</span>, <span class="number">10</span>, <span class="number">11</span>]))</span><br><span class="line">print(f)</span><br><span class="line">&gt;&gt;</span><br><span class="line"><span class="number">45</span></span><br><span class="line"><span class="number">23</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h2 id="5-4-可调用对象"><a href="#5-4-可调用对象" class="headerlink" title="5.4 可调用对象"></a>5.4 可调用对象</h2><blockquote>
<p>除了用户自定义的函数, 调用运算符<code>()</code>还可以用在其他对象上, 如果要判断一个函数是否可以调用, 可以使用<code>callable()</code></p>
</blockquote>
<p>python中的可调用对象可以分为以下几类:</p>
<ul>
<li>自定义的<code>def</code> 或 <code>lambda</code></li>
<li>内置函数: <code>Cpython</code>实现的函数如<code>len</code> <code>time.strftime</code></li>
<li>内置方法: 使用<code>C</code>语言实现的, 比如<code>dict.get</code></li>
<li>类定义体中定义的函数</li>
<li>类: 调用类会运行类的<code>__new__</code>创建一个实例, 之后运行<code>__init__</code>初始化实例, 最后把实例返回给调用方</li>
<li>类的实例: 在类中定义了<code>__call__</code></li>
<li>生成器函数: <code>yield</code> 的关键字函数或方法, 生成器函数往往返回生成器对象</li>
</ul>
<p>注意的是: 生成器函数在很多方面与其他可调用对象不同, 生成器函数还可以作为协程来使用</p>
<h2 id="5-5-定义的可调用类型"><a href="#5-5-定义的可调用类型" class="headerlink" title="5.5 定义的可调用类型"></a>5.5 定义的可调用类型</h2><blockquote>
<p>python其实模糊了类和函数的界限, 要实现内部call的magic method, 在实现这个magic mthod时需要在内部维护一个状态, 让它在调用之间可用, 通常使用俩种方法 –&gt;  闭包 | 装饰器</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Callable Obj</span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BingoCage</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, items</span>):</span></span><br><span class="line">        <span class="comment"># 根据PEP规范软性约束属性为私用属性|内部使用|import * 执行|解释器不强制执行</span></span><br><span class="line">        self._elems = <span class="built_in">list</span>(items)</span><br><span class="line">        random.shuffle(self._elems)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pick</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> self._elems.pop()</span><br><span class="line">        <span class="keyword">except</span> IndexError:</span><br><span class="line">            <span class="keyword">return</span> LookupError(<span class="string">&quot;pick from empty BingoCage!&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.pick()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bingo = BingoCage(<span class="built_in">range</span>(<span class="number">5</span>))</span><br><span class="line">print(bingo.pick())</span><br></pre></td></tr></table></figure>

<h2 id="5-6-函数内省"><a href="#5-6-函数内省" class="headerlink" title="5.6 函数内省"></a>5.6 函数内省</h2><blockquote>
<p>内省: 即通过函数名, 可以得到函数的更多信息, 通常需要借助<code>fun_name.__doc__ </code> <code>dir(fun_name)</code></p>
</blockquote>
<h2 id="5-7-定位参数-关键词参数"><a href="#5-7-定位参数-关键词参数" class="headerlink" title="5.7 定位参数|关键词参数"></a>5.7 定位参数|关键词参数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tag</span>(<span class="params">name, *content, cls=<span class="literal">None</span>, **attrs</span>):</span></span><br></pre></td></tr></table></figure>

<p><code>name</code>: 定位参数, 当没有<code>key</code>时按照位置赋值</p>
<p><code>*content</code>: 接受除定位参数后的所有参数, 一般是一个可迭代对象, 并将这些参数解包成元组</p>
<p><code>cls=None</code>: 关键词参数, 一般需要设置一个<code>default_value</code></p>
<p><code>**attrs</code>: 关键词参数, 可以接受多个关键词, 通常使用字典封装</p>
<p><strong>定位参数</strong></p>
<ul>
<li><code>arg</code></li>
<li><code>*args</code>   common –&gt; tuple(iterator)</li>
</ul>
<p><strong>关键词参数</strong></p>
<ul>
<li><code>key=value</code></li>
<li><code>**dict </code> common –&gt; dict(Obj)</li>
</ul>
<p><strong>py3接受了一个特性, 只接受关键词参数|即只接受特定的key</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">a, *, b</span>):</span></span><br><span class="line">    print(a, b)</span><br><span class="line"></span><br><span class="line">f(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">&gt;&gt;</span><br><span class="line">TypeError: f() takes <span class="number">1</span> positional argument but <span class="number">2</span> were given</span><br><span class="line">    </span><br><span class="line">----------</span><br><span class="line">you should modify this function --&gt; f(1, b=2)</span><br></pre></td></tr></table></figure>

<h2 id="5-8-获取参数的信息"><a href="#5-8-获取参数的信息" class="headerlink" title="5.8 获取参数的信息"></a>5.8 获取参数的信息</h2><blockquote>
<p>获取函数对象的参数信息<code>__code__</code>可以获取参数的名字以及其他属性, 它本身返一个对象, 也有其他属性, <code>__defaults__</code>返回一个元组, 里面存储的是函数定位参数的缺省值, <code>__kwdefaults__</code>返回一个字典, 里面存储的关键词参数的缺省值</p>
</blockquote>
<blockquote>
<p>python中的代码对象是实现代码自省的重要概念, 代码对象通过<code>fun.__code__</code>访问</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">temp</span>(<span class="params">x=<span class="number">1</span>, y=<span class="number">2</span>, *, z=<span class="number">3</span></span>):</span></span><br><span class="line">    <span class="keyword">return</span> x, y, z</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">temp(<span class="number">1</span>, <span class="number">32</span>, z=<span class="number">3</span>)</span><br><span class="line">print(temp.__defaults__)</span><br><span class="line">print(temp.__kwdefaults__)</span><br><span class="line">print(temp.__code__.co_argcount)</span><br><span class="line">print(temp.__code__.co_varnames)</span><br><span class="line">&gt;&gt;</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">&#123;<span class="string">&#x27;z&#x27;</span>: <span class="number">3</span>&#125;</span><br><span class="line"><span class="number">2</span></span><br><span class="line">(<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;z&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>代码对象</strong></p>
<p>代码对象 <code>code object</code> 是一段可执行的 <code>Python</code> 代码在 <code>CPython</code> 中的内部表示。<br>可执行的 <code>Python</code> 代码包括：</p>
<ul>
<li>函数</li>
<li>模块</li>
<li>类</li>
<li>生成器表达式</li>
</ul>
<p>当你运行一段代码时，它被解析并编译成代码对象，随后被 <code>CPython</code> 虚拟机执行。<br>代码对象包含一系列直接操作虚拟机内部状态的指令。<br>这跟你在用<code> C</code> 语言编程时是类似的，你写出人类可读的文本，然后用编译器转换成二进制形式，二进制代码<code>C 的机器码或者是 Python 的字节码</code>被 CPU<code>对于 C 语言来说</code>或者<code> CPython</code> 虚拟机虚拟的 CPU 直接执行。</p>
<p>代码对象除了包含 指令，还提供了虚拟机运行代码所需要的一些 额外信息。</p>
<hr>
<p>在<code>Python 2</code>中，函数的代码对象通过 函数<code>.func_code</code> 来访问；而<code> Python 3</code> 中，则需要通过 函数<code>.__code__ </code>来访问。<br>Python 3 的代码对象增加了一个新属性 <code>co_kwonlyargcount</code>，对应强制关键字参数 <code>keyword-only argument</code>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/20220405202516.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">def clip(text, max_len&#x3D;80):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    clip the text in the first whitplace</span><br><span class="line">    :param text:</span><br><span class="line">    :param max_len:</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    end &#x3D; None</span><br><span class="line">    if len(text) &gt; max_len:</span><br><span class="line">        space_before &#x3D; text.rfind(&quot; &quot;, 0, max_len)</span><br><span class="line">        if space_before &gt;&#x3D; 0:</span><br><span class="line">            end &#x3D; space_before</span><br><span class="line">        space_after &#x3D; text.rfind(&quot; &quot;, max_len)</span><br><span class="line">        if space_after &gt;&#x3D; 0:</span><br><span class="line">            end &#x3D; space_after</span><br><span class="line">    if end is None:</span><br><span class="line">        end &#x3D; len(text)</span><br><span class="line">    return text[:end].rstrip()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 获取函数对象</span><br><span class="line">print(clip.__code__)</span><br><span class="line"># 获取函数的局部变量名</span><br><span class="line">print(clip.__code__.co_varnames)</span><br><span class="line"># 获取函数的定位参数数量</span><br><span class="line">print(clip.__code__.co_argcount)</span><br><span class="line"># 获取函数的字节码</span><br><span class="line">print(clip.__code__.co_code)</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/20220405203145.png"></p>
<p><strong>即使我们通过函数对象<code>__code__</code>实现了函数自省, 但是其数据和效率并不高, 而且所获取到的信息可读性比较差</strong></p>
<h3 id="inspect模块"><a href="#inspect模块" class="headerlink" title="inspect模块"></a><strong>inspect模块</strong></h3><blockquote>
<p>为了解决通过函数对象实现函数自省的效率和可读性问题, 我们可以通过<code>inspect</code>模块</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> inspect <span class="keyword">import</span> signature</span><br><span class="line">sig = signature(clip)</span><br><span class="line">print(sig)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name, param <span class="keyword">in</span> sig.parameters.items():</span><br><span class="line">    print(param.kind, <span class="string">&quot;:&quot;</span>, name, <span class="string">&quot;=&quot;</span>, param.default)</span><br><span class="line">&gt;&gt;</span><br><span class="line">(text, max_len=<span class="number">80</span>)</span><br><span class="line">POSITIONAL_OR_KEYWORD : text = &lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">inspect</span>.<span class="title">_empty</span>&#x27;&gt;</span></span><br><span class="line"><span class="class"><span class="title">POSITIONAL_OR_KEYWORD</span> :</span> max_len = <span class="number">80</span></span><br></pre></td></tr></table></figure>

<p><code>inspect.signature</code>函数返回一个<code>inspect.Signature</code>对象, 这个对象有个很重要的属性是<code>parameters</code>, 是一个有序映射, 可以把参数名和<code>inspect.Parameters</code>对应起来.</p>
<h4 id="Signature-Parameters"><a href="#Signature-Parameters" class="headerlink" title="Signature.Parameters"></a>Signature.Parameters</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看inspect.signature.parameters的数据</span></span><br><span class="line">print(sig.parameters)</span><br><span class="line">a = sig.parameters.items()</span><br><span class="line">&gt;&gt;</span><br><span class="line">OrderedDict([(<span class="string">&#x27;text&#x27;</span>, &lt;Parameter <span class="string">&quot;text&quot;</span>&gt;), (<span class="string">&#x27;max_len&#x27;</span>, &lt;Parameter <span class="string">&quot;max_len=80&quot;</span>&gt;)])</span><br><span class="line"></span><br><span class="line">odict_items([(<span class="string">&#x27;text&#x27;</span>, &lt;Parameter <span class="string">&quot;text&quot;</span>&gt;), (<span class="string">&#x27;max_len&#x27;</span>, &lt;Parameter <span class="string">&quot;max_len=80&quot;</span>&gt;)])</span><br></pre></td></tr></table></figure>

<p>各个<code>Parameters</code>也有自己独立的属性(封装在<code>inspect.signature.parameters</code>的有序映射里的对象体)</p>
<p><code>OrderedDict([(&#39;text&#39;, &lt;Parameter &quot;text&quot;&gt;)]</code>每个<code>&lt;Parameter&gt;</code></p>
<p><code>kind</code> : 函数对象的变量种类</p>
<p><code>name</code>: 函数对象的变量名字</p>
<p><code>default</code>: 函数对象的默认值</p>
<p><code>annotation</code>: 注解属性|提供函数签名元数据</p>
<h4 id="Signature-bind"><a href="#Signature-bind" class="headerlink" title="Signature.bind"></a>Signature.bind</h4><blockquote>
<p><code>inspect.Signature</code>对象有一个<code>bind</code>方法, 可以将任意参数绑定到签名中的形参上, 所用的规则与实参到形参的匹配方式一样, 可以使用此方法进行调用函数前的验参(验证是否少参|多参)</p>
</blockquote>
<p>1.<code>inspect.Signature</code>获取函数签名</p>
<p>2.讲特定函数签名通过<code>Signnature.bind(**params)</code>绑定进行验参</p>
<p>3.<strong>终端输出是否存在少参多参的情况</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_sign</span>(<span class="params">name, age, sex, *, book=<span class="string">&quot;Drink&quot;</span>, title</span>):</span></span><br><span class="line">    <span class="keyword">return</span> name, age, sex, book, title</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">params = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Drink&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">21</span>, <span class="string">&quot;sex&quot;</span>: <span class="string">&quot;man&quot;</span>, <span class="string">&quot;book&quot;</span>: <span class="string">&quot;StarFire&quot;</span>, <span class="string">&quot;title&quot;</span>: <span class="string">&quot;SINUO&quot;</span>, <span class="string">&quot;temp&quot;</span>: <span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line">check_params = signature(check_sign)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    temp_sign = check_params.bind(**params)</span><br><span class="line">    print(temp_sign)</span><br><span class="line">    <span class="keyword">for</span> name, value <span class="keyword">in</span> temp_sign.arguments.items():</span><br><span class="line">        print(name, <span class="string">&quot;=&quot;</span>, value)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    print(<span class="string">f&quot;-----error---&gt; something error <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">&gt;&gt;</span><br><span class="line">-----error---&gt; something error got an unexpected keyword argument &#x27;temp&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="5-9-函数注解"><a href="#5-9-函数注解" class="headerlink" title="5.9 函数注解"></a>5.9 函数注解</h2><blockquote>
<p>函数注解是python3的一种语法, 用于声明函数中的参数和返回值附加的元数据, 注解并不会对代码逻辑做任何处理, 只是将其作为[可视化]的元数据存储在函数对象的<code>__annotations__</code>属性里(表现形式是字典)</p>
</blockquote>
<p>注解如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 无注解形式</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clip</span>(<span class="params">text, max_len=<span class="number">80</span></span>):</span></span><br><span class="line"><span class="comment"># 注解形式</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clip</span>(<span class="params">text:<span class="built_in">str</span>, max_len:<span class="string">&#x27;int &gt; 0&#x27;</span>=<span class="number">80</span></span>) -&gt; str:</span></span><br></pre></td></tr></table></figure>

<ul>
<li>注解加在<code>par:</code>后, 一般声明参数类型</li>
<li>如果有默认值, 注解放在<code>par:</code>和<code>=</code>之间</li>
<li>python对注解所作的唯一件事是将其放在fun obj的<code>__annotation__</code>属性里</li>
<li>注解对python解释器没有任何意义, 注解只是元数据,供<code>IDE</code>框架和装饰器使用</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_ann</span>(<span class="params">name: <span class="built_in">str</span>, age: <span class="built_in">int</span>, book: <span class="built_in">str</span> = <span class="string">&#x27;StarFire&#x27;</span></span>) -&gt; str:</span></span><br><span class="line">    <span class="keyword">return</span> name, age, book</span><br><span class="line"></span><br><span class="line">print(test_ann.__annotations__)</span><br><span class="line">&gt;&gt;</span><br><span class="line">&#123;&#x27;name&#x27;: &lt;class &#x27;str&#x27;&gt;, &#x27;age&#x27;: &lt;class &#x27;int&#x27;&gt;, &#x27;book&#x27;: &lt;class &#x27;str&#x27;&gt;, &#x27;return&#x27;: &lt;class &#x27;str&#x27;&gt;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sign = signature(test_ann)</span><br><span class="line">print(sign.return_annotation)</span><br><span class="line"><span class="keyword">for</span> param <span class="keyword">in</span> sign.parameters.values():</span><br><span class="line">    <span class="comment"># note = repr(param.annotation)</span></span><br><span class="line">    note = param.annotation</span><br><span class="line">    print(note, <span class="string">&quot;:&quot;</span>, <span class="string">&quot;=&quot;</span>, param.default)</span><br><span class="line">&gt;&gt;</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">str</span>&#x27;&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> &#x27;<span class="title">str</span>&#x27;&gt; :</span> = &lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">inspect</span>.<span class="title">_empty</span>&#x27;&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> &#x27;<span class="title">int</span>&#x27;&gt; :</span> = &lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">inspect</span>.<span class="title">_empty</span>&#x27;&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> &#x27;<span class="title">str</span>&#x27;&gt; :</span> = StarFire</span><br></pre></td></tr></table></figure>

<p>1.<code>signature</code>函数返回一个<code>Signature</code>对象, 这个对象拥有<code>return_annotation</code>属性和<code>parameters</code>属性</p>
<p>2.<code>return_annotation</code>返回函数对象注解</p>
<p>3.<code>parameters</code>属性返回一个字典, 其中字典的key是参数, value是<code>Parameter</code>对象</p>
<p>4.每个<code>Parameter</code>对象有独属于自己的属性</p>
<h2 id="5-10-函数式编程"><a href="#5-10-函数式编程" class="headerlink" title="5.10 函数式编程"></a>5.10 函数式编程</h2><blockquote>
<p>Python的不目标并不是称为函数式编程语言, 但是<code>operator</code>和<code>functools</code>等包的支持让其函数式风格十分快捷</p>
</blockquote>
<h3 id="Operator"><a href="#Operator" class="headerlink" title="Operator"></a>Operator</h3><blockquote>
<p>其中绝大多数方法, 用于&lt;算术运算&gt;和&lt;代替匿名函数从序列中取出元素或读取对象&gt;, 即大多数其方法式实列化的匿名函数</p>
<p><strong>其用法就如该目录一样即提供函数式编程|换句话说是所返回的实例本质上式函数|创建函数</strong></p>
</blockquote>
<p><strong>1.算数运算</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> operator <span class="keyword">import</span> mul</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fact</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">return</span> reduce(<span class="keyword">lambda</span> a, b: a * b, <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># optimization</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fact</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">return</span> reduce(mul, <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>))</span><br></pre></td></tr></table></figure>

<p><strong>2.itemgetter取值</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> operator <span class="keyword">import</span> itemgetter</span><br></pre></td></tr></table></figure>

<p><strong>3.attrgetter取值</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> operator <span class="keyword">import</span> attrgetter</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">header = [<span class="string">&quot;name&quot;</span>, <span class="string">&quot;id&quot;</span>, <span class="string">&quot;score&quot;</span>, <span class="string">&quot;age&quot;</span>]</span><br><span class="line">temp = []</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> <span class="built_in">sorted</span>(students, key=attrgetter(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;score&quot;</span>, <span class="string">&quot;age&quot;</span>), reverse=<span class="literal">True</span>):</span><br><span class="line">    temp.append([item.name, item.<span class="built_in">id</span>, item.score, item.age])</span><br><span class="line"></span><br><span class="line">file_path = <span class="string">&quot;./students.xls&quot;</span></span><br><span class="line">print(temp)</span><br><span class="line">df = pd.DataFrame(temp, columns=header)</span><br><span class="line">df.to_excel(file_path, index=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    name        id  score  age</span><br><span class="line">0  Drink  68491562     90   21</span><br><span class="line">1   Star  21719561     85   20</span><br><span class="line">2   Fire  10069164     96   23</span><br></pre></td></tr></table></figure>

<p><strong>4.methodcaller</strong></p>
<blockquote>
<p>methodcaller(fun_name, fun_args)</p>
<p>fun_name: str</p>
<p>fun_args: *args  **args</p>
<p>本质上式访问的参数的类属性(get atteration)</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># methodcaller</span></span><br><span class="line"><span class="keyword">from</span> operator <span class="keyword">import</span> methodcaller</span><br><span class="line"></span><br><span class="line">s = <span class="string">&quot;The time has come&quot;</span></span><br><span class="line">upcase = methodcaller(<span class="string">&quot;upper&quot;</span>)</span><br><span class="line">print(upcase(s))</span><br><span class="line">replace_case = methodcaller(<span class="string">&quot;replace&quot;</span>, <span class="string">&quot; &quot;</span>, <span class="string">&quot;-&quot;</span>)</span><br><span class="line">print(replace_case(s))</span><br><span class="line"></span><br><span class="line">&gt;&gt;</span><br><span class="line">THE TIME HAS COME</span><br><span class="line">The-time-has-come</span><br></pre></td></tr></table></figure>

<h3 id="5-10-2-使用functools-partial冻结参数"><a href="#5-10-2-使用functools-partial冻结参数" class="headerlink" title="5.10.2 使用functools.partial冻结参数"></a>5.10.2 使用functools.partial冻结参数</h3><blockquote>
<p>又称为偏函数, 即根据一个函数通过<code>functools</code>创建一个可调用对象, 其中实现了原函数的功能, 但是只接受其参数的子集, 否则抛出exception</p>
</blockquote>
<p><code>functools</code>提供了一系列的高阶函数, 其中使用频率最多的是<code>reduce</code>和<code>partial</code>以及其变体<code>partialmethod</code></p>
<blockquote>
<p>使用partial冻结参数类似于将函数的部分参数设置了一个可变的缺省值</p>
<p>基于一个函数创建一个新的可调用对象, 并把原函数的某些参数固定, 使这个函数可以接受一个或者多个参数的函数改编成需要回调的API</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> operator <span class="keyword">import</span> mul</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line"></span><br><span class="line">triple = partial(mul, <span class="number">3</span>)</span><br><span class="line">triple(<span class="number">7</span>)</span><br><span class="line">&gt;&gt; <span class="number">21</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>(<span class="built_in">map</span>(triple, <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>)))</span><br><span class="line">[<span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">12</span>, <span class="number">15</span>, <span class="number">18</span>, <span class="number">21</span>, <span class="number">24</span>, <span class="number">27</span>]</span><br></pre></td></tr></table></figure>

<p><code>partial</code>的第一个参数接受一个可调用对象, 后面需要跟任意一个要绑定的定位参数和关键字参数</p>
<p><code>functools</code>提供的高阶函数除了<code>reduce</code> <code>partial</code> <code>partialmethod</code>之外, 还有可用于缓存的<code>lru_cache</code>以及装饰器<code>singledispatch</code>和<code>wraps</code>以及构造选择的函数<code>itemgetter</code> <code>attrgetter</code></p>
<h2 id="5-11-本章小结"><a href="#5-11-本章小结" class="headerlink" title="5.11 本章小结"></a>5.11 本章小结</h2><p><strong>函数的一等性</strong></p>
<ul>
<li>可赋值给变量</li>
<li>传给其他函数</li>
<li>存储在数据结构中</li>
<li>方位函数的属性</li>
<li>供框架和一些工具使用</li>
</ul>
<p><strong>规约函数</strong></p>
<p>函数调用规约，是指<strong>当一个函数被调用时，函数的参数会被传递给被调用的函数和返回值会被返回给调用函数</strong>。</p>
<p><strong>偏函数</strong></p>
<p>即根据一个函数通过<code>functools</code>创建一个可调用对象, 其中实现了原函数的功能, 但是只接受其参数的子集, 否则抛出<code>exception</code></p>
<p><strong>可调用对象</strong></p>
<p>0.函数即是对象, 对象也是函数</p>
<p>1.<code>lambda</code>实现的方法</p>
<p>2.自定义或实现<code>__call__</code>的函数或对象</p>
<h1 id="Part6-Imp-DP-Use-1-FunObj"><a href="#Part6-Imp-DP-Use-1-FunObj" class="headerlink" title="Part6 Imp DP Use 1 FunObj"></a>Part6 Imp DP Use 1 FunObj</h1><h2 id="6-0-抽象基类"><a href="#6-0-抽象基类" class="headerlink" title="6.0 抽象基类"></a>6.0 抽象基类</h2><p>定义一个接口或抽象类，并且通过执行类型检查来确保子类实现了某些特定的方法<br>运用 <code>abc</code>模块实现抽象基类</p>
<blockquote>
<p>抽象方法: 表示基类的一个方法，没有实现，所以基类不能实例化，子类实现了该抽象方法才能被实例化。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> abstractmethod, ABCMeta</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Http_Base</span>(<span class="params">metaclass=ABCMeta</span>):</span></span><br><span class="line"><span class="meta">	@abstractmethod</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="keyword">pass</span></span><br><span class="line">	</span><br><span class="line"><span class="meta">	@abstractmethod</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">set</span>(<span class="params">self, key, value</span>):</span></span><br><span class="line">		<span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Http</span>(<span class="params">Http_Base</span>):</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="keyword">pass</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">set</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<ul>
<li>抽象类的一个特点是它不能直接被实例化</li>
<li>抽象类的目的就是让别的类继承它并实现特定的抽象方法</li>
</ul>
<blockquote>
<p>Implement design patterns using first-class functions</p>
</blockquote>
<p><strong>上下文</strong></p>
<p>把一些计算委托给实现了不同算法的可互换组件, 提供服务</p>
<p><strong>策略</strong></p>
<p>实现不同算法的组件共同的接口</p>
<p><strong>具体策略</strong></p>
<p>策略的子类, 用于实现不同的算法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABC, abstractmethod</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"></span><br><span class="line">Customer = namedtuple(<span class="string">&quot;Customer&quot;</span>, <span class="string">&quot;name fidelity&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LineItem</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, product, quantity, price</span>):</span></span><br><span class="line">        self.product = product</span><br><span class="line">        self.quantity = quantity</span><br><span class="line">        self.price = price</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">total</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.price * self.quantity</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, customer, cart, promotion=<span class="literal">None</span></span>):</span></span><br><span class="line">        self.customer = customer</span><br><span class="line">        self.cart = <span class="built_in">list</span>(cart)</span><br><span class="line">        self.promotion = promotion</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">total</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">hasattr</span>(self, <span class="string">&quot;__total&quot;</span>):</span><br><span class="line">            self.__total = <span class="built_in">sum</span>(item.total() <span class="keyword">for</span> item <span class="keyword">in</span> self.cart)</span><br><span class="line">        <span class="keyword">return</span> self.__total</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">due</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.promotion <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            discount = <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            discount = self.promotion.discount(self)</span><br><span class="line">        <span class="keyword">return</span> self.total() - discount</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        fmt = <span class="string">&quot;&lt;Order total: &#123;:.2f&#125; due: :&#123;:.2f&#125;&gt;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> fmt.<span class="built_in">format</span>(self.total(), self.due())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 策略: 抽象基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promotion</span>(<span class="params">ABC</span>):</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">discount</span>(<span class="params">self, order</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        返回折扣金额(正值)</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FidelityPromo</span>(<span class="params">Promotion</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    第一个具体的策略</span></span><br><span class="line"><span class="string">    为积分1000以及上的顾客提供5%折扣</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">discount</span>(<span class="params">self, order</span>):</span></span><br><span class="line">        <span class="keyword">return</span> order.total() * <span class="number">.05</span> <span class="keyword">if</span> order.customer.fidelity &gt;= <span class="number">1000</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BulkItemPromo</span>(<span class="params">Promotion</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    第二个策略</span></span><br><span class="line"><span class="string">    单个商品为20个及以上时提供10%折扣</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">discount</span>(<span class="params">self, order</span>):</span></span><br><span class="line">        discount = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> order.cart:</span><br><span class="line">            <span class="keyword">if</span> item.quantity &gt;= <span class="number">20</span>:</span><br><span class="line">                discount += item.total() * <span class="number">.1</span></span><br><span class="line">            <span class="keyword">return</span> discount</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LargeOrderPromo</span>(<span class="params">Promotion</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    第三个具体策略</span></span><br><span class="line"><span class="string">    订单中的额不同商品达到10个及以上时提供7%折扣</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">discount</span>(<span class="params">self, order</span>):</span></span><br><span class="line">        distinct_items = &#123;item.product <span class="keyword">for</span> item <span class="keyword">in</span> order.cart&#125;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(distinct_items) &gt;= <span class="number">10</span>:</span><br><span class="line">            <span class="keyword">return</span> order.total() * <span class="number">.07</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是: 我们把<code>Promotion</code>定义为抽象基类<code>(ABCMeta)</code>, 这么做是使用<code>@abstractmethod</code>装饰器除此之外还可以使用<code>class Promotion(metaclass=ABCMeta)</code>实现</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">joe = Customer(<span class="string">&quot;john doe&quot;</span>, <span class="number">0</span>)</span><br><span class="line">ann = Customer(<span class="string">&quot;ann smith&quot;</span>, <span class="number">1100</span>)</span><br><span class="line">cart = [</span><br><span class="line">    LineItem(<span class="string">&quot;banana&quot;</span>, <span class="number">4</span>, <span class="number">.5</span>),</span><br><span class="line">    LineItem(<span class="string">&quot;apple&quot;</span>, <span class="number">4</span>, <span class="number">1.5</span>),</span><br><span class="line">    LineItem(<span class="string">&quot;watermellon&quot;</span>, <span class="number">5</span>, <span class="number">5.0</span>)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">print(Order(joe, cart, FidelityPromo()))</span><br><span class="line">print(Order(ann, cart, FidelityPromo()))</span><br><span class="line">&gt;&gt;</span><br><span class="line">&lt;Order total: <span class="number">33.00</span> due: <span class="number">33.00</span>&gt;</span><br><span class="line">&lt;Order total: <span class="number">33.00</span> due: <span class="number">31.35</span>&gt;</span><br></pre></td></tr></table></figure>

<p>可以完全使用一等对象函数来实现这种策略, 并且代码更少</p>
<h2 id="6-1-函数实现策略模式"><a href="#6-1-函数实现策略模式" class="headerlink" title="6.1 函数实现策略模式"></a>6.1 函数实现策略模式</h2><blockquote>
<p>在上面的例子中, 每一个实例化的抽象类<code>Promotion</code>都只实现了一个方法, 我们对此重构如下<br>使用作为一等对象的函数, 可以使某些设计模式进行简化</p>
</blockquote>
<p>什么是策略模式: 定义一系列算法, 把他一一封装起来, 并且可以使他们相互替换(使算法可以独立于使用它的客户而变化)</p>
<p><strong>策略模式对类的编排</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/lyh0825/Drink@master/PicGo/20220411202433.png" alt=" "></p>
<p>策略模式示例:</p>
<p>电商策略模式:</p>
<ul>
<li>1000积分的顾客, 每单5%折扣</li>
<li>同一个订单, 单个商品数量达到20个, 10%折扣</li>
<li>订单中不同商品达到10, 7%折扣</li>
</ul>
<p><strong>假设每个订单只享受一个折扣</strong></p>
<blockquote>
<p>使用order类和函数实现的折扣策略</p>
<p>把具体的策略换成简单的函数, 去除抽象类</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"></span><br><span class="line">Customer = namedtuple(<span class="string">&quot;Customer&quot;</span>, <span class="string">&quot;name fidelity&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LineItem</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, product, quantity, price</span>):</span></span><br><span class="line">        self.product = product</span><br><span class="line">        self.quantity = quantity</span><br><span class="line">        self.price = price</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">total</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.price * self.quantity</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, customer, cart, promoition=<span class="literal">None</span></span>):</span></span><br><span class="line">        self.customer = customer</span><br><span class="line">        self.cart = <span class="built_in">list</span>(cart)</span><br><span class="line">        self.promotion = promoition</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">total</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">hasattr</span>(self, <span class="string">&quot;__total&quot;</span>):</span><br><span class="line">            self.__total = <span class="built_in">sum</span>(item.total() <span class="keyword">for</span> item <span class="keyword">in</span> self.cart)</span><br><span class="line">        <span class="keyword">return</span> self.__total</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">due</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.promotion <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            discount = <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            discount = self.promotion(self)</span><br><span class="line">        <span class="keyword">return</span> self.total() - discount</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        fmt = <span class="string">&quot;&lt;Order total: &#123;:.2f&#125; due: &#123;:.2f&#125;&gt;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> fmt.<span class="built_in">format</span>(self.total(), self.due())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fidelity_promo</span>(<span class="params">order</span>):</span></span><br><span class="line">    <span class="keyword">return</span> order.total() * <span class="number">.5</span> <span class="keyword">if</span> order.customer.fidelity &gt;= <span class="number">1000</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bulk_item_promo</span>(<span class="params">order</span>):</span></span><br><span class="line">    discount = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> order.cart:</span><br><span class="line">        <span class="keyword">if</span> item.quantity &gt;= <span class="number">20</span>:</span><br><span class="line">            discount += item.total() * <span class="number">.1</span></span><br><span class="line">    <span class="keyword">return</span> discount</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lager_order_promo</span>(<span class="params">order</span>):</span></span><br><span class="line">    distinct_items = &#123;item.product <span class="keyword">for</span> item <span class="keyword">in</span> order.cart&#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(distinct_items) &gt;= <span class="number">10</span>:</span><br><span class="line">        <span class="keyword">return</span> order.total() * <span class="number">.07</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<ul>
<li>计算折扣只需要调用<code>self.promotion()</code></li>
<li><strong>再次表明了函数是一等对象:可以作为参数传递</strong></li>
<li>取消了抽象类</li>
<li>各个策略都是函数</li>
<li>为了把策略用到实例上, 只需要传入对应的策略函数即可</li>
</ul>
<hr>
<p><strong>策略对象通常是很好的享元(flyweight)</strong></p>
<ol>
<li>享元是可以共享的对象, 可以同时在多个上下文中使用</li>
<li>享元不需要在每个上下文实例化, 减少消耗</li>
</ol>
<hr>
<p>显然易见, 即使是使用了函数作为策略实现, 但是在选择策略时,任然时人工选择, 接下来我们考虑实现 <strong>元策略</strong>, 即让它自动化实现最优方案</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 实例化函数:并非将其输入为string, 而是创建一个list包含了实例化的函数对象, 方便调用</span></span><br><span class="line">promos = [fidelity_promo, bulk_item_promo. large_order_promo]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">meta_promo</span>(<span class="params">order</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;auto select best promo&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(promo(order) <span class="keyword">for</span> promo <span class="keyword">in</span> promos)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>promos</code>列出函数实现的各个策略</li>
<li>于其他<code>*_promo</code>函数一样, <code>meta_promo</code>函数的参数是一个<code>order</code>的实例</li>
<li>使用生成器表达式, 将<code>order</code>作为参数传给<code>fun list</code></li>
</ul>
<p><strong>这里的promos是一个存储函数对象的列表, 当你深刻意识到了函数的一等对象性, 你就不难发现, 这样构建函数列表的simple and right</strong></p>
<p><strong>1.作为参数传递</strong></p>
<p><strong>2.可以被数据结构化存储</strong></p>
<p>如下例所示:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">temp</span>():</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fun_list = [temp]</span><br><span class="line">print(fun_list)</span><br><span class="line">&gt;&gt;</span><br><span class="line">[&lt;function temp at <span class="number">0x000001D96DA478C8</span>&gt;]</span><br></pre></td></tr></table></figure>

<h3 id="6-1-1-find-all-strategy-in-module"><a href="#6-1-1-find-all-strategy-in-module" class="headerlink" title="6.1.1 find all strategy in module"></a>6.1.1 find all strategy in module</h3><blockquote>
<p>在python中, 模块也属于一等对象, 并且标准库提供了许多处理模块的函数</p>
</blockquote>
<h4 id="Globals"><a href="#Globals" class="headerlink" title="Globals()"></a>Globals()</h4><blockquote>
<p>返回一个字典, 表示当前的全局符号表, 这个符号表始终针对当前模块(对函数或方法来说是定义他们的模块而不是调用他们的模块)</p>
</blockquote>
<p>动态收集促销品折扣函数更简单的一个方式是使用简单的装饰器</p>
<h2 id="6-2-命令模式"><a href="#6-2-命令模式" class="headerlink" title="6.2 命令模式"></a>6.2 命令模式</h2><blockquote>
<p>命令模式也可以通过把函数作为参数而传递</p>
<p>主要解决的是解耦调用者和接收者, 通过中间对象<code>command</code>对象实现|如果要实现保存函数状态, 可以使用函数闭包</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/lyh0825/Drink@master/PicGo/20220417193527.png"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Macrocommand</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, commands</span>):</span></span><br><span class="line">        <span class="comment"># init commands (list) </span></span><br><span class="line">        self.commands = <span class="built_in">list</span>(commands)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="keyword">for</span> command <span class="keyword">in</span> self.commands:</span><br><span class="line">            command()</span><br></pre></td></tr></table></figure>

<h2 id="6-3-本章小结"><a href="#6-3-本章小结" class="headerlink" title="6.3 本章小结"></a>6.3 本章小结</h2><p>Recommand Books</p>
<ul>
<li>Learning python design patterns</li>
</ul>
<h1 id="Part7-Decorators-And-Closuer"><a href="#Part7-Decorators-And-Closuer" class="headerlink" title="Part7 Decorators And Closuer"></a>Part7 Decorators And Closuer</h1><blockquote>
<p>装饰器用于在源码中标记函数, 用于增强函数行为, 装饰器的基础时闭包(回调式异步编程和函数式编程的基础)</p>
</blockquote>
<h2 id="7-0-Target"><a href="#7-0-Target" class="headerlink" title="7.0 Target"></a>7.0 Target</h2><ul>
<li>如何计算装饰器句法</li>
<li>如何判断变量不是局部的</li>
<li>闭包存在的原因和工作原理</li>
<li>nonlocal解决的问题</li>
<li>行为良好的装饰器如何实现</li>
<li>标准库中常见的装饰器</li>
<li>实现参数化装饰器</li>
</ul>
<h2 id="7-1-DecoratorBasic"><a href="#7-1-DecoratorBasic" class="headerlink" title="7.1 DecoratorBasic"></a>7.1 DecoratorBasic</h2><blockquote>
<p>装饰器是一个可调用对象, 其参数是一个被装饰的函数, 其结果可能会处理被装饰的函数并将其返回, 或者将其替换成一个函数或可调用对象</p>
<p>在运行时改变程序的行为</p>
</blockquote>
<p><strong>装饰器</strong></p>
<ul>
<li>接受: 函数</li>
<li>返回: 处理后的函数|替换的函数 |可调用对象</li>
</ul>
<p><strong>特性:</strong></p>
<ol>
<li>能把被装饰的函数换成其他函数</li>
<li>装饰器在加载模块时立即执行</li>
<li>在被装饰函数定义之后立即运行</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deco</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="comment"># deco函数返回的其实时inner</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span>():</span></span><br><span class="line">        print(<span class="string">&quot;running inner()&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@deco</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">target</span>():</span></span><br><span class="line">    print(<span class="string">&quot;running target()&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用被装饰的target函数其实会运行inner</span></span><br><span class="line">target()</span><br><span class="line"><span class="comment"># 审查对象发现target现在时inner的引用</span></span><br><span class="line">print(target)</span><br></pre></td></tr></table></figure>

<h2 id="7-2-Py何时执行装饰器"><a href="#7-2-Py何时执行装饰器" class="headerlink" title="7.2 Py何时执行装饰器"></a>7.2 Py何时执行装饰器</h2><blockquote>
<p>在被装饰函数定义后立即执行, 通常是在导包时(加载模块)中执行</p>
</blockquote>
<ul>
<li>在<code>import</code>或<code>running code</code>时装饰器会首先运行, 被装饰的函数只有在调用时才运行</li>
<li>通常情况下, 装饰器独自写成一个模块, 被其他模块通过<code>import</code>调用</li>
<li>大多数情况下装饰器会在内部定义一个函数</li>
</ul>
<h2 id="7-3-装饰器改进策略模式"><a href="#7-3-装饰器改进策略模式" class="headerlink" title="7.3 装饰器改进策略模式"></a>7.3 装饰器改进策略模式</h2><blockquote>
<p>使用装饰器改进策略模式</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">promos = []</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">promotion</span>(<span class="params">promo_func</span>):</span></span><br><span class="line">    promos.append(promo_func)</span><br><span class="line">    <span class="keyword">return</span> promo_func</span><br><span class="line"></span><br><span class="line"><span class="meta">@promotion</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">prom_1</span>(<span class="params">order</span>):</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@promotion</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">prom_2</span>(<span class="params">order</span>):</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@promotion</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">prom_3</span>(<span class="params">order</span>):</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">best_promos</span>():</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> promos:</span><br><span class="line">        print(item)</span><br><span class="line"></span><br><span class="line">best_promos()</span><br></pre></td></tr></table></figure>

<ul>
<li>策略函数不需要一个特别名称</li>
<li>装饰器突出了被装饰的函数的作用, 可以临时禁用或者注释, 只需要注释掉装饰器即可</li>
<li>可以在其他模块中定义促销函数, 只需要添加装装饰器</li>
</ul>
<p><strong>转装饰器如果使用内部函数, 必须依赖于闭包实现</strong></p>
<h2 id="7-4-变量作用域规则"><a href="#7-4-变量作用域规则" class="headerlink" title="7.4 变量作用域规则"></a>7.4 变量作用域规则</h2><blockquote>
<p>variable scoping rule</p>
</blockquote>
<p>1.python在定义函数中, 默认函数中的变量都是<code>local</code>, 如果在执行中没有在<code>local</code>中找到对应的变量, 或者变量没有绑定值, python将会通过code crash的方式告诉用户, 而非像JavaScript一样找<code>global</code>代替</p>
<ul>
<li>在函数体中没有进行赋值操作</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">a</span>):</span></span><br><span class="line">    print(a)</span><br><span class="line">    print(b)</span><br><span class="line"></span><br><span class="line">b = <span class="number">1</span></span><br><span class="line">test(<span class="number">1</span>)</span><br><span class="line">&gt;&gt;</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span>   </span><br></pre></td></tr></table></figure>

<ul>
<li>在函数体中进行了赋值操作</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">a</span>):</span></span><br><span class="line">    print(a)</span><br><span class="line">    print(b)</span><br><span class="line">    b = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">b = <span class="number">1</span></span><br><span class="line">test(<span class="number">1</span>)</span><br><span class="line">&gt;&gt;</span><br><span class="line"><span class="number">1</span></span><br><span class="line">UnboundLocalError: local variable <span class="string">&#x27;b&#x27;</span> referenced before assignment</span><br></pre></td></tr></table></figure>

<p><strong>两个函数的字节码如下</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/lyh0825/Drink@master/PicGo/20220419165520.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/lyh0825/Drink@master/PicGo/20220419170013.png"></p>
<p>可以看到俩这的差别, 一个是将<code>b</code>视为<code>FAST</code>另一个视为<code>GLOBAL</code></p>
<blockquote>
<p>将fun_block中的变量加载为global可以使用global关键词声明variable</p>
</blockquote>
<h2 id="7-5-闭包"><a href="#7-5-闭包" class="headerlink" title="7.5 闭包"></a>7.5 闭包</h2><blockquote>
<p>只有涉及到嵌套函数时才会有闭包, 通常情况出现在定义的函数体中使用了<code>lambda</code>函数, 或者定义的装饰器内部含有函数</p>
</blockquote>
<p><strong>闭包的本质: 闭包是指延伸了作用域的函数, 其中包含函数定义体中引用, 但是不在定义体中定义的非全局变量, 闭包的关键问题不是匿名函数, 而是它能访问定义体之外定义的非全局变量</strong></p>
<p>函数中创建的变量是一个<strong>局部变量。</strong></p>
<p>局部变量的<strong>生命周期</strong>是等局部作用结束之后就会被释放掉。</p>
<p><strong>如果内函数使用了外函数的局部变量，那么这个变量就与闭包函数发生了绑定关系，就延长该变量的生命周期。实际上就是内存给它存储了这个值，暂时不释放。</strong></p>
<hr>
<p><strong>要实现一个函数不断计算系列值的均值</strong></p>
<blockquote>
<p>需要记录器历史值</p>
</blockquote>
<p><strong>方法一 类实现</strong> </p>
<p>使用类中和属性存储历史数值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Averager</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.series = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self, new_value</span>):</span></span><br><span class="line">        self.series.append(new_value)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(self.series) / <span class="built_in">len</span>(self.series)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">avg = Averager()</span><br><span class="line"></span><br><span class="line">print(avg(<span class="number">10</span>))</span><br><span class="line">print(avg(<span class="number">18</span>))</span><br><span class="line">print(avg(<span class="number">17</span>))</span><br><span class="line">print(avg(<span class="number">22</span>))</span><br><span class="line">print(avg.series)</span><br></pre></td></tr></table></figure>

<p><strong>方法二 高阶函数实现</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义一个函数(类)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_averager</span>():</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 在初始化时给函数(类)赋予属性</span></span><br><span class="line">    series = []</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 实现函数中的一个方法(enclosure)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">average</span>(<span class="params">new_value</span>):</span></span><br><span class="line">        series.append(new_value)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(series) / <span class="built_in">len</span>(series)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 调用函数实例时返回的方法</span></span><br><span class="line">    <span class="keyword">return</span> average</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化一个函数并初始化其属性</span></span><br><span class="line">avg = make_averager()</span><br><span class="line"><span class="comment"># 调用函数的实例实际上根据函数的定义</span></span><br><span class="line"><span class="comment"># 调用的是函数中的average方法</span></span><br><span class="line">avg(<span class="number">2</span>)</span><br><span class="line">avg(<span class="number">12</span>)</span><br></pre></td></tr></table></figure>

<p>我们可以在<code>fun.__code__</code>(<strong>表示编译后的函数定义体</strong>)属性中查看变量作用域</p>
<p><strong>需要注意的是</strong></p>
<p><code>series</code>是<code>make_averager</code>函数的局部变量, 因为在函数的定义体中已经初始化了<code>series: series = []</code>, 可是在调用<code>avg(10)</code>时, <code>make_averager</code>函数已经返回了, 而且它的本地作用域也消失了</p>
<p><img src="https://cdn.jsdelivr.net/gh/lyh0825/Drink@master/PicGo/20220419191131.png"></p>
<p>在<code>averager</code>函数中, <code>series</code>是自由变量<code>freevariable</code>, 指未在本地作用域中绑定的变量</p>
<p><code>averager</code>的闭包延伸到那个函数的作用域外, 包含自由变量<code>series</code>的绑定</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看局部变量</span></span><br><span class="line">print(avg.__code__.co_varnames)</span><br><span class="line"><span class="comment"># 查看自由变量</span></span><br><span class="line">print(avg.__code__.co_freevars)</span><br><span class="line">&gt;&gt;</span><br><span class="line">(<span class="string">&#x27;new_value&#x27;</span>,)</span><br><span class="line">(<span class="string">&#x27;series&#x27;</span>,)</span><br></pre></td></tr></table></figure>

<p><code>series</code>的绑定在返回的<code>avg</code>函数的<code>__closure__</code>属性中, <code>avg.__closure__</code>中的各个元素对应的<code>avg.__code__.co_freevars</code>中一个名称, 这些元素都是一个<code>cell</code>对象, 可以通过<code>cell_contents</code>属性访问保存的值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">avg.__code__co_freevars</span><br><span class="line">&gt;&gt; (<span class="string">&quot;series&quot;</span>, )</span><br><span class="line">avg.__closure__</span><br><span class="line">&gt;&gt; (&lt;cell at <span class="number">0x00000193478E8AF8</span>: <span class="built_in">list</span> <span class="built_in">object</span> at <span class="number">0x00000193479273C8</span>&gt;,)</span><br><span class="line">avg.__closure__[<span class="number">0</span>].cell_contents</span><br><span class="line">&gt;&gt; [<span class="number">19</span>, <span class="number">20</span>]</span><br></pre></td></tr></table></figure>

<hr>
<p>闭包本质上是一个函数, 它会保留定义函数时存在的自由变量的绑定, 这样在调用函数时, 虽然定义作用域不可用了, 但是使用那些绑定</p>
<p>需要注意的是, 只有嵌套在其他函数中的函数才可能需要处理不在全局</p>
<h2 id="7-6-NoncalDeclaration"><a href="#7-6-NoncalDeclaration" class="headerlink" title="7.6 NoncalDeclaration"></a>7.6 NoncalDeclaration</h2><blockquote>
<p>改进计算累加均值的方式, 只记录总值不再记录历史数据</p>
<p>nonlocal declaration not allowed at module level</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_average</span>():</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">average</span>(<span class="params">new_value</span>):</span></span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        total += new_value</span><br><span class="line">        <span class="keyword">return</span> total / count</span><br><span class="line">   	<span class="keyword">return</span> total / count</span><br></pre></td></tr></table></figure>

<p>由于<code>str int tuple</code>属于不可变类型, <code>+=</code>本质上<code>var = var + other</code>, 因此这样会隐式创建一个<strong>局部变量</strong>, 这样<code>count total</code>就无法作为<strong>自由变量</strong>存在于闭包中, 因此在实例化函数对象时会失败</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_average</span>():</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">average</span>(<span class="params">new_value</span>):</span></span><br><span class="line">        <span class="keyword">nonlocal</span> count, total</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        total += new_value</span><br><span class="line">        <span class="keyword">return</span> total / count</span><br><span class="line">   	<span class="keyword">return</span> total / count</span><br></pre></td></tr></table></figure>

<p><code>nonlocal</code>会把变量标记为<strong>自由变量</strong>, 即使在函数中为变量赋予了新值, 也会称为自由变量</p>
<p><strong>nonlocal的作用可以简单理解为: 允许在闭包定义的变量从局部变量转变为自由变量, 从而实现调用定义体外的变量. 从宏观上看延长了变量的生命周期(调用完函数即释放), 并使变量具有记忆</strong></p>
<h2 id="7-7-实现一个简单的装饰器"><a href="#7-7-实现一个简单的装饰器" class="headerlink" title="7.7 实现一个简单的装饰器"></a>7.7 实现一个简单的装饰器</h2><p>1.<code>decorator(func)</code>等价于</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@decorator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>()</span></span><br></pre></td></tr></table></figure>

<p>2.被装饰器装饰的函数, 其引用指向对应装饰器的对应内部函数</p>
<p><strong>实例</strong></p>
<blockquote>
<p>这里实现了装饰器一个典型的行为, 把被装饰的函数替换成新函数, 两者接受一样的参数, 并且返回被装饰的函数本应该返回的值, 同时在这一个过程中会进行额外的操作</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clock</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clocked</span>(<span class="params">*args</span>):</span></span><br><span class="line">        t0 = time.perf_counter()</span><br><span class="line">        result = func(*args)</span><br><span class="line">        elapsed = time.perf_counter() - t0</span><br><span class="line">        name = func.__name__</span><br><span class="line">        args_str = <span class="string">&quot;, &quot;</span>.join(<span class="built_in">repr</span>(arg) <span class="keyword">for</span> arg <span class="keyword">in</span> args)</span><br><span class="line">        print(<span class="string">&quot;[%0.8fs] %s(%s) -&gt; %r&quot;</span> % (elapsed, name, args_str, result))</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> clocked</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@clock</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorial</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">if</span> n &lt; <span class="number">2</span> <span class="keyword">else</span> n * factorial(n-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">factorial(<span class="number">1</span>)</span><br><span class="line">factorial(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">print(factorial.__name__)</span><br><span class="line"></span><br><span class="line">&gt;&gt;</span><br><span class="line">[0.00000060s] factorial(1) -&gt; 1</span><br><span class="line">[0.00000030s] factorial(1) -&gt; 1</span><br><span class="line">[0.00000860s] factorial(2) -&gt; 2</span><br><span class="line">[0.00001510s] factorial(3) -&gt; 6</span><br><span class="line">clocked</span><br></pre></td></tr></table></figure>

<p><strong>需要注意的是:</strong></p>
<p><strong>1.装饰器会抹去被装饰器的<code>__name__</code>和<code>__doc__</code>属性, 可以使用<code>functools.wraps</code>装饰器把接受参数<code>(func)</code>的属性复制到被装饰函数中</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clock</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="comment"># </span></span><br><span class="line"><span class="meta">    @functools.wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clocked</span>(<span class="params">*args</span>):</span></span><br><span class="line">        t0 = time.perf_counter()</span><br><span class="line">        result = func(*args)</span><br><span class="line">        elapsed = time.perf_counter() - t0</span><br><span class="line">        name = func.__name__</span><br><span class="line">        args_str = <span class="string">&quot;, &quot;</span>.join(<span class="built_in">repr</span>(arg) <span class="keyword">for</span> arg <span class="keyword">in</span> args)</span><br><span class="line">        print(<span class="string">&quot;[%0.8fs] %s(%s) -&gt; %r&quot;</span> % (elapsed, name, args_str, result))</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> clocked</span><br><span class="line"></span><br><span class="line"><span class="meta">@clock</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorial</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">if</span> n &lt; <span class="number">2</span> <span class="keyword">else</span> n * factorial(n-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h2 id="7-8-标准库中的装饰器"><a href="#7-8-标准库中的装饰器" class="headerlink" title="7.8 标准库中的装饰器"></a>7.8 标准库中的装饰器</h2><blockquote>
<p>标准库中常见的装饰器函数有:</p>
<p><code>property</code> <code>classmethod</code> <code>staticmethod</code>  </p>
<p><code>lru_cache</code> <code>singledispatch</code> </p>
</blockquote>
<h3 id="7-8-1-lru-cache备忘"><a href="#7-8-1-lru-cache备忘" class="headerlink" title="7.8.1 lru_cache备忘"></a>7.8.1 lru_cache备忘</h3><blockquote>
<p>functools.lru_cache实现了备忘(memoization)的功能, 是一项优化技术, 它将耗时的函数结果保存起来, 避免传入相同参数时重复计算</p>
</blockquote>
<p><code>LRU(least Recently Used)</code>最近使用, 表示缓存不会无限增长, 一段时间不用会自动丢掉</p>
<p><strong>lru_cache装饰器非常适合递归函数使用, 而且从web中获取信息也有很大优势</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clock</span>(<span class="params">func</span>):</span></span><br><span class="line"><span class="meta">    @functools.wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clocked</span>(<span class="params">*args</span>):</span></span><br><span class="line">        t0 = time.perf_counter()</span><br><span class="line">        result = func(*args)</span><br><span class="line">        elapsed = time.perf_counter() - t0</span><br><span class="line">        name = func.__name__</span><br><span class="line">        args_str = <span class="string">&quot;, &quot;</span>.join(<span class="built_in">repr</span>(arg) <span class="keyword">for</span> arg <span class="keyword">in</span> args)</span><br><span class="line">        print(<span class="string">&quot;[%0.8fs] %s(%s) -&gt; %r&quot;</span> % (elapsed, name, args_str, result))</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> clocked</span><br><span class="line"></span><br><span class="line"><span class="meta">@functools.lru_cache()</span></span><br><span class="line"><span class="meta">@clock</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorial</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">if</span> n &lt; <span class="number">2</span> <span class="keyword">else</span> n * factorial(n - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">factorial(<span class="number">1</span>)</span><br><span class="line">factorial(<span class="number">9</span>)</span><br><span class="line">factorial(<span class="number">10</span>)</span><br><span class="line">print(factorial.__name__)</span><br><span class="line">&gt;&gt;</span><br><span class="line">[0.00000050s] factorial(1) -&gt; 1</span><br><span class="line">...</span><br><span class="line">[0.00000040s] factorial(10) -&gt; 3628800</span><br><span class="line">factorial</span><br></pre></td></tr></table></figure>

<ul>
<li>显示调用了10次</li>
<li>不加装饰器会调用(19次)</li>
<li>必须像常规函数一样调用<code>lru_cache()</code>, 加括号的原因是其可以接受配置参数</li>
<li>叠放装饰器<code>@lru_cache()</code>在<code>@clock</code>之前</li>
<li>需要注意的是<code>lru_cache</code>可以使用两个可选参数, 签名如下:</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> inspect <span class="keyword">import</span> signature</span><br><span class="line">print(signature(functools.lru_cache))</span><br><span class="line">&gt;&gt;</span><br><span class="line">(maxsize=<span class="number">128</span>, typed=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>maxsize</code>:指定最大存储缓存数目, 满了之后旧的会被丢弃(为了最佳性能, maxsize应该设置成2的幂)</li>
<li><code>typed</code>: 为<code>True</code>时会把不同参数类型得到的结果分开保存(即会把通常认为相等的浮点和整形分开保存)</li>
<li><code>lru_cache</code>使用字典储存结果, <code>key</code>根据传入的定位参数和关键字参数创建, 所以被<code>lru_cache</code>都必须时<code>hashable</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@functools.lru_cache()</span></span><br><span class="line"><span class="meta">@clock</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorial</span>(<span class="params">n</span>):</span></span><br><span class="line">    m = n.pop</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">if</span> m &lt; <span class="number">2</span> <span class="keyword">else</span> m * factorial(n)</span><br><span class="line"></span><br><span class="line">factorial([<span class="number">1</span>, <span class="number">10</span>])</span><br><span class="line">&gt;&gt;</span><br><span class="line">TypeError: unhashable <span class="built_in">type</span>: <span class="string">&#x27;list&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="7-8-2-单分派泛函数"><a href="#7-8-2-单分派泛函数" class="headerlink" title="7.8.2 单分派泛函数"></a>7.8.2 单分派泛函数</h3><blockquote>
<p>分派函数: 对于不同的传参类型进行不同的处理输出, 一般使用(if-else), 时间一长就会显得十分笨拙, 而且各个模块的耦合度逐渐增高</p>
<p>泛函数: 根据第一个传参类型进行自适应处理输出<strong>函数组</strong></p>
<p>单分派函数: 只根据第一个传参类型进行自适应判断的<strong>泛函数</strong></p>
<p>多分派函数: 根据多个参数进行自适应判断的<strong>泛函数</strong></p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/lyh0825/Drink@master/PicGo/20220422190720.png"></p>
<p><code>python3.4</code>新增的<code>functools.singledispatch</code>装饰器会多个函数组合成一个函数组, 甚至可以为无法修改的类提供专门的函数, 使用<code>@singledispatch</code>装饰的普通函数会被成泛函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">from functools import singledispatch</span><br><span class="line">from collections import abc</span><br><span class="line">import numbers</span><br><span class="line">import html</span><br><span class="line"></span><br><span class="line"># 装饰器标记处理object类型的基函数</span><br><span class="line">@singledispatch</span><br><span class="line">def htmlize(obj):</span><br><span class="line">    content &#x3D; html.escape(repr(obj))</span><br><span class="line">    return f&quot;&lt;pre&gt;&#123;content&#125;&lt;pre&gt;&quot;</span><br><span class="line"></span><br><span class="line"># 各个专门函数使用@&lt;base_function&gt;.register(&lt;type&gt;)装饰</span><br><span class="line">@htmlize.register(str)</span><br><span class="line"># 使用占位符代替不必要的函数名</span><br><span class="line">def _(text):</span><br><span class="line">    content &#x3D; html.escape(text).replace(&quot;\n&quot;, &quot;&lt;br&gt;\n&quot;)</span><br><span class="line">    return f&quot;&lt;p&gt;&#123;content&#125;&lt;&#x2F;p&gt;&quot;</span><br><span class="line"></span><br><span class="line"># 为每个需要特殊处理的类型注册一个函数, numbers.Integral是int的虚拟超类</span><br><span class="line">@htmlize.register(numbers.Integral)</span><br><span class="line">def _(n):</span><br><span class="line">    return f&quot;&lt;pre&gt;&#123;n&#125;&lt;&#x2F;pre&gt;&quot;</span><br><span class="line"></span><br><span class="line"># 可以叠放多个装饰器让同一个函数处理多个类型</span><br><span class="line">@htmlize.register(tuple)</span><br><span class="line">@htmlize.register(abc.MutableSequence)</span><br><span class="line">def _(seq):</span><br><span class="line">    inner &#x3D; &quot;&lt;&#x2F;in&gt;\n&lt;li&gt;&quot;.join(htmlize(item) for item in seq)</span><br><span class="line">    return &quot;&lt;ul&gt;\n&lt;li&gt;&quot; + inner + &quot;&lt;&#x2F;li&gt;\n&lt;ul&gt;&quot;</span><br></pre></td></tr></table></figure>

<p><strong>只要可能, 注册的专门函数应该处理抽象基类(numbers.Integral) 和(abs.MutaleSequence), 不要处理具体实现(int | list) , 这样代码具有更高的兼容性</strong></p>
<p><strong><code>@singledispatch</code>装饰器不是把java重载函数带入pyhton. 实际上在一个类中为同一个方法定义多个重载变体,比在函数中使用if-elif-elif块更好用, 但是他们有个共同的缺陷, 都将代码单元(类或函数)承担了太多责任, 装饰器的好处是支持模块化扩展:各个模块可以为它支持的各个类型注册一个专门的函数</strong></p>
<p>装饰器是函数, <code>因此可以组合起来使用类似于泛函数</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/StarFire1226/photos@master/20220423222901.png"></p>
<p><strong>连接两者的桥梁是[fun oneself] – params – [regsiter fun]</strong></p>
<h2 id="7-9-StackDecorator"><a href="#7-9-StackDecorator" class="headerlink" title="7.9 StackDecorator"></a>7.9 StackDecorator</h2><blockquote>
<p>有时需要对一个函数进行多次装饰以满足现实的需求</p>
</blockquote>
<h2 id="7-10-参数化装饰器"><a href="#7-10-参数化装饰器" class="headerlink" title="7.10 参数化装饰器"></a>7.10 参数化装饰器</h2><blockquote>
<p>解析源码中的装饰器时, python会把被装饰的函数作为第一个参数传递给装饰器, 如果想将其他参数传递给装饰器, 我们需要创建一个装饰器工厂函数把参数传递给工厂函数, 他将返回一个带参装饰器(函数), 再将这个装饰器运用即可</p>
</blockquote>
<p><strong>装饰器的参数化必须通过函数工厂的模式实现</strong></p>
<h3 id="7-10-1参数化注册装饰器"><a href="#7-10-1参数化注册装饰器" class="headerlink" title="7.10.1参数化注册装饰器"></a>7.10.1参数化注册装饰器</h3><blockquote>
<p>启用或禁用register执行的函数注册功能, 提供一个active参数, 设置为false, 不注册被装饰函数, 从概念上看, register函数不是装饰器, 而是装饰器工厂函数</p>
</blockquote>
<p><strong>如果装饰器工厂函数带有 [定位参数], 在使用装饰器时, 必须使用()带参, 否则装饰器并不会运行</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">registry = <span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">register</span>(<span class="params">active</span>):</span></span><br><span class="line">    <span class="comment"># decorate 这个内部函数是真正的装饰器</span></span><br><span class="line">    <span class="comment"># 其参数是一个函数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorate</span>(<span class="params">func</span>):</span></span><br><span class="line">        print(<span class="string">f&quot;running register <span class="subst">&#123;func&#125;</span> --&gt; <span class="subst">&#123;active&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="comment"># 只有activate(从闭包中获取)为True时才注册func</span></span><br><span class="line">        <span class="keyword">if</span> active:</span><br><span class="line">            registry.add(func)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            registry.discard(func)</span><br><span class="line">        <span class="comment"># decorate是装饰器必须返回一个函数</span></span><br><span class="line">        <span class="keyword">return</span> func</span><br><span class="line">	<span class="comment"># register是装饰器工厂函数, 返回decorate</span></span><br><span class="line">    <span class="keyword">return</span> decorate</span><br><span class="line"></span><br><span class="line"><span class="comment"># @register()</span></span><br><span class="line"><span class="comment"># @register(active=True)</span></span><br><span class="line"><span class="comment"># @register</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span>():</span></span><br><span class="line">    print(<span class="string">f&quot;running 1&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;running main&quot;</span>)</span><br><span class="line">print(<span class="string">f&quot;registry -&gt; <span class="subst">&#123;registry&#125;</span>&quot;</span>)</span><br><span class="line">&gt;&gt; <span class="comment">#1 TypeError: register() missing 1 required positional argument: &#x27;active&#x27;</span></span><br><span class="line">&gt;&gt; <span class="comment">#2 registry -&gt; &#123;&lt;function f1 at 0x00000212715E8158&gt;&#125;</span></span><br><span class="line">&gt;&gt; <span class="comment">#3 registry -&gt; set()</span></span><br></pre></td></tr></table></figure>

<ul>
<li>@register工厂函数必须作为函数调用,并且传入所需参数</li>
<li>即使不传入参数, register也必须作为函数<code>@register()</code>调用, 即要返回真正的装饰器<code>decorate</code>, 而不是作为函数对象调用<code>@register</code></li>
<li>我们需要调用装饰器工厂函数返回的装饰器函数, 而不是调用装饰器对象</li>
</ul>
<hr>
<p><strong>关键在于使用<code>@register(param)</code>返回一个函数作为装饰器而不是使用<code>@register</code>的函数对象装饰</strong></p>
<p>使用<code>@register</code>装饰器, 装饰函数时等价于<code>register()(func)</code></p>
<p>本质上是<code>register()</code>返回一个函数对象在将<code>(func)</code>返回带入返回的函数对象**(装饰器)**</p>
<hr>
<p>参数化的装饰器原理相当复杂, 参数化装饰器通常会把被装饰的函数替换, 而且结构上要多一层嵌套(形成装饰器工厂函数)</p>
<h3 id="7-10-2-参数化的clock装饰器"><a href="#7-10-2-参数化的clock装饰器" class="headerlink" title="7.10.2 参数化的clock装饰器"></a>7.10.2 参数化的clock装饰器</h3><blockquote>
<p>在调用装饰器时, 是否使用函数化调用<code>@decorate()</code>取决于两个方面</p>
<p>1.装饰器是否需要传参</p>
<p>2.是否需要调用装饰器函数(否则调用装饰器函数对象)</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">DEFAULT_FMT = <span class="string">&quot;[&#123;elapsed:0.8f&#125;s] &#123;name&#125; (&#123;args&#125;)  -&gt; &#123;result&#125;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># factory function</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clock</span>(<span class="params">fmt=DEFAULT_FMT</span>):</span></span><br><span class="line">    <span class="comment"># the real decorate</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorate</span>(<span class="params">func</span>):</span></span><br><span class="line">        <span class="comment"># decorated the function</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">clocked</span>(<span class="params">*_args</span>):</span></span><br><span class="line">            t0 = time.time()</span><br><span class="line">            <span class="comment"># 被装饰函数真正返回的结果</span></span><br><span class="line">            <span class="comment"># args是clocked的参数</span></span><br><span class="line">            _result = func(*_args)</span><br><span class="line">            elapsed = time.time() - t0</span><br><span class="line">            name = func.__name__</span><br><span class="line">            args = <span class="string">&quot;, &quot;</span>.join(<span class="built_in">repr</span>(arg) <span class="keyword">for</span> arg <span class="keyword">in</span> _args)</span><br><span class="line">            result = <span class="built_in">repr</span>(_result)</span><br><span class="line">            <span class="comment"># 在fmt引用clocked的局部变量</span></span><br><span class="line">            print(fmt.<span class="built_in">format</span>(**<span class="built_in">locals</span>()))</span><br><span class="line">            <span class="comment"># 从clocked会取代被装饰的函数, 返回被装饰函数的返回值</span></span><br><span class="line">            <span class="keyword">return</span> _result</span><br><span class="line">        <span class="keyword">return</span> clocked</span><br><span class="line">    <span class="keyword">return</span> decorate</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line"></span><br><span class="line"><span class="meta">    @clock()</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">snooze</span>(<span class="params">seconds</span>):</span></span><br><span class="line">        time.sleep(seconds)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        snooze(<span class="number">.123</span>)</span><br></pre></td></tr></table></figure>

<p><strong>装饰器最好的是通过<code>__call__</code>方法的类实现</strong></p>
<h2 id="7-11-本章小结"><a href="#7-11-本章小结" class="headerlink" title="7.11 本章小结"></a>7.11 本章小结</h2><p><strong>阅读清单</strong></p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://github.com/GrahamDumpleton/wrapt/blob/develop/blog/README.md"><strong>Implement Decorator</strong></a> [Graham Dumpleton ]</p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://www.artima.com/weblogs/viewpost.jsp?thread=101605"><strong>singledispatch</strong></a> [Guido van Rossum]</p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://effbot.org/zone/closure.htm"><strong>Closures</strong></a> [Fredrik Lundh]</p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://www.python.org/dev/peps/pep-3104/"><strong>nonlocal</strong></a>  </p>
</li>
</ul>
<p><strong>杂谈</strong></p>
<p>把函数作为一等对象, 就必须要考虑一个问题: 作为一等对象的函数在某个作用域中定义, 但可能会在其他作用域中调用, 如何计算自由变量呢? python给出的答案是”词法作用域”(根据定义函数的环境计算自由变量)</p>
<h1 id="Part8-ObjectOriented"><a href="#Part8-ObjectOriented" class="headerlink" title="Part8 ObjectOriented"></a>Part8 ObjectOriented</h1><blockquote>
<p>本章目标如下:</p>
</blockquote>
<ul>
<li><input disabled="" type="checkbox"> variable is mark not box that stores data in python</li>
<li><input disabled="" type="checkbox"> object reference</li>
<li><input disabled="" type="checkbox"> mutable | varibility</li>
<li><input disabled="" type="checkbox"> garbage collection</li>
<li><input disabled="" type="checkbox"> tuple is unmutable data structure but it`s element can change</li>
<li><input disabled="" type="checkbox"> shallow copy and deep copy</li>
<li><input disabled="" type="checkbox"> object mark | value | weak reference | strong reference</li>
<li><input disabled="" type="checkbox"> del</li>
</ul>
<h2 id="8-1-变量不是盒子"><a href="#8-1-变量不是盒子" class="headerlink" title="8.1 变量不是盒子"></a>8.1 变量不是盒子</h2><ol>
<li>变量不存储数据, 其是marker, 用来标记数据</li>
<li>多个变量标记同一个对象, 称为alias</li>
<li>赋值=, 先执行右边的对象计算, 对象在右边创建或获取, 在此之后创建变量并将变量标记(绑定)到对象上</li>
</ol>
<h2 id="8-2-标识-相等性-别名"><a href="#8-2-标识-相等性-别名" class="headerlink" title="8.2 标识|相等性|别名"></a>8.2 标识|相等性|别名</h2><p><strong>标识</strong>: 对象在内存中的地址, 一个对象一旦创建, 在其生命周期内, 其标识不会改变, 返回标识的整数表示:<code>id()</code> 判断标识是否相等: <code>is</code></p>
<p><strong>别名</strong>: 多个变量绑定到同一个对象上, 这些变量统称为这个对象的别名, 别名具有等幂性(is == id)三等</p>
<p><strong>相等性</strong>: <code>python</code>有两种相等性 数值相等通过对象定义的<code>__eq__ or __len__</code>定义以及内存地址相等<code>__id__</code>, 两者的运算符分别是<code>==</code> <code>is</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">b = &#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">c = a</span><br><span class="line"></span><br><span class="line">print(b == c, b <span class="keyword">is</span> c, a <span class="keyword">is</span> c)</span><br><span class="line">print(<span class="built_in">id</span>(a), <span class="built_in">id</span>(c), <span class="built_in">id</span>(b))</span><br><span class="line">&gt;&gt;</span><br><span class="line"><span class="literal">True</span> <span class="literal">False</span> <span class="literal">True</span></span><br><span class="line"><span class="number">2478949962920</span> <span class="number">2478949962920</span> <span class="number">2478949963144</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>对象的id在不同的实现中有所不同, Cpython中表示内存地址, 但其他的解释器中可能是别的值, 其本质是保证id唯一且在对象的声明周期内不可更改</p>
</blockquote>
<h3 id="8-2-1-is"><a href="#8-2-1-is" class="headerlink" title="8.2.1 is | =="></a>8.2.1 is | ==</h3><blockquote>
<p>is: 比较两个对象的标识</p>
<p>==: 比较两个对象的值(存储的数据)</p>
</blockquote>
<p>在变量与单例值的比较中使用<code>is</code>如与<code>None</code>的比较(查看变量绑定的值是否是<code>None</code>)</p>
<p>多数情况下, <code>is</code>运算比<code>==</code>快很多, 因为前者不能重载, 两者本质上的魔法方法是<code>__id__</code>和<code>__eq__ + define by oneself</code> </p>
<h3 id="8-2-2-元组的相对不可变性"><a href="#8-2-2-元组的相对不可变性" class="headerlink" title="8.2.2 元组的相对不可变性"></a>8.2.2 元组的相对不可变性</h3><blockquote>
<p>relative immutability of tuple</p>
</blockquote>
<p>元组和多数<code>python collection</code>一样其内部存储的都是对象的引用, 如果引用的元素本身是可变的, 即使元组不可变其元素依然可变</p>
<p><strong>元组的相对不变性指的是:tuple数据结构的物理内容(保存的引用)不可变[id()], 与引用的对象无关</strong></p>
<blockquote>
<p>str bytes array.array等单一类型序列是扁平的, 他们保存的不是引用而是在连续的内存中保存数据本身</p>
</blockquote>
<p><strong>元组中不变的是元组的标识id(), 与其内部的对象引用本身无关, 因此有些元组是不可以散列的</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">t1 = (<span class="number">1</span>, <span class="number">2</span>, [<span class="number">1</span>, <span class="number">10</span>])</span><br><span class="line">t2 = (<span class="number">1</span>, <span class="number">2</span>, [<span class="number">1</span>, <span class="number">10</span>])</span><br><span class="line"></span><br><span class="line">print(<span class="built_in">id</span>(t1))</span><br><span class="line">print(t1 == t2)</span><br><span class="line"></span><br><span class="line">t1[-<span class="number">1</span>].append(<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">print(t1)</span><br><span class="line">print(t1 == t2)</span><br><span class="line">print(<span class="built_in">id</span>(t1))</span><br><span class="line">&gt;&gt;</span><br><span class="line"><span class="number">2375749450792</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, [<span class="number">1</span>, <span class="number">10</span>, <span class="number">100</span>])</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="number">2375749450792</span></span><br></pre></td></tr></table></figure>

<h2 id="8-3-默认做潜复制"><a href="#8-3-默认做潜复制" class="headerlink" title="8.3 默认做潜复制"></a>8.3 默认做潜复制</h2><blockquote>
<p>shallow copy by default</p>
</blockquote>
<blockquote>
<p> Python operations perform shallow copies by default, no special declaration is required</p>
</blockquote>
<p>复制列表(或多数内置的可变集合)最简单的方式是使用内置的类型构造方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], (<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)]</span><br><span class="line">b = <span class="built_in">list</span>(a)</span><br><span class="line"></span><br><span class="line">a.append(<span class="number">7</span>)</span><br><span class="line">a[<span class="number">1</span>].remove(<span class="number">2</span>)</span><br><span class="line">print(<span class="string">f&quot;a: <span class="subst">&#123;a&#125;</span>&quot;</span>)</span><br><span class="line">print(<span class="string">f&quot;b: <span class="subst">&#123;b&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># list -&gt; mutable type iadd will extend ori obj</span></span><br><span class="line">b[<span class="number">1</span>] += [<span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="comment"># tuple -&gt; immutable type iadd will create a new obj</span></span><br><span class="line">b[<span class="number">2</span>] += (<span class="number">7</span>, <span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">f&quot;a: <span class="subst">&#123;a&#125;</span>&quot;</span>)</span><br><span class="line">print(<span class="string">f&quot;b: <span class="subst">&#123;b&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">&gt;&gt;</span><br><span class="line">a: [<span class="number">1</span>, [<span class="number">3</span>], (<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>), <span class="number">7</span>]</span><br><span class="line">b: [<span class="number">1</span>, [<span class="number">3</span>], (<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)]</span><br><span class="line">a: [<span class="number">1</span>, [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], (<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>), <span class="number">7</span>]</span><br><span class="line">b: [<span class="number">1</span>, [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], (<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>)]</span><br></pre></td></tr></table></figure>

<p><strong>构造方法或[:]都是浅复制(复制了最外层容器, 副本中的元素是源容器的引用), 如果容器内部的元素都是不可变的, 那么不会出现异常且会节约内存, 如果容器内的元素有可变类型的, 对容器内的元素进行操作会有异常现象</strong></p>
<hr>
<p>浅复制容易操作, 但对于可变类型来说会出现异常情况</p>
<h3 id="8-3-1-DeepCopy"><a href="#8-3-1-DeepCopy" class="headerlink" title="8.3.1 DeepCopy"></a>8.3.1 DeepCopy</h3><blockquote>
<p>sometime, we will use deep copy to avoid exception.</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line"><span class="comment"># shallow copy </span></span><br><span class="line">copy.copy(iterable obj)</span><br><span class="line"></span><br><span class="line"><span class="comment"># deep copy </span></span><br><span class="line">copy.deepcopy(iterable obj)</span><br></pre></td></tr></table></figure>

<p><strong>一般情况下深复制不是一件简单的事情, 因为有嵌套引用的存在, 但有时深复制可能太深, 对象会引用不该复制的外部资源或单例值, 我们可以是实现<code>__copy__()</code> <code>__deepcopy__()</code> magic method 来自定义copy以及deepcopy的行为</strong></p>
<h2 id="8-4-函数的参数作为引用时"><a href="#8-4-函数的参数作为引用时" class="headerlink" title="8.4 函数的参数作为引用时"></a>8.4 函数的参数作为引用时</h2><blockquote>
<p>python唯一支持的参数传递方式是&lt;共享传参&gt;, 并且大多数面向对象语言都采用这一模式</p>
</blockquote>
<p><strong>共享传参指函数的各个形式参数获得实参中各个引用的副本, 换句话说函数内部的形参是实参的别名, 这种方式可能会修改作为参数传入的可变对象, 但是无法修改那些对象的标识(不能把一个对象替换成另一个对象)</strong></p>
<p><strong>函数对改变任何传入的可变参数</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">a, b</span>):</span></span><br><span class="line">    a += b</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">x, y = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">a, b = [<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">c, d = (<span class="number">1</span>, <span class="number">2</span>), (<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">f(x, y)</span><br><span class="line">f(a, b)</span><br><span class="line">f(c, d)</span><br><span class="line"></span><br><span class="line">print(x, y)</span><br><span class="line">print(a, b)</span><br><span class="line">print(c, d)</span><br><span class="line">&gt;&gt;</span><br><span class="line"><span class="number">1</span> <span class="number">1</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>] [<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>) (<span class="number">3</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<h3 id="8-4-1-不要使用可变类型作为参数的默认值"><a href="#8-4-1-不要使用可变类型作为参数的默认值" class="headerlink" title="8.4.1 不要使用可变类型作为参数的默认值"></a>8.4.1 不要使用可变类型作为参数的默认值</h3><blockquote>
<p>可选参数设置默认值可以使API在进化的同时保证向后兼容, 但是我们应该避免使用可变参数作为参数的默认值</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HanutedBus</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;this is a haunted bus&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, passengers=[]</span>):</span></span><br><span class="line">        self.passengers = passengers</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pick</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        self.passengers.append(name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">drop</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        self.passengers.remove(name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;<span class="subst">&#123;self.passengers&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bus1 = HanutedBus([<span class="string">&quot;Drink&quot;</span>, <span class="string">&quot;Star&quot;</span>])</span><br><span class="line">bus1.pick(<span class="string">&quot;Fire&quot;</span>)</span><br><span class="line">bus1.drop(<span class="string">&quot;Drink&quot;</span>)</span><br><span class="line">print(bus1)</span><br><span class="line"></span><br><span class="line">bus2 = HanutedBus()</span><br><span class="line">bus2.pick(<span class="string">&quot;Haunt&quot;</span>)</span><br><span class="line">print(bus2)</span><br><span class="line"></span><br><span class="line">bus3 = HanutedBus()</span><br><span class="line">print(bus3)</span><br><span class="line">&gt;&gt;</span><br><span class="line">[<span class="string">&#x27;Star&#x27;</span>, <span class="string">&#x27;Fire&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;Haunt&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;Haunt&#x27;</span>]</span><br><span class="line"><span class="comment"># bus2 bus3 共用了一个passengers list对象</span></span><br></pre></td></tr></table></figure>

<p><strong>在实例化对象时, 如果passengers为空, self.passengers变成了passengers参数默认值的别名, 这是因为默认值在定义函数时计算(通常在加载模块中), 因此默认值变成了函数对象的属性</strong></p>
<p>我们可以通过审查<code>HauntedBus.__init__</code>对象, 查看其中的<code>__defaults__</code>属性中的<code>haunted passengers</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="built_in">dir</span>(HanutedBus.__init__))</span><br><span class="line">print(HanutedBus.__init__.__defaults__)</span><br><span class="line">&gt;&gt;</span><br><span class="line">[<span class="string">&#x27;__annotations__&#x27;</span>, ..., <span class="string">&#x27;defaults&#x27;</span>]</span><br><span class="line">([<span class="string">&#x27;Haunt&#x27;</span>],)</span><br></pre></td></tr></table></figure>

<p>通过验证得出<code>bus2.passengers</code>是一个别名, 它绑定到了<code>HauntedBus.__init__.__defaults__</code>属性的第一个元素上:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HauntedBus._-init__ --&gt; return &gt;&gt;function</span><br><span class="line"></span><br><span class="line">HanutedBus.__init__.__defaults__[<span class="number">0</span>] <span class="keyword">is</span> bus2.passengers</span><br><span class="line">&gt;&gt; <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h3 id="8-4-2-Defense-Var-Paras"><a href="#8-4-2-Defense-Var-Paras" class="headerlink" title="8.4.2 Defense Var Paras"></a>8.4.2 Defense Var Paras</h3><blockquote>
<p>预防可变参数是指: 是否将在函数|类中对参数的处理体现到函数外部</p>
</blockquote>
<ul>
<li>防御可变参数最好的方式是: 类或函数自己维护参数, 通过<code>built-in constructor</code> 构造自己的参数</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HanutedBus</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;this is a haunted bus&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, passengers=<span class="literal">None</span></span>):</span></span><br><span class="line">        <span class="keyword">if</span> passengers <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.passengers = []</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">        	self.passengers = <span class="built_in">list</span>(passengers)</span><br></pre></td></tr></table></figure>

<p><strong>除非希望这个方法修改传入的参数对象, 否则在类中直接把参数赋值给实例变量之前一定要深思, 因此这样会为参数对象创建别名, 如果不确定就使用&lt;创建副本&gt;的方式取变量</strong></p>
<h2 id="8-5-Del-amp-GC"><a href="#8-5-Del-amp-GC" class="headerlink" title="8.5 Del &amp; GC"></a>8.5 Del &amp; GC</h2><blockquote>
<p>del: 删除名称, 通过删除名称减少对象引用, 进而会导致删除对象(引用为0)</p>
<p>对象不会自行销毁; 然而无法得到对象时, 可能会被当作垃圾回收</p>
</blockquote>
<p>对象销毁情况:</p>
<ul>
<li>对象引用为0</li>
<li>对象仅存在相互引用(垃圾回收程序会判断两者都无法获取进而销毁)</li>
<li>重新绑定对象导致引用为0</li>
<li>无法得到对象</li>
</ul>
<p><code>__del__</code>特殊方法不会销毁实例, 不应该在代码中调用, 但在即将销毁实例时<code>Python</code>解释器会调用<code>__del__</code>给实例释放外部资源的机会</p>
<p><code>Cpython</code>垃圾回收算法:</p>
<p><strong>引用计数</strong></p>
<ul>
<li>每个对象都会统计有多少引用指向自己</li>
<li>当引用数为0时, 调用<code>__del__</code>(如果定义了)并销毁对象</li>
<li>释放分配给对象的资源(内存)</li>
</ul>
<p><strong>分代垃圾回收算法 [Cpy2.0]</strong></p>
<ul>
<li>检测引用循环中涉及的对象组</li>
<li>如果一组对象之间全是相互引用, 即使在出色的引用方式也会导致组中的对象不可获取</li>
</ul>
<p><strong>更复杂的收回算法</strong></p>
<ul>
<li>也有不依赖引用的垃圾回收算法, 这意味者对象引用数量为0时, 可能不会立即调用<code>__del__</code>方法</li>
</ul>
<p>使用弱引用可以监控对象的生命周期</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> weakref</span><br><span class="line">a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">b = a</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bye</span>():</span></span><br><span class="line">    print(<span class="string">&quot;Gone with the wind...&quot;</span>)</span><br><span class="line"></span><br><span class="line">ender = weakref.finalize(a, bye)</span><br><span class="line">print(ender.alive)</span><br><span class="line"><span class="keyword">del</span> a</span><br><span class="line">print(ender.alive)</span><br><span class="line"><span class="keyword">del</span> b</span><br><span class="line">print(ender.alive)</span><br><span class="line">&gt;&gt;</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line">Gone <span class="keyword">with</span> the wind...</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h2 id="8-6-weakrefence"><a href="#8-6-weakrefence" class="headerlink" title="8.6 weakrefence"></a>8.6 weakrefence</h2><blockquote>
<p>弱引用不会增加对象的引用数量, 不会妨碍对象被当作垃圾回收, 往往用在缓存中</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> weakref</span><br><span class="line"></span><br><span class="line">a_set = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="comment"># 创建一个弱引用对象</span></span><br><span class="line">wref = weakref.ref(a_set)</span><br><span class="line"></span><br><span class="line">print(wref)</span><br><span class="line"><span class="comment"># 调用wref()返回被引用的对象</span></span><br><span class="line">print(wref())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重绑定</span></span><br><span class="line">a_set = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">print(wref)</span><br><span class="line">print(wref())</span><br><span class="line">print(wref() <span class="keyword">is</span> <span class="literal">None</span>)</span><br><span class="line">&gt;&gt;</span><br><span class="line">&lt;weakref at <span class="number">0x0000026B7900EF98</span>; to <span class="string">&#x27;set&#x27;</span> at <span class="number">0x0000026B791F1E48</span>&gt;</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">&lt;weakref at <span class="number">0x0000026B7900EF98</span>; dead&gt;</span><br><span class="line"><span class="literal">None</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>wref</code> 重新监测弱引用对象是否被释放|未释放返回对象|否则返回None</li>
<li><code>wref()</code> 获取最近监测的弱引用对象</li>
</ul>
<p>需要注意的是: <code>weakref.ref</code>类是一个底层接口, 供高级用途使用, 多数程序最好使用<code>weakref</code>集合和<code>finalize</code></p>
<ul>
<li><code>WeakKeyDictionary</code></li>
<li><code>WeakValueDictionary</code></li>
<li><code>WeakSet</code></li>
<li><code>finalize</code>(在内部使用弱引用)</li>
<li>不建议手动创建并处理<code>weakref.ref</code>实例</li>
</ul>
<h3 id="8-6-1-WeakValueDict"><a href="#8-6-1-WeakValueDict" class="headerlink" title="8.6.1 WeakValueDict"></a>8.6.1 WeakValueDict</h3><blockquote>
<p>此类实现的是可变映射, 里面的<code>value</code>是对象的<code>weakreference</code>, 当被引用的对象被当作垃圾回收后, 对应的键会自动删除, 因此其常常用作缓存<code>cache</code></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> weakref</span><br><span class="line">stock = weakref.WeakValueDictionary()</span><br><span class="line">catalog = [cheese(<span class="string">&quot;Red&quot;</span>), cheese(<span class="string">&quot;Blue&quot;</span>), cheese(<span class="string">&quot;Green&quot;</span>), cheese(<span class="string">&quot;White&quot;</span>)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> cheese <span class="keyword">in</span> catalog:</span><br><span class="line">    stock[cheese.kind] = cheese</span><br><span class="line"></span><br><span class="line">print(<span class="built_in">list</span>(stock.values()))</span><br><span class="line">print(<span class="built_in">list</span>(stock.keys()))</span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> catalog</span><br><span class="line"></span><br><span class="line">print(<span class="built_in">list</span>(stock.values()))</span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> cheese</span><br><span class="line"></span><br><span class="line">print(<span class="built_in">globals</span>())</span><br><span class="line">print(<span class="built_in">list</span>(stock.values()))</span><br><span class="line">&gt;&gt;</span><br><span class="line">[-Red, -Blue, -Green, -White]</span><br><span class="line">[<span class="string">&#x27;Red&#x27;</span>, <span class="string">&#x27;Blue&#x27;</span>, <span class="string">&#x27;Green&#x27;</span>, <span class="string">&#x27;White&#x27;</span>]</span><br><span class="line">[-White]</span><br><span class="line">&#123;<span class="string">&#x27;stock&#x27;</span>: &lt;WeakValueDictionary at <span class="number">0x1e8719b5a88</span>&gt;&#125;</span><br><span class="line">[]</span><br></pre></td></tr></table></figure>

<ul>
<li>在<code>del catalog</code>后查看<code>stock</code>发现仍有一个<code>white</code>没有<code>deleted</code></li>
<li>这是因为还有一个临时变量<code>cheese</code>引用了<code>cheese(&quot;white&quot;)</code></li>
<li>可以通过<code>global()</code>验证, 临时变量如果是局部变量则会在函数返回时被销毁, 但是在此次例子中, <code>cheese</code>是<code>for loop</code>中的全局变量, 需要手动(显式)删除</li>
</ul>
<p>与<code>WeakValueDictionary</code>相对应的是<code>WeakKeyDictionary</code>, 后者的键是弱引用, 其用途为:</p>
<ol>
<li>可以为应用中其他部分拥有的对象附加数据, 这样无需为对象添加属性(这对覆盖属性访问权限的对象尤其有用)</li>
</ol>
<p><strong>WeakSet</strong></p>
<blockquote>
<p>保存元素弱引用的集合类, 元素没有强引用时, 集合会将它删除, 如果一个类需要知道所有实例, 一种好的方案是创建一个weakset类型的类属性, 保存实例的引用, 直到实例被回收, 否则其存在时间和python进程一样长</p>
</blockquote>
<p><strong><a target="_blank" rel="noopener" href="https://blog.csdn.net/Spade_/article/details/108114785">weakkey|valuedict|set例子参考</a></strong></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/marsggbo/p/14831456.html"><strong>weakfinalize</strong></a></p>
<h3 id="8-6-2-Limitions-WF"><a href="#8-6-2-Limitions-WF" class="headerlink" title="8.6.2 Limitions(WF)"></a>8.6.2 Limitions(WF)</h3><blockquote>
<p>the limitions of weak reference</p>
</blockquote>
<p>不是所有<code>python</code>对象都可以作为弱引用的目标, <code>list</code> <code>dict</code>实例就不可, 但是它们的子类可以解决这个问题</p>
<p>具体限制如下(受于Cpython的实现细节, 其他解释器可能有所不同), 这些局限时内部优化导致的结果</p>
<ul>
<li>list -&gt; 其子类可以弱引用</li>
<li>dict -&gt; 其子类可以弱引用</li>
<li>int -&gt; 不可引用|子类也不可</li>
<li>tuple -&gt; 不可引用|子类也不可 </li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyList</span>(<span class="params"><span class="built_in">list</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span></span><br><span class="line">a_list = MyList(<span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line">wref_to_a_sub_list = weakref.ref(a_list)</span><br><span class="line">temp = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">wref_to_a_list = weakref.ref(temp)</span><br><span class="line"></span><br><span class="line">&gt;&gt;</span><br><span class="line"><span class="comment"># list不可以直接弱引用</span></span><br><span class="line">wref_to_a_list = weakref.ref(temp)</span><br><span class="line">TypeError: cannot create weak reference to <span class="string">&#x27;list&#x27;</span> <span class="built_in">object</span></span><br></pre></td></tr></table></figure>

<h2 id="8-7-Py对不可变类型的实现"><a href="#8-7-Py对不可变类型的实现" class="headerlink" title="8.7 Py对不可变类型的实现"></a>8.7 Py对不可变类型的实现</h2><ol>
<li><code>Cpython</code>为了优化将不可变类型的<code>copy</code> <code>[:]</code> 等不创建副本而是指向同一个引用</li>
<li>收到影响的有<code>tuple</code> <code>int</code> <code>str</code>  <code>bytes</code> <code>frozenset</code></li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">&quot;121&quot;</span></span><br><span class="line">b = <span class="string">&quot;121&quot;</span></span><br><span class="line"></span><br><span class="line">print(a == b)</span><br><span class="line">print(a <span class="keyword">is</span> b)</span><br><span class="line">&gt;&gt;</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>共享字符串字面量是一种优化措施, 称为<strong>驻留</strong></p>
<p>这些<code>trick</code>的目的时节省内存提升解释器的速度</p>
<h2 id="8-8-Summary"><a href="#8-8-Summary" class="headerlink" title="8.8 Summary"></a>8.8 Summary</h2><h3 id="Python对象三要素"><a href="#Python对象三要素" class="headerlink" title="Python对象三要素"></a><strong>Python对象三要素</strong></h3><table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>标识(id)</td>
<td>不可变</td>
<td>一般是整数内存地址, 通过id()获取, <code>is</code>比较</td>
<td>通过构造创建副本id()不同</td>
</tr>
<tr>
<td>类型(type)</td>
<td>可变但不推荐变化</td>
<td>通过<code>__class__</code>属性指定其他类</td>
<td></td>
</tr>
<tr>
<td>值(value)</td>
<td>可变</td>
<td>通过<code>==</code>比较</td>
<td>赋值 | 引用</td>
</tr>
</tbody></table>
<p>一般俩个变量具有相同的值<code>== -&gt; True</code>, 有两种情况, 副本或者别名(共同引用), 对于不可变对象没啥区别, 如果涉及到可变变量需要小心</p>
<h3 id="变量保存的是引用"><a href="#变量保存的是引用" class="headerlink" title="变量保存的是引用"></a><strong>变量保存的是引用</strong></h3><ul>
<li>简单的赋值不创建副本, 副本一般通过<code>[:]</code> <code>构造list()..</code> <code>copy.deepcopy()</code> <ul>
<li>副本和引用不同的区别是, 是否开辟了内存创建了一个新对象(id不同)</li>
</ul>
</li>
<li><code>+=</code> <code>*=</code> 的增量赋值, 如果左边的变量绑定的是不可变对象, 则会创建一个新对象赋值, 否则是就地修改</li>
<li>对现有的变量赋予新值, 不会修改之前绑定的变量(重新绑定: 现有的变量绑定了其他对象), 需要注意的是, 如果该变量是该对象的唯一绑定那么, 绑定后该对象会被当作垃圾回收</li>
<li>以别名的形式给函数传参, 函数会修改通过参数传入的可变对象, 除非在函数中创建副本或传入不可变对象</li>
<li>使用可变类型作为函数参数的默认值有很大风险, 不推荐使用</li>
<li>在某些情况下需要保存对象的引用, 但不留存对象本身, 可以使用弱引用</li>
</ul>
<h3 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h3><p><code>==</code> 比较数值</p>
<p><code>is</code> 比较引用</p>
<p><strong>可变性</strong></p>
<p>1.<code>python</code>是面向对象编程语言, 在定义类的属性时可以是可变的或不可变的</p>
<p>2.可变对象会导致多线程编程难以实现, 因为一个线程修改了数据如果没有及时同步就会损坏数据, 但是过度同步会导致死锁</p>
<p><strong>对象析构和垃圾回收</strong></p>
<blockquote>
<p><code>python</code>没有直接销毁对象的机制, 而是通过引用, 避免销毁时存在强引用</p>
</blockquote>
<p><code>Cpython</code>主要用过<strong>引用计数</strong>实现垃圾回收, 但是在碰到循环引用时容易泄露内存**(由于疏忽或错误造成程序未能释放已经不再使用的 内存)<strong>在<code>Cpython2.0</code>后引入了</strong>分代垃圾回收**(可以将引用循环中不可获取的对象销毁)</p>
<p><strong>注意</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;wt&quot;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>).write(<span class="string">&quot;123&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>这行代码是安全的, 因为文件对象的引用数量会在<code>write</code>后归零, <code>Python</code>在销毁内存中表示文件的对象前, 会先关闭文件, 但是我们仍然提倡使用显示关闭文件, 即使用<code>with</code>语句, 他能保证文件一定会被关闭, 即使打开文件时抛出了异常也无妨</p>
<p>考虑到(其他环境|语言):</p>
<ul>
<li>回收程序复杂</li>
<li>销毁对象和关闭文件时间可能会更长</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;wt&quot;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">    fp.write(<span class="string">&quot;123&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="参数传递-引用传递"><a href="#参数传递-引用传递" class="headerlink" title="参数传递:引用传递"></a><strong>参数传递:引用传递</strong></h3><p>传递方式有两种:</p>
<p><strong>按值传递:函数得到的是参数副本</strong></p>
<p><strong>按引用传递: 函数得到的参数的指针(引用)</strong></p>
<p>在<code>python</code>中, 函数得到是参数的副本,但是参数始终是引用, 即参数引用的副本(共享参数)</p>
<h1 id="Part9-Python-Style-Obj"><a href="#Part9-Python-Style-Obj" class="headerlink" title="Part9 Python-Style Obj"></a>Part9 Python-Style Obj</h1><blockquote>
<p>Never use two leading underscores, it is  annoyingly selfish</p>
</blockquote>
<p>本章我们将自定义类并实现内置对象的结构和行为包括:</p>
<ul>
<li>支持用于生成对象其他表示形式的内置函数<code>repr()</code> <code>bytes()</code></li>
<li>使用一个类方法实现备选构造方法</li>
<li>扩展内置的<code>format()</code>和<code>str.format()</code></li>
<li>实现只读属性</li>
<li>将对象变为可散列的, 以便在<code>set</code> 或作为<code>dict</code>的 <code>key</code></li>
<li>利用<code>__solt__</code>节省内存</li>
<li>使用<code>@classmethod</code>和<code>@staticmethod</code>装饰器</li>
<li><code>python</code>的私有变量和受保护属性的用法约定和局限</li>
</ul>
<h2 id="9-1-Obj-Representation"><a href="#9-1-Obj-Representation" class="headerlink" title="9.1 Obj Representation"></a>9.1 Obj Representation</h2><blockquote>
<p>每种面向对象语言都有一种获取对象的字符串表示形式的标准方式, python提供了<code>str()</code> <code>repr()</code></p>
</blockquote>
<table>
<thead>
<tr>
<th>对象表示函数</th>
<th>表示类型</th>
<th>内置函数</th>
<th>返回类型</th>
</tr>
</thead>
<tbody><tr>
<td>str()</td>
<td>字符串表示</td>
<td><code>__str__()</code></td>
<td>str (Unicode-str)</td>
</tr>
<tr>
<td>repr()</td>
<td>字符串表示</td>
<td><code>__repr__()</code></td>
<td>str (Unicode-str)</td>
</tr>
<tr>
<td>bytes()</td>
<td>字节序列表示</td>
<td><code>__bytes__()</code></td>
<td>bytes</td>
</tr>
<tr>
<td>format()</td>
<td>特殊格式的字符串表示</td>
<td><code>__format__()</code></td>
<td>str (Unicode-str)</td>
</tr>
<tr>
<td>str.format()</td>
<td>特殊格式的字符串表示</td>
<td><code>__format__()</code></td>
<td>str (Unicode-str)</td>
</tr>
</tbody></table>
<h2 id="9-2-Vector-Class"><a href="#9-2-Vector-Class" class="headerlink" title="9.2 Vector Class"></a>9.2 Vector Class</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">from</span> array <span class="keyword">import</span> array</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span>:</span></span><br><span class="line">    type_code = <span class="string">&quot;d&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x, y</span>):</span></span><br><span class="line">        self.x = <span class="built_in">float</span>(x)</span><br><span class="line">        self.y = <span class="built_in">float</span>(y)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># unpacking</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> (i <span class="keyword">for</span> i <span class="keyword">in</span> (self.x, self.y))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        class_name = <span class="built_in">type</span>(self).__name__</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;<span class="subst">&#123;class_name&#125;</span> (<span class="subst">&#123;self.x&#125;</span>, <span class="subst">&#123;self.y&#125;</span> )&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">str</span>(<span class="built_in">tuple</span>(self))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__bytes__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">bytes</span>([<span class="built_in">ord</span>(self.type_code)]) +</span><br><span class="line">                <span class="built_in">bytes</span>(array(self.type_code, self)))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">tuple</span>(self) == <span class="built_in">tuple</span>(other)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__abs__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> math.hypot(self.x, self.y)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__bool__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bool</span>(<span class="built_in">abs</span>(self))</span><br></pre></td></tr></table></figure>

<h2 id="9-3-Alternative-Constructions-Method"><a href="#9-3-Alternative-Constructions-Method" class="headerlink" title="9.3 Alternative Constructions Method"></a>9.3 Alternative Constructions Method</h2><blockquote>
<p>实现将<code>Vector</code>的字节序列转成<code>Vector</code>实例</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 类方法使用classmethod装饰器修饰</span></span><br><span class="line"><span class="meta">@classmethod</span></span><br><span class="line"><span class="comment"># 不传入self(类的实例), 传入cls(类本身)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">frombytes</span>(<span class="params">cls, octets</span>):</span></span><br><span class="line">    <span class="comment"># 从第一个字节种获取type_code</span></span><br><span class="line">    type_code = <span class="built_in">chr</span>(octets[<span class="number">0</span>])</span><br><span class="line">    <span class="comment"># 使用传入的octets字节序列创建一个memoryview, 在使用typecode转换</span></span><br><span class="line">    memv = <span class="built_in">memoryview</span>(octets[<span class="number">1</span>:]).cast(type_code)</span><br><span class="line">    <span class="comment"># 拆包转换后的memoryview得到构造方法所需的一对参数</span></span><br><span class="line">    <span class="keyword">return</span> cls(*memv)</span><br></pre></td></tr></table></figure>

<h2 id="9-4-classmethod-staticmethod"><a href="#9-4-classmethod-staticmethod" class="headerlink" title="9.4 classmethod|staticmethod"></a>9.4 classmethod|staticmethod</h2><p><strong>@classmethod</strong></p>
<p>类方法装饰器|定义备选构造方法, 用它装饰的第一个函数参数必须是<code>cls</code>本身, 而非<code>self</code>类实例, 常用于创建新的类实例</p>
<p><strong>@staticmetho</strong></p>
<p>静态装饰器, 装饰的函数将会与类失去交互, 常用在和类相关联的函数定义中, 但实际效果和定义在类的上下文一样, 意义更在于一种提示</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_class</span>(<span class="params">*args</span>):</span></span><br><span class="line">        <span class="comment"># 第一个参数返回的始终是cls</span></span><br><span class="line">        <span class="keyword">return</span> args</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_static</span>(<span class="params">*args</span>):</span></span><br><span class="line">        <span class="keyword">return</span> args</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(Demo().test_static())</span><br><span class="line">print(Demo().test_static(<span class="string">&quot;sss&quot;</span>))</span><br><span class="line">print(Demo().test_class())</span><br><span class="line">print(Demo().test_class(<span class="string">&quot;sss&quot;</span>))</span><br><span class="line">&gt;&gt;</span><br><span class="line">()</span><br><span class="line">(<span class="string">&#x27;sss&#x27;</span>,)</span><br><span class="line">(&lt;class &#x27;__main__.Demo&#x27;&gt;,)</span><br><span class="line">(&lt;class &#x27;__main__.Demo&#x27;&gt;, &#x27;sss&#x27;)</span><br></pre></td></tr></table></figure>

<h2 id="9-5格式化显示"><a href="#9-5格式化显示" class="headerlink" title="9.5格式化显示"></a>9.5格式化显示</h2><blockquote>
<p>内置的<code>format()</code>和<code>str.format()</code>方法本质上调用的是<code>.__format__(format_spec)</code></p>
</blockquote>
<p><strong>格式规范微语言</strong></p>
<p><code>&#123;0.mass:5.2e&#125;</code></p>
<ul>
<li><code>0.mass</code>: 在代换字段句法种是字段名,</li>
<li><code>: </code>: 分隔符</li>
<li><code>5.2e</code>: 是格式说明符</li>
</ul>
<p><strong>格式规范微语言为一些内置类型提供了专用的表示代码, 比如</strong></p>
<ul>
<li><p><code>b</code> -&gt; 二进制 </p>
</li>
<li><p><code>x</code> -&gt; 十六进制的<code>int</code>型 </p>
</li>
<li><p><code>f</code>表示<code>float</code>类型</p>
</li>
<li><p><code>%</code> 百分数</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="built_in">format</span>(<span class="number">42</span>, <span class="string">&quot;b&quot;</span>))</span><br><span class="line">print(<span class="built_in">format</span>(<span class="number">42</span>, <span class="string">&quot;x&quot;</span>))</span><br><span class="line">print(<span class="built_in">format</span>(<span class="number">42</span>, <span class="string">&quot;.2f&quot;</span>))</span><br><span class="line">print(<span class="built_in">format</span>(<span class="number">2</span>/<span class="number">3</span>, <span class="string">&quot;.2%&quot;</span>))</span><br><span class="line">&gt;&gt;</span><br><span class="line"><span class="number">101010</span></span><br><span class="line">2a</span><br><span class="line"><span class="number">42.00</span></span><br><span class="line"><span class="number">66.67</span>%</span><br></pre></td></tr></table></figure>

<p><strong>格式规范微语言是可扩展的, 各个类可以自行决定如何解释<code>format_spec</code>参数, 并且一个类如果没有定义<code>__format__</code>方法, 从<code>Obj</code>继承的方法会返回<code>str(my_obj)</code></strong></p>
<hr>
<p><strong>格式规范微语言的本质上将类的部分参数以一定的格式显示</strong></p>
<h2 id="9-6-可散列的类"><a href="#9-6-可散列的类" class="headerlink" title="9.6 可散列的类"></a>9.6 可散列的类</h2><blockquote>
<p>可散列的类是指类实现了<code>__hash__</code> <code>__eq__</code>方法, 且类的实例在其生命周期内<code>hash()</code>不变, 有时还要实现<strong>属性的只读</strong></p>
</blockquote>
<p><strong>1.eq</strong></p>
<blockquote>
<p>使用<code>==</code>或其他方式判断两个类实例是否相等</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__eq__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">tuple</span>(self) == <span class="built_in">tuple</span>(other)</span><br></pre></td></tr></table></figure>

<p><strong>2.hash</strong></p>
<blockquote>
<p>最好使用位运算符异或运算, 混合各分量的散列值</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__hash__</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">hash</span>(self.x) ^ <span class="built_in">hash</span>(self.y)</span><br></pre></td></tr></table></figure>

<p><strong>3.属性只读</strong></p>
<blockquote>
<p>init属性时使用<code>self.__x</code>双前导保证属性的私有</p>
<p>在获取属性时, 返回私有属性并添加装饰器<code>@property</code>把读值标记为特性</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x, y</span>):</span></span><br><span class="line">    self.__x = x</span><br><span class="line">    self.__y = y</span><br><span class="line"></span><br><span class="line"><span class="meta">@property</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">x</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="keyword">return</span> self.__x</span><br></pre></td></tr></table></figure>

<p><strong>@property</strong></p>
<p>python @property 装饰器使一个方法可以像属性一样被使用，而不需要在调用的时候带上<code>()</code></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/366156798"><strong>[example]</strong></a></p>
<p><strong>4.不变性</strong></p>
<blockquote>
<p>我们有时需要实现类中的某些属性具有不可变性, 以便实现<code>__hash__</code>中的<code>id()</code>不变</p>
</blockquote>
<hr>
<p><strong>创建hashable类型, 不一定要实现[@property]特性, 也不一定要保护实例属性, 只需要正确的实现<code>__hash__</code>和<code>__eq__</code>方法即可, 但是, 实例的散列值绝不应该变化, 因此我们借机实现了只读属性</strong></p>
<h2 id="9-7-私有属性和受保护属性"><a href="#9-7-私有属性和受保护属性" class="headerlink" title="9.7 私有属性和受保护属性"></a>9.7 私有属性和受保护属性</h2><blockquote>
<p>首先明确两个概念, python虽然可以设置所谓的私有属性通过<code>two leading underscores </code>  但其并不是真正的<code>private attribute</code>而是一种的<code>name mangling</code>&lt;命名改写&gt;, 仅仅是一种保护装置, 通过将属性<code>name mangling</code>成<code>_CLS__attr</code>, 保护属性在继承或获取时隐藏, 但是我们依然可以使用<code>instance._cls__attr</code>获取属性或者对属性进行<code>update</code></p>
</blockquote>
<p><code>python</code>不像<code>Java</code>使用<code>private</code>修饰符创建私有属性, 但是<code>python</code>可以通过<code>self.__attr</code>将属性通过<code>name mangle</code>改写成<code>fake-private-attr</code>, 起到保护作用</p>
<p>这样改写在一些人看来是自私的, 也有人建议通过命名<code>soft-constraint</code>进行约束, 即约定<code>one leading downscore -&gt; self._x</code>, 如果担心命名冲突应该明确使用<code>_Cls_attr</code>进行属性命名</p>
<p><strong>name mangle &lt;名称改写&gt;是一个安全措施, 其保护的是意外改写, 不并不防止故意改写</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> array <span class="keyword">import</span> array</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span>:</span></span><br><span class="line">    type_code = <span class="string">&quot;d&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x, y</span>):</span></span><br><span class="line">        self.__x = x</span><br><span class="line">        self.__y = y</span><br><span class="line"></span><br><span class="line">vector = Vector(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">vector._Vector__x = <span class="number">3</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>python</code>解释器不会对单个下划线的属性名做特殊处理, 这仅仅是一种约定, 程序员应该遵守约定, 不再类外部访问这种属性, 就像使用全大写字母编写常量</li>
<li>但是在顶层名称使用一个前导下划线的话, 确实会有影响, 对<code>from mymod import *</code>, <code>mymod</code>中前缀为下划线的名称并不会导入, 但是依然可以使用<code>from mymod import _private_func</code>导入</li>
<li><code>python</code>文档中在类中使用<code>self._x single downsoce</code>很常见, 表示此属性为类的私有属性(很少有人称为受保护属性), 尽在内部使用(尽管是一个口头约定)</li>
</ul>
<p><strong>总结:</strong></p>
<p><strong>私有属性</strong>: 使用<code>self.__x</code>, 通过<code>name mangle</code>实现, 为了防止类在<code>inherit</code>时属性丢失以及外部访问, 但是它从本质上是一个取巧装置, 我们依然可以通过<code>_Cls_attr</code>外部访问并修改值</p>
<p><strong>受保护属性</strong>: 使用<code>self._x</code>, 完全通过口头约定, 的<code>soft sonstraint</code></p>
<h2 id="9-8-使用slots类属性节省内存"><a href="#9-8-使用slots类属性节省内存" class="headerlink" title="9.8 使用slots类属性节省内存"></a>9.8 使用slots类属性节省内存</h2><blockquote>
<p>默认情况下, <code>python</code>在各个实例中名为<code>__dict__</code>的字典里存储实例属性, 这样做的目的是为了使用底层的散列表提升访问速度, 但是字典会大量消耗内存, 如果要处理数百万个属性不多的实例, 通过<code>__slots__</code>类属性, 能节省大量内存, 其本质上是使用<code>tuple</code>存储实例属性而不是<code>dict</code></p>
</blockquote>
<p><strong>继承自超类的<code>__slots__</code>属性没有效果, <code>Python</code>只会使用各个类中定义的<code>__slots__</code>属性</strong></p>
<p>定义<code>__slots__</code>的方法是, 创建一个类属性, 使用<code>__slots__</code>这个名字, 并把它的值设为一个字符串构成的可迭代对象, 元素为每个实例属性, 建议使用元组避免信息发生变化</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Temp</span>:</span></span><br><span class="line">    <span class="comment"># define class`s slots attribute </span></span><br><span class="line">    __slots__ = (<span class="string">&quot;x&quot;</span>, <span class="string">&quot;y&quot;</span>, <span class="string">&quot;__name&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x, y, name</span>):</span></span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line">        self.__name = name</span><br></pre></td></tr></table></figure>

<ul>
<li>类中<code>__slots__</code>属性是告诉解释器, 类中的所有实例属性都在此, 这样<code>python</code>会在各个实例中使用类似元组的结构存储实例变量, 从而避免使用消耗内存的<code>__dict__</code>属性, 这样可以节省大量内存, 缓解服务器压力 <strong>(56%)</strong></li>
<li><code>__slots__</code>不仅可以降低内存消耗, 而且运行速度也会提升</li>
<li><code>__slots__</code>定义属性后, 实例不再有所列之外的属性, 这是<code>slots</code>的副作用, 其本质目的是为了提升内存使用率, 而不是为了约束内存, 也不推荐这样使用</li>
<li>如果在<code>__slots__</code>中添加<code>__dict__</code>, 那节省的内存会再次被吃掉, 实例会在元组中保存属性, 此外还支持动态创建属性, 这些动态属性会出存在<code>__dict__</code>中</li>
<li>如果要使对象支持弱引用<code>weak ref</code>, 必须在<code>__slots__</code>中添加<code>__weakref__</code></li>
<li>如果套处理数百万个数值对象, 应该使用<code>Numpy</code>数组, 其能够高效使用内存并对数值处理函数进行了高度优化</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">vector</span>:</span></span><br><span class="line">    __slots__ = (<span class="string">&quot;x&quot;</span>, <span class="string">&quot;y&quot;</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x, y, name</span>):</span></span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">vector1 = vector(<span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;Drink&quot;</span>)</span><br><span class="line">print(vector1.name)</span><br><span class="line">&gt;&gt;</span><br><span class="line">self.name = name</span><br><span class="line">AttributeError: <span class="string">&#x27;vector&#x27;</span> <span class="built_in">object</span> has no attribute <span class="string">&#x27;name&#x27;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># -----------------</span></span><br><span class="line">...</span><br><span class="line">__slots__ = (<span class="string">&quot;x&quot;</span>, <span class="string">&quot;y&quot;</span>, <span class="string">&quot;__dict__&quot;</span>)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;</span><br><span class="line">Drink</span><br><span class="line"></span><br><span class="line"><span class="comment"># ------------------</span></span><br><span class="line">print(vector1.__dict__)</span><br><span class="line">print(vector1.__slots__)</span><br><span class="line">&gt;&gt;</span><br><span class="line">&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Drink&#x27;</span>&#125;</span><br><span class="line">(<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;__dict__&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>slots的问题</strong></p>
<ul>
<li><p><code>__slots__</code>: 静态属性</p>
</li>
<li><p>不可滥用, 其存储的使静态属性, <code>__dict__</code> :存储动态属性</p>
</li>
<li><p>本质上是为了优化内存, 而不是约束属性获取</p>
</li>
<li><p>如果要同时实现对象的弱引用, 需要在其中添加<code>__weakref__</code></p>
</li>
<li><p>每个子类都要继承<code>__slots__</code>属性, 因为解释器会忽略继承</p>
</li>
<li><p>可以创建 禁止创建动态属性 和 不支持弱引用的类</p>
</li>
</ul>
<h2 id="9-9-OverrideClsAttr"><a href="#9-9-OverrideClsAttr" class="headerlink" title="9.9 OverrideClsAttr"></a>9.9 OverrideClsAttr</h2><blockquote>
<p>在定义<code>class</code>的属性时, 可以在<code>__init__</code>之外定义<code>class</code>属性而非<code>instance</code>属性, 并且这个属性可以直接通过<code>cls.attr</code>访问, 即是没有初始化实例对象, 也会生成对应的<code>cls.attr</code></p>
</blockquote>
<ol>
<li><strong>类属性作为实例属性的默认值, 一旦被实例化, 类属性从用法上将转化为实例属性</strong></li>
<li><strong>修改类属性必须通过类修改, 实例无法修改类属性</strong></li>
<li><strong>类属性也可以在子类中实现<code>Override</code></strong></li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Temp</span>:</span></span><br><span class="line">    a = <span class="number">1</span></span><br><span class="line">    b = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x, y</span>):</span></span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line"></span><br><span class="line">print(Temp.a)</span><br><span class="line">print(Temp.b)</span><br><span class="line">print(Temp.x)</span><br><span class="line">&gt;&gt;</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">AttributeError: <span class="built_in">type</span> <span class="built_in">object</span> <span class="string">&#x27;Temp&#x27;</span> has no attribute <span class="string">&#x27;x&#x27;</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="comment"># ============</span></span><br><span class="line">...</span><br><span class="line">    a = <span class="number">1</span></span><br><span class="line">    b = <span class="number">2</span></span><br><span class="line">    __slots__ = (<span class="string">&quot;x&quot;</span>, <span class="string">&quot;y&quot;</span>)</span><br><span class="line">...</span><br><span class="line">print(Temp.a)</span><br><span class="line">print(Temp.b)</span><br><span class="line">print(Temp.x)</span><br><span class="line">&gt;&gt;</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">&lt;member <span class="string">&#x27;x&#x27;</span> of <span class="string">&#x27;Temp&#x27;</span> objects&gt;</span><br></pre></td></tr></table></figure>

<p><code>python</code>中<code>class</code>与<code>instance</code>关于<code>attribute</code>的注意事项</p>
<ul>
<li>在定义<code>cls</code>属性时, 相当于给<code>instance</code>属性做了<code>default value</code>, 当两者属性<code>key</code>冲突时, 解释器取<code>instance</code>属性</li>
<li>在未定义<code>instance</code>属性并<code>slef.attr</code>获取时, 解释器回去取<code>cls</code>属性<code>(default value)</code></li>
<li><code>instance</code>可以更新<strong>自己的<code>cls</code>属性</strong><ul>
<li>可以通过在类中添加<code>__slots__</code>声明, 将属性变为静态属性, 即只能通过<code>cls</code>对属性进行更新, <code>instance</code>拿到的是<code>only-read</code></li>
<li><strong>类属性有个特点: 被实例化后变成&lt;实例属性&gt;</strong></li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Temp</span>:</span></span><br><span class="line">    a = <span class="number">1</span></span><br><span class="line">    b = <span class="number">2</span></span><br><span class="line">    __slots__ = (<span class="string">&quot;x&quot;</span>, <span class="string">&quot;y&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x, y</span>):</span></span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;a -&gt;<span class="subst">&#123;self.a&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">temp = Temp(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">print(temp.a)</span><br><span class="line"></span><br><span class="line">temp.a = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">temp2 = Temp(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">print(temp.a)</span><br><span class="line">&gt;&gt;</span><br><span class="line"><span class="number">1</span></span><br><span class="line">AttributeError: <span class="string">&#x27;Temp&#x27;</span> <span class="built_in">object</span> attribute <span class="string">&#x27;a&#x27;</span> <span class="keyword">is</span> read-only</span><br></pre></td></tr></table></figure>

<h2 id="9-10-Summary"><a href="#9-10-Summary" class="headerlink" title="9.10 Summary"></a>9.10 Summary</h2><p>本章主要实现了<code>python style</code>的对象</p>
<h3 id="有关对象的magic-method"><a href="#有关对象的magic-method" class="headerlink" title="有关对象的magic method"></a><strong>有关对象的magic method</strong></h3><ul>
<li>将对象用<code>str</code> <code>bytes</code>展示:<ul>
<li><code>__str__</code></li>
<li><code>__repr__</code></li>
<li><code>__format__</code></li>
<li><code>__bytes__</code></li>
</ul>
</li>
</ul>
<h3 id="备选构造方法"><a href="#备选构造方法" class="headerlink" title="备选构造方法"></a><strong>备选构造方法</strong></h3><p>通过对方法使用<code>@classmethod</code>装饰器, 将接收<code>cls</code>参数, 并重构<code>cls</code>返回一个类**(cls)**</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">	<span class="comment"># 类方法使用classmethod装饰器修饰</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="comment"># 不传入self(类的实例), 传入cls(类本身)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">frombytes</span>(<span class="params">cls, octets</span>):</span></span><br><span class="line">        <span class="comment"># 从第一个字节种获取type_code</span></span><br><span class="line">        type_code = <span class="built_in">chr</span>(octets[<span class="number">0</span>])</span><br><span class="line">        <span class="comment"># 使用传入的octets字节序列创建一个memoryview, 在使用typecode转换</span></span><br><span class="line">        memv = <span class="built_in">memoryview</span>(octets[<span class="number">1</span>:]).cast(type_code)</span><br><span class="line">        <span class="comment"># 拆包转换后的memoryview得到构造方法所需的一对参数</span></span><br><span class="line">        <span class="keyword">return</span> cls(*memv)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="可散列对象"><a href="#可散列对象" class="headerlink" title="可散列对象"></a><strong>可散列对象</strong></h3><ul>
<li>实现<code>__hash__</code> <code>__eq__</code></li>
<li>要保证对象在其生命周期内<code>hash(obj)</code>不会变化, 通常会选择<code>cls</code>中的部分属性, 将其<code>private_attr</code>并以特性<code>@property</code>变为私有只读属性, 并用异或<code>^ + hash(attr)</code> 实现<code>__hash__</code></li>
</ul>
<h3 id="节省内存"><a href="#节省内存" class="headerlink" title="节省内存"></a><strong>节省内存</strong></h3><ul>
<li>使用<code>__slots__</code>节省类的内存使用, 但是其本身也有其他作用<ul>
<li>不能隐式继承</li>
<li>声明的是静态属性与<code>__dict__</code>相反(动态属性)</li>
<li>会阻止不再声明内的属性的访问</li>
<li>如果要同时实现对象的弱引用, 需要在其中添加<code>__weakref__</code></li>
</ul>
</li>
</ul>
<h3 id="属性的覆盖"><a href="#属性的覆盖" class="headerlink" title="属性的覆盖"></a><strong>属性的覆盖</strong></h3><ul>
<li>类属性是实例属性的前置默认值, 类被实例化后, 类属性在表现形式上为实例属性</li>
<li>类属性无法通过实例修改</li>
<li>类属性在继承或实例化后可以<code>Override</code></li>
<li><strong>类属性 + <code>__slots__</code></strong> 可以实现<code>only-read</code></li>
</ul>
<h3 id="index"><a href="#index" class="headerlink" title="__index__"></a><strong><code>__index__</code></strong></h3><blockquote>
<p>作用: 将对象强制转化成整数索引</p>
<p>用途: 在特定的序列切片场景使用, 满足<code>Numpy</code>需求, 或需要新键一种数值类型, 并想把它作为参数传递给<code>__getitem__</code>方法</p>
</blockquote>
<h3 id="特性-gt-私有属性一起使用"><a href="#特性-gt-私有属性一起使用" class="headerlink" title="特性  -&gt; [私有属性一起使用]"></a><strong>特性  -&gt; [私有属性一起使用]</strong></h3><blockquote>
<p>@property </p>
<p>def attr()</p>
<p>将类中的方法以属性的方式访问, 如果方法和类同名, 可以避免属性被意外更新<code>(avoid accidental updates)</code></p>
<p><strong>和私有属性一起使用</strong></p>
</blockquote>
<p>在<code>python</code>中我们可以大胆定义属性, 在之后使用特性, 避免属性被意外更改</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.__x = x</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">x</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.__x</span><br><span class="line"></span><br><span class="line">    <span class="comment"># @x.setter</span></span><br><span class="line">    <span class="comment"># def x(self, new_x):</span></span><br><span class="line">    <span class="comment">#     self.__x = new_x</span></span><br><span class="line"></span><br><span class="line">test = Test(<span class="number">1</span>)</span><br><span class="line">print(test.x)</span><br><span class="line">test.x = <span class="number">2</span></span><br><span class="line">print(test.x)</span><br><span class="line">&gt;&gt; ori code</span><br><span class="line"><span class="number">1</span></span><br><span class="line">AttributeError: can<span class="string">&#x27;t set attribute</span></span><br></pre></td></tr></table></figure>

<p><strong>将@x.setter开打后</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<p><strong>将属性变为公开属性 <code>self.__x</code> =&gt; <code>self.x</code>初始化不成功</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RecursionError: maximum recursion depth exceeded</span><br></pre></td></tr></table></figure>

<h3 id="私有属性的安全和隐私"><a href="#私有属性的安全和隐私" class="headerlink" title="私有属性的安全和隐私"></a>私有属性的安全和隐私</h3><blockquote>
<p>严格意义上私有属性没有所谓的安全和隐私</p>
</blockquote>
<p><strong>私有属性:</strong></p>
<ul>
<li><code>self.__x</code></li>
<li><strong>soft constraint</strong></li>
<li>通过<code>instance._Cls__private</code>访问和修改</li>
</ul>
<p><strong>受保护属性</strong></p>
<ul>
<li><code>self._x</code></li>
<li>口头约束</li>
<li>直接访问和修改</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://drinkle.top/2022/02/06/%E6%B5%81%E7%95%85%E7%9A%84python/" data-id="ckzb823ai0000ngf5h2vdfe6t" data-title="流畅的python" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/" rel="tag">Python</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2022/02/22/python%E9%9D%A2%E8%AF%95%E9%A2%98/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">前一篇</strong>
      <div class="article-nav-title">
        
          python面试题
        
      </div>
    </a>
  
  
    <a href="/2021/11/14/%E7%BB%8F%E6%B5%8E%E5%88%86%E6%9E%90-1/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">后一篇</strong>
      <div class="article-nav-title">经济分析[1]</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/825%E8%AE%A1%E5%88%92/" rel="tag">825计划</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Algorithm/" rel="tag">Algorithm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/BuiltIn/" rel="tag">BuiltIn</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Daily-Plan/" rel="tag">Daily Plan</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Data-Structure/" rel="tag">Data Structure</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DataBase/" rel="tag">DataBase</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Drink/" rel="tag">Drink</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/English-Study/" rel="tag">English Study</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GoodNotes/" rel="tag">GoodNotes</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hexo/" rel="tag">Hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LeeCode/" rel="tag">LeeCode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mongodb/" rel="tag">Mongodb</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Object-Oriented/" rel="tag">Object Oriented</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Postgraduate/" rel="tag">Postgraduate</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/" rel="tag">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python%E5%90%8E%E7%AB%AF/" rel="tag">Python后端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spirit/" rel="tag">Spirit</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/consciousness/" rel="tag">consciousness</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/django/" rel="tag">django</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/source-code/" rel="tag">source-code</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%96%E7%95%8C%E8%A7%82/" rel="tag">世界观</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%96%E7%95%8C%E8%A7%82-%E6%96%B9%E6%B3%95%E8%AE%BA/" rel="tag">世界观 方法论</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AE%9E%E8%B7%B5/" rel="tag">实践</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B7%A6%E7%BF%BC%E5%90%8C%E7%9B%9F%E4%BC%9A/" rel="tag">左翼同盟会</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%96%B0%E9%97%BB%E8%81%94%E6%92%AD/" rel="tag">新闻联播</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%8B%AC%E5%88%B0%E7%A7%91%E6%8A%80/" rel="tag">独到科技</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%87%B4%E4%BD%A0%E7%9A%84%E4%B8%80%E5%B0%81%E4%BF%A1/" rel="tag">致你的一封信</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/825%E8%AE%A1%E5%88%92/" style="font-size: 13.33px;">825计划</a> <a href="/tags/Algorithm/" style="font-size: 10px;">Algorithm</a> <a href="/tags/BuiltIn/" style="font-size: 10px;">BuiltIn</a> <a href="/tags/Daily-Plan/" style="font-size: 10px;">Daily Plan</a> <a href="/tags/Data-Structure/" style="font-size: 10px;">Data Structure</a> <a href="/tags/DataBase/" style="font-size: 10px;">DataBase</a> <a href="/tags/Drink/" style="font-size: 13.33px;">Drink</a> <a href="/tags/English-Study/" style="font-size: 20px;">English Study</a> <a href="/tags/GoodNotes/" style="font-size: 10px;">GoodNotes</a> <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/LeeCode/" style="font-size: 10px;">LeeCode</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/Mongodb/" style="font-size: 10px;">Mongodb</a> <a href="/tags/MySQL/" style="font-size: 10px;">MySQL</a> <a href="/tags/Object-Oriented/" style="font-size: 10px;">Object Oriented</a> <a href="/tags/Postgraduate/" style="font-size: 10px;">Postgraduate</a> <a href="/tags/Python/" style="font-size: 16.67px;">Python</a> <a href="/tags/Python%E5%90%8E%E7%AB%AF/" style="font-size: 10px;">Python后端</a> <a href="/tags/Spirit/" style="font-size: 10px;">Spirit</a> <a href="/tags/consciousness/" style="font-size: 10px;">consciousness</a> <a href="/tags/django/" style="font-size: 10px;">django</a> <a href="/tags/source-code/" style="font-size: 10px;">source-code</a> <a href="/tags/%E4%B8%96%E7%95%8C%E8%A7%82/" style="font-size: 13.33px;">世界观</a> <a href="/tags/%E4%B8%96%E7%95%8C%E8%A7%82-%E6%96%B9%E6%B3%95%E8%AE%BA/" style="font-size: 10px;">世界观 方法论</a> <a href="/tags/%E5%AE%9E%E8%B7%B5/" style="font-size: 10px;">实践</a> <a href="/tags/%E5%B7%A6%E7%BF%BC%E5%90%8C%E7%9B%9F%E4%BC%9A/" style="font-size: 10px;">左翼同盟会</a> <a href="/tags/%E6%96%B0%E9%97%BB%E8%81%94%E6%92%AD/" style="font-size: 10px;">新闻联播</a> <a href="/tags/%E7%8B%AC%E5%88%B0%E7%A7%91%E6%8A%80/" style="font-size: 10px;">独到科技</a> <a href="/tags/%E8%87%B4%E4%BD%A0%E7%9A%84%E4%B8%80%E5%B0%81%E4%BF%A1/" style="font-size: 10px;">致你的一封信</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">二月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">十一月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">十月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">九月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">八月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">七月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">六月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">五月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">四月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">三月 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/02/22/python%E9%9D%A2%E8%AF%95%E9%A2%98/">python面试题</a>
          </li>
        
          <li>
            <a href="/2022/02/06/%E6%B5%81%E7%95%85%E7%9A%84python/">流畅的python</a>
          </li>
        
          <li>
            <a href="/2021/11/14/%E7%BB%8F%E6%B5%8E%E5%88%86%E6%9E%90-1/">经济分析[1]</a>
          </li>
        
          <li>
            <a href="/2021/11/14/%E6%96%B0%E9%97%BB%E8%81%94%E6%92%AD-2/">新闻联播[2]</a>
          </li>
        
          <li>
            <a href="/2021/10/07/Question/">Question</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 Drink<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>